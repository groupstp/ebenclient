<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {Component} from '../component';
import {Button} from '../button';
import template from './template.hbs'

export class Field extends Component {

    constructor(options) {
        super(options);

        this.name = options.element.properties.name || this.id;

        // DOM-объект контролирующего элемента (input или textarea)
        this.controlEl = null;
        // кнопки относящиеся именно к этому полю
        this.buttons = [];

        this.label = options.element.properties.label || '';
        this.type = options.element.properties.type;
        // при true используем textarea
        this.multiline = options.element.properties.multiline || false;

        this.hidden = options.element.properties.hidden || false;
        this.enabled = options.element.properties.enabled || true;
        this.required = options.element.properties.required || false;

        this._initField(options.element.elements);
    }

    ///// Private methods /////

    /**
     * Инициализация поля, поиск кнопок
     * @private
     */
    _initField(elements = []) {

        extractElements.call(this, elements);

        function extractElements(elements) {

            elements.forEach((el) => {
                searchForFormElements.call(this, el);
            });

        }

        function searchForFormElements(el) {

            let type = el.type;

            switch (type) {
                case 'button' :
                    this.buttons.push(new Button({
                        "element": el,
                        "code": this.prepareCode(this.code),
                        "parent": this
                    }));
                    break;
            }

        }

    }

    /**
     * Заполняет контейнер html содержимым
     * @private
     */
    _generateHTML() {

        if (!this.box) {
            this.box = document.createElement('div');
        }

        let requiredMark = (this.required) ? '&lt;sup style="color:red; margin-left: 4px">*&lt;/sup>' : '';

        // TODO переделать для checkbox'ов и radio кнопок
        this.box.innerHTML = template({
            "label": this.label,
            "requiredMark": requiredMark,
            "id": this.id,
            "name": this.name,
            "multiline" : this.multiline,
            "checkbox" : (this.type === 'checkbox') ? true : false
        });

        if (this.multiline) {
            this.controlEl = this.box.querySelector('textarea');
        } else {
            this.controlEl = this.box.querySelector('input');
        }

        this._renderButtons();

    }

    /**
     * Рисуем кнопки
     * @private
     */
    _renderButtons() {

        let btnsWrapper = this.box.querySelector('.field-btns-wrapper');

        if (!btnsWrapper) return;

        this.buttons.forEach((btn) => {
            btnsWrapper.appendChild(btn.render());
            btn.initLogic();
        });

    }

    /**
     * Метод определяет обязательное ли это поле
     * @returns {boolean}
     */
    isRequired(){
        if (this.required) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Окрашиваем поле в зеленный цвет(успешная валидация)
     */
    showSuccess(){
        this.removeNotifications();
        this.box.classList.add('has-success');
    }

    /**
     * Окрашиваем поле в красный цвет(неуспешная валидация)
     */
    showError(){
        this.removeNotifications();
        this.box.classList.add('has-error');
    }

    /**
     * Убираем любое окрашивание
     */
    removeNotifications(){
        this.box.classList.remove('has-success');
        this.box.classList.remove('has-error');
    }

    initLogic() {

        // если до сих пор не определен контейнер box - значит мы работаем с кастомным шаблоном, а в нем по стандарту поле должно быть завернуто в div с [data-component = "field"]
        if (!this.box) {
            let input = this.parent.box.querySelector('#' + this.id);
            this.controlEl = input;
            this.box = input.closest('[data-component = "field"]');
        }

        this.buttons.forEach((btn) => {
            btn.initLogic();
        });

        this.addHandlers();

    }

    applyProperties(){
        if (this.hidden) {
            this.hide();
        } else {
            this.show();
        }

        if (this.enabled) {
            this.enable();
        } else {
            this.disable();
        }
    }



    ///// Public methods /////


    enable() {
        this.buttons.forEach((btn) => {
            btn.enable();
        });
    }

    disable() {
        this.buttons.forEach((btn) => {
            btn.disable();
        });
    }

    setValue(newValue){

    }

    getValue(){

    }


    /**
     * Генерирует DOM элемент с полем и возвращает его
     * @returns {object} - DOM элемент с формой
     */
    render() {

        this._generateHTML();

        return this.box;

    }

}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.3</a> on Wed Aug 02 2017 08:17:36 GMT+0800 (RTZ 7 (зима))
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
