<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: main.bandle.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: main.bandle.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i &lt; chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		4: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData === 0) {
/******/ 			return new Promise(function(resolve) { resolve(); });
/******/ 		}
/******/
/******/ 		// a Promise means "currently loading".
/******/ 		if(installedChunkData) {
/******/ 			return installedChunkData[2];
/******/ 		}
/******/
/******/ 		// setup Promise in chunk cache
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunkData[2] = promise;
/******/
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = 'text/javascript';
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "js/" + chunkId + ".bandle.js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) {
/******/ 					chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				}
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module &amp;&amp; module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 32);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" &amp;&amp; typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj &amp;&amp; typeof Symbol === "function" &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&amp;': '&amp;amp;',
  '&lt;': '&amp;lt;',
  '>': '&amp;gt;',
  '"': '&amp;quot;',
  "'": '&amp;#x27;',
  '`': '&amp;#x60;',
  '=': '&amp;#x3D;'
};

var badChars = /[&amp;&lt;>"'`=]/g,
    possible = /[&amp;&lt;>"'`=]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i &lt; arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function isFunction(value) {
    return typeof value === 'function' &amp;&amp; toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value &amp;&amp; (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? toString.call(value) === '[object Array]' : false;
};

exports.isArray = isArray;
// Older IE versions do not directly support indexOf so we must implement our own, sadly.

function indexOf(array, value) {
  for (var i = 0, len = array.length; i &lt; len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string &amp;&amp; string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value &amp;&amp; value !== 0) {
    return true;
  } else if (isArray(value) &amp;&amp; value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" &amp;&amp; typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj &amp;&amp; typeof Symbol === "function" &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * jQuery JavaScript Library v2.2.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-05-20T17:23Z
 */

(function (global, factory) {

	if (( false ? "undefined" : _typeof(module)) === "object" &amp;&amp; _typeof(module.exports) === "object") {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ? factory(global, true) : function (w) {
			if (!w.document) {
				throw new Error("jQuery requires a window with a document");
			}
			return factory(w);
		};
	} else {
		factory(global);
	}

	// Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : undefined, function (window, noGlobal) {

	// Support: Firefox 18+
	// Can't be in strict mode, several libs including ASP.NET trace
	// the stack via arguments.caller.callee and Firefox dies if
	// you try to trace through "use strict" call chains. (#13335)
	//"use strict";
	var arr = [];

	var document = window.document;

	var _slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var support = {};

	var version = "2.2.4",


	// Define a local copy of jQuery
	jQuery = function jQuery(selector, context) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init(selector, context);
	},


	// Support: Android&lt;4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,


	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	    rdashAlpha = /-([\da-z])/gi,


	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function fcamelCase(all, letter) {
		return letter.toUpperCase();
	};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// Start with an empty selector
		selector: "",

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function toArray() {
			return _slice.call(this);
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function get(num) {
			return num != null ?

			// Return just the one element from the set
			num &lt; 0 ? this[num + this.length] : this[num] :

			// Return all the elements in a clean array
			_slice.call(this);
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function pushStack(elems) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge(this.constructor(), elems);

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
			ret.context = this.context;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function each(callback) {
			return jQuery.each(this, callback);
		},

		map: function map(callback) {
			return this.pushStack(jQuery.map(this, function (elem, i) {
				return callback.call(elem, i, elem);
			}));
		},

		slice: function slice() {
			return this.pushStack(_slice.apply(this, arguments));
		},

		first: function first() {
			return this.eq(0);
		},

		last: function last() {
			return this.eq(-1);
		},

		eq: function eq(i) {
			var len = this.length,
			    j = +i + (i &lt; 0 ? len : 0);
			return this.pushStack(j >= 0 &amp;&amp; j &lt; len ? [this[j]] : []);
		},

		end: function end() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function () {
		var options,
		    name,
		    src,
		    copy,
		    copyIsArray,
		    clone,
		    target = arguments[0] || {},
		    i = 1,
		    length = arguments.length,
		    deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;

			// Skip the boolean and the target
			target = arguments[i] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ((typeof target === "undefined" ? "undefined" : _typeof(target)) !== "object" &amp;&amp; !jQuery.isFunction(target)) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if (i === length) {
			target = this;
			i--;
		}

		for (; i &lt; length; i++) {

			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {

				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {

						if (copyIsArray) {
							copyIsArray = false;
							clone = src &amp;&amp; jQuery.isArray(src) ? src : [];
						} else {
							clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = jQuery.extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend({

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function error(msg) {
			throw new Error(msg);
		},

		noop: function noop() {},

		isFunction: function isFunction(obj) {
			return jQuery.type(obj) === "function";
		},

		isArray: Array.isArray,

		isWindow: function isWindow(obj) {
			return obj != null &amp;&amp; obj === obj.window;
		},

		isNumeric: function isNumeric(obj) {

			// parseFloat NaNs numeric-cast false positives (null|true|false|"")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			// adding 1 corrects loss of precision from parseFloat (#15100)
			var realStringObj = obj &amp;&amp; obj.toString();
			return !jQuery.isArray(obj) &amp;&amp; realStringObj - parseFloat(realStringObj) + 1 >= 0;
		},

		isPlainObject: function isPlainObject(obj) {
			var key;

			// Not plain objects:
			// - Any object or value whose internal [[Class]] property is not "[object Object]"
			// - DOM nodes
			// - window
			if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
				return false;
			}

			// Not own constructor property must be Object
			if (obj.constructor &amp;&amp; !hasOwn.call(obj, "constructor") &amp;&amp; !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own
			for (key in obj) {}

			return key === undefined || hasOwn.call(obj, key);
		},

		isEmptyObject: function isEmptyObject(obj) {
			var name;
			for (name in obj) {
				return false;
			}
			return true;
		},

		type: function type(obj) {
			if (obj == null) {
				return obj + "";
			}

			// Support: Android&lt;4.0, iOS&lt;6 (functionish RegExp)
			return (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
		},

		// Evaluates a script in a global context
		globalEval: function globalEval(code) {
			var script,
			    indirect = eval;

			code = jQuery.trim(code);

			if (code) {

				// If the code includes a valid, prologue position
				// strict mode pragma, execute code by injecting a
				// script tag into the document.
				if (code.indexOf("use strict") === 1) {
					script = document.createElement("script");
					script.text = code;
					document.head.appendChild(script).parentNode.removeChild(script);
				} else {

					// Otherwise, avoid the DOM node creation, insertion
					// and removal by using an indirect global eval

					indirect(code);
				}
			}
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE9-11+
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function camelCase(string) {
			return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
		},

		nodeName: function nodeName(elem, name) {
			return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function each(obj, callback) {
			var length,
			    i = 0;

			if (isArrayLike(obj)) {
				length = obj.length;
				for (; i &lt; length; i++) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (callback.call(obj[i], i, obj[i]) === false) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android&lt;4.1
		trim: function trim(text) {
			return text == null ? "" : (text + "").replace(rtrim, "");
		},

		// results is for internal usage only
		makeArray: function makeArray(arr, results) {
			var ret = results || [];

			if (arr != null) {
				if (isArrayLike(Object(arr))) {
					jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
				} else {
					push.call(ret, arr);
				}
			}

			return ret;
		},

		inArray: function inArray(elem, arr, i) {
			return arr == null ? -1 : indexOf.call(arr, elem, i);
		},

		merge: function merge(first, second) {
			var len = +second.length,
			    j = 0,
			    i = first.length;

			for (; j &lt; len; j++) {
				first[i++] = second[j];
			}

			first.length = i;

			return first;
		},

		grep: function grep(elems, callback, invert) {
			var callbackInverse,
			    matches = [],
			    i = 0,
			    length = elems.length,
			    callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for (; i &lt; length; i++) {
				callbackInverse = !callback(elems[i], i);
				if (callbackInverse !== callbackExpect) {
					matches.push(elems[i]);
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function map(elems, callback, arg) {
			var length,
			    value,
			    i = 0,
			    ret = [];

			// Go through the array, translating each of the items to their new values
			if (isArrayLike(elems)) {
				length = elems.length;
				for (; i &lt; length; i++) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}

				// Go through every key on the object,
			} else {
				for (i in elems) {
					value = callback(elems[i], i, arg);

					if (value != null) {
						ret.push(value);
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply([], ret);
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function proxy(fn, context) {
			var tmp, args, proxy;

			if (typeof context === "string") {
				tmp = fn[context];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if (!jQuery.isFunction(fn)) {
				return undefined;
			}

			// Simulated bind
			args = _slice.call(arguments, 2);
			proxy = function proxy() {
				return fn.apply(context || this, args.concat(_slice.call(arguments)));
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	});

	// JSHint would error on this code due to the Symbol not being defined in ES5.
	// Defining this global in .jshintrc would create a danger of using the global
	// unguarded in another place, it seems safer to just disable JSHint for these
	// three lines.
	/* jshint ignore: start */
	if (typeof Symbol === "function") {
		jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
	}
	/* jshint ignore: end */

	// Populate the class2type map
	jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
		class2type["[object " + name + "]"] = name.toLowerCase();
	});

	function isArrayLike(obj) {

		// Support: iOS 8.2 (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj &amp;&amp; "length" in obj &amp;&amp; obj.length,
		    type = jQuery.type(obj);

		if (type === "function" || jQuery.isWindow(obj)) {
			return false;
		}

		return type === "array" || length === 0 || typeof length === "number" &amp;&amp; length > 0 &amp;&amp; length - 1 in obj;
	}
	var Sizzle =
	/*!
  * Sizzle CSS Selector Engine v2.2.1
  * http://sizzlejs.com/
  *
  * Copyright jQuery Foundation and other contributors
  * Released under the MIT license
  * http://jquery.org/license
  *
  * Date: 2015-10-17
  */
	function (window) {

		var i,
		    support,
		    Expr,
		    getText,
		    isXML,
		    tokenize,
		    compile,
		    select,
		    outermostContext,
		    sortInput,
		    hasDuplicate,


		// Local document vars
		setDocument,
		    document,
		    docElem,
		    documentIsHTML,
		    rbuggyQSA,
		    rbuggyMatches,
		    matches,
		    contains,


		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		    preferredDoc = window.document,
		    dirruns = 0,
		    done = 0,
		    classCache = createCache(),
		    tokenCache = createCache(),
		    compilerCache = createCache(),
		    sortOrder = function sortOrder(a, b) {
			if (a === b) {
				hasDuplicate = true;
			}
			return 0;
		},


		// General-purpose constants
		MAX_NEGATIVE = 1 &lt;&lt; 31,


		// Instance methods
		hasOwn = {}.hasOwnProperty,
		    arr = [],
		    pop = arr.pop,
		    push_native = arr.push,
		    push = arr.push,
		    slice = arr.slice,

		// Use a stripped-down indexOf as it's faster than native
		// http://jsperf.com/thor-indexof-vs-for/5
		indexOf = function indexOf(list, elem) {
			var i = 0,
			    len = list.length;
			for (; i &lt; len; i++) {
				if (list[i] === elem) {
					return i;
				}
			}
			return -1;
		},
		    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",


		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",


		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",


		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
		    pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" + ")\\)|)",


		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp(whitespace + "+", "g"),
		    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
		    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
		    rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
		    rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
		    rpseudo = new RegExp(pseudos),
		    ridentifier = new RegExp("^" + identifier + "$"),
		    matchExpr = {
			"ID": new RegExp("^#(" + identifier + ")"),
			"CLASS": new RegExp("^\\.(" + identifier + ")"),
			"TAG": new RegExp("^(" + identifier + "|[*])"),
			"ATTR": new RegExp("^" + attributes),
			"PSEUDO": new RegExp("^" + pseudos),
			"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
			"bool": new RegExp("^(?:" + booleans + ")$", "i"),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
		},
		    rinputs = /^(?:input|select|textarea|button)$/i,
		    rheader = /^h\d$/i,
		    rnative = /^[^{]+\{\s*\[native \w/,


		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
		    rsibling = /[+~]/,
		    rescape = /'|\\/g,


		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
		    funescape = function funescape(_, escaped, escapedWhitespace) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox&lt;24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ? escaped : high &lt; 0 ?
			// BMP codepoint
			String.fromCharCode(high + 0x10000) :
			// Supplemental Plane codepoint (surrogate pair)
			String.fromCharCode(high >> 10 | 0xD800, high &amp; 0x3FF | 0xDC00);
		},


		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function unloadHandler() {
			setDocument();
		};

		// Optimize for push.apply( _, NodeList )
		try {
			push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
			// Support: Android&lt;4.0
			// Detect silently failing push.apply
			arr[preferredDoc.childNodes.length].nodeType;
		} catch (e) {
			push = { apply: arr.length ?

				// Leverage slice if possible
				function (target, els) {
					push_native.apply(target, slice.call(els));
				} :

				// Support: IE&lt;9
				// Otherwise append directly
				function (target, els) {
					var j = target.length,
					    i = 0;
					// Can't trust NodeList.length
					while (target[j++] = els[i++]) {}
					target.length = j - 1;
				}
			};
		}

		function Sizzle(selector, context, results, seed) {
			var m,
			    i,
			    elem,
			    nid,
			    nidselect,
			    match,
			    groups,
			    newSelector,
			    newContext = context &amp;&amp; context.ownerDocument,


			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

			results = results || [];

			// Return early from calls with invalid selector or context
			if (typeof selector !== "string" || !selector || nodeType !== 1 &amp;&amp; nodeType !== 9 &amp;&amp; nodeType !== 11) {

				return results;
			}

			// Try to shortcut find operations (as opposed to filters) in HTML documents
			if (!seed) {

				if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
					setDocument(context);
				}
				context = context || document;

				if (documentIsHTML) {

					// If the selector is sufficiently simple, try using a "get*By*" DOM method
					// (excepting DocumentFragment context, where the methods don't exist)
					if (nodeType !== 11 &amp;&amp; (match = rquickExpr.exec(selector))) {

						// ID selector
						if (m = match[1]) {

							// Document context
							if (nodeType === 9) {
								if (elem = context.getElementById(m)) {

									// Support: IE, Opera, Webkit
									// TODO: identify versions
									// getElementById can match elements by name instead of ID
									if (elem.id === m) {
										results.push(elem);
										return results;
									}
								} else {
									return results;
								}

								// Element context
							} else {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if (newContext &amp;&amp; (elem = newContext.getElementById(m)) &amp;&amp; contains(context, elem) &amp;&amp; elem.id === m) {

									results.push(elem);
									return results;
								}
							}

							// Type selector
						} else if (match[2]) {
							push.apply(results, context.getElementsByTagName(selector));
							return results;

							// Class selector
						} else if ((m = match[3]) &amp;&amp; support.getElementsByClassName &amp;&amp; context.getElementsByClassName) {

							push.apply(results, context.getElementsByClassName(m));
							return results;
						}
					}

					// Take advantage of querySelectorAll
					if (support.qsa &amp;&amp; !compilerCache[selector + " "] &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test(selector))) {

						if (nodeType !== 1) {
							newContext = context;
							newSelector = selector;

							// qSA looks outside Element context, which is not what we want
							// Thanks to Andrew Dupont for this workaround technique
							// Support: IE &lt;=8
							// Exclude object elements
						} else if (context.nodeName.toLowerCase() !== "object") {

							// Capture the context ID, setting it first if necessary
							if (nid = context.getAttribute("id")) {
								nid = nid.replace(rescape, "\\$&amp;");
							} else {
								context.setAttribute("id", nid = expando);
							}

							// Prefix every selector in the list
							groups = tokenize(selector);
							i = groups.length;
							nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
							while (i--) {
								groups[i] = nidselect + " " + toSelector(groups[i]);
							}
							newSelector = groups.join(",");

							// Expand context for sibling selectors
							newContext = rsibling.test(selector) &amp;&amp; testContext(context.parentNode) || context;
						}

						if (newSelector) {
							try {
								push.apply(results, newContext.querySelectorAll(newSelector));
								return results;
							} catch (qsaError) {} finally {
								if (nid === expando) {
									context.removeAttribute("id");
								}
							}
						}
					}
				}
			}

			// All others
			return select(selector.replace(rtrim, "$1"), context, results, seed);
		}

		/**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
		function createCache() {
			var keys = [];

			function cache(key, value) {
				// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
				if (keys.push(key + " ") > Expr.cacheLength) {
					// Only keep the most recent entries
					delete cache[keys.shift()];
				}
				return cache[key + " "] = value;
			}
			return cache;
		}

		/**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
		function markFunction(fn) {
			fn[expando] = true;
			return fn;
		}

		/**
   * Support testing using an element
   * @param {Function} fn Passed the created div and expects a boolean result
   */
		function assert(fn) {
			var div = document.createElement("div");

			try {
				return !!fn(div);
			} catch (e) {
				return false;
			} finally {
				// Remove from its parent by default
				if (div.parentNode) {
					div.parentNode.removeChild(div);
				}
				// release memory in IE
				div = null;
			}
		}

		/**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
		function addHandle(attrs, handler) {
			var arr = attrs.split("|"),
			    i = arr.length;

			while (i--) {
				Expr.attrHandle[arr[i]] = handler;
			}
		}

		/**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
		function siblingCheck(a, b) {
			var cur = b &amp;&amp; a,
			    diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp; (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);

			// Use IE sourceIndex if available on both nodes
			if (diff) {
				return diff;
			}

			// Check if b follows a
			if (cur) {
				while (cur = cur.nextSibling) {
					if (cur === b) {
						return -1;
					}
				}
			}

			return a ? 1 : -1;
		}

		/**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
		function createInputPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" &amp;&amp; elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
		function createButtonPseudo(type) {
			return function (elem) {
				var name = elem.nodeName.toLowerCase();
				return (name === "input" || name === "button") &amp;&amp; elem.type === type;
			};
		}

		/**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
		function createPositionalPseudo(fn) {
			return markFunction(function (argument) {
				argument = +argument;
				return markFunction(function (seed, matches) {
					var j,
					    matchIndexes = fn([], seed.length, argument),
					    i = matchIndexes.length;

					// Match elements found at the specified indexes
					while (i--) {
						if (seed[j = matchIndexes[i]]) {
							seed[j] = !(matches[j] = seed[j]);
						}
					}
				});
			});
		}

		/**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
		function testContext(context) {
			return context &amp;&amp; typeof context.getElementsByTagName !== "undefined" &amp;&amp; context;
		}

		// Expose support vars for convenience
		support = Sizzle.support = {};

		/**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
		isXML = Sizzle.isXML = function (elem) {
			// documentElement is verified for cases where it doesn't yet exist
			// (such as loading iframes in IE - #4833)
			var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
			return documentElement ? documentElement.nodeName !== "HTML" : false;
		};

		/**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
		setDocument = Sizzle.setDocument = function (node) {
			var hasCompare,
			    parent,
			    doc = node ? node.ownerDocument || node : preferredDoc;

			// Return early if doc is invalid or already selected
			if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
				return document;
			}

			// Update global variables
			document = doc;
			docElem = document.documentElement;
			documentIsHTML = !isXML(document);

			// Support: IE 9-11, Edge
			// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
			if ((parent = document.defaultView) &amp;&amp; parent.top !== parent) {
				// Support: IE 11
				if (parent.addEventListener) {
					parent.addEventListener("unload", unloadHandler, false);

					// Support: IE 9 - 10 only
				} else if (parent.attachEvent) {
					parent.attachEvent("onunload", unloadHandler);
				}
			}

			/* Attributes
   ---------------------------------------------------------------------- */

			// Support: IE&lt;8
			// Verify that getAttribute really returns attributes and not properties
			// (excepting IE8 booleans)
			support.attributes = assert(function (div) {
				div.className = "i";
				return !div.getAttribute("className");
			});

			/* getElement(s)By*
   ---------------------------------------------------------------------- */

			// Check if getElementsByTagName("*") returns only elements
			support.getElementsByTagName = assert(function (div) {
				div.appendChild(document.createComment(""));
				return !div.getElementsByTagName("*").length;
			});

			// Support: IE&lt;9
			support.getElementsByClassName = rnative.test(document.getElementsByClassName);

			// Support: IE&lt;10
			// Check if getElementById returns elements by name
			// The broken getElementById methods don't pick up programatically-set names,
			// so use a roundabout getElementsByName test
			support.getById = assert(function (div) {
				docElem.appendChild(div).id = expando;
				return !document.getElementsByName || !document.getElementsByName(expando).length;
			});

			// ID find and filter
			if (support.getById) {
				Expr.find["ID"] = function (id, context) {
					if (typeof context.getElementById !== "undefined" &amp;&amp; documentIsHTML) {
						var m = context.getElementById(id);
						return m ? [m] : [];
					}
				};
				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						return elem.getAttribute("id") === attrId;
					};
				};
			} else {
				// Support: IE6/7
				// getElementById is not reliable as a find shortcut
				delete Expr.find["ID"];

				Expr.filter["ID"] = function (id) {
					var attrId = id.replace(runescape, funescape);
					return function (elem) {
						var node = typeof elem.getAttributeNode !== "undefined" &amp;&amp; elem.getAttributeNode("id");
						return node &amp;&amp; node.value === attrId;
					};
				};
			}

			// Tag
			Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
				if (typeof context.getElementsByTagName !== "undefined") {
					return context.getElementsByTagName(tag);

					// DocumentFragment nodes don't have gEBTN
				} else if (support.qsa) {
					return context.querySelectorAll(tag);
				}
			} : function (tag, context) {
				var elem,
				    tmp = [],
				    i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName(tag);

				// Filter out possible comments
				if (tag === "*") {
					while (elem = results[i++]) {
						if (elem.nodeType === 1) {
							tmp.push(elem);
						}
					}

					return tmp;
				}
				return results;
			};

			// Class
			Expr.find["CLASS"] = support.getElementsByClassName &amp;&amp; function (className, context) {
				if (typeof context.getElementsByClassName !== "undefined" &amp;&amp; documentIsHTML) {
					return context.getElementsByClassName(className);
				}
			};

			/* QSA/matchesSelector
   ---------------------------------------------------------------------- */

			// QSA and matchesSelector support

			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			rbuggyMatches = [];

			// qSa(:focus) reports false when true (Chrome 21)
			// We allow this because of a bug in IE8/9 that throws an error
			// whenever `document.activeElement` is accessed on an iframe
			// So, we allow :focus to pass through QSA all the time to avoid the IE error
			// See http://bugs.jquery.com/ticket/13378
			rbuggyQSA = [];

			if (support.qsa = rnative.test(document.querySelectorAll)) {
				// Build QSA regex
				// Regex strategy adopted from Diego Perini
				assert(function (div) {
					// Select is set to empty string on purpose
					// This is to test IE's treatment of not explicitly
					// setting a boolean content attribute,
					// since its presence should be enough
					// http://bugs.jquery.com/ticket/12359
					docElem.appendChild(div).innerHTML = "&lt;a id='" + expando + "'>&lt;/a>" + "&lt;select id='" + expando + "-\r\\' msallowcapture=''>" + "&lt;option selected=''>&lt;/option>&lt;/select>";

					// Support: IE8, Opera 11-12.16
					// Nothing should be selected when empty strings follow ^= or $= or *=
					// The test attribute must be unknown in Opera but "safe" for WinRT
					// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
					if (div.querySelectorAll("[msallowcapture^='']").length) {
						rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
					}

					// Support: IE8
					// Boolean attributes and "value" are not treated correctly
					if (!div.querySelectorAll("[selected]").length) {
						rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
					}

					// Support: Chrome&lt;29, Android&lt;4.4, Safari&lt;7.0+, iOS&lt;7.0+, PhantomJS&lt;1.9.8+
					if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
						rbuggyQSA.push("~=");
					}

					// Webkit/Opera - :checked should return selected option elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					// IE8 throws error here and will not see later tests
					if (!div.querySelectorAll(":checked").length) {
						rbuggyQSA.push(":checked");
					}

					// Support: Safari 8+, iOS 8+
					// https://bugs.webkit.org/show_bug.cgi?id=136851
					// In-page `selector#id sibing-combinator selector` fails
					if (!div.querySelectorAll("a#" + expando + "+*").length) {
						rbuggyQSA.push(".#.+[+~]");
					}
				});

				assert(function (div) {
					// Support: Windows 8 Native Apps
					// The type and name attributes are restricted during .innerHTML assignment
					var input = document.createElement("input");
					input.setAttribute("type", "hidden");
					div.appendChild(input).setAttribute("name", "D");

					// Support: IE8
					// Enforce case-sensitivity of name attribute
					if (div.querySelectorAll("[name=d]").length) {
						rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
					}

					// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
					// IE8 throws error here and will not see later tests
					if (!div.querySelectorAll(":enabled").length) {
						rbuggyQSA.push(":enabled", ":disabled");
					}

					// Opera 10-11 does not throw on post-comma invalid pseudos
					div.querySelectorAll("*,:x");
					rbuggyQSA.push(",.*:");
				});
			}

			if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {

				assert(function (div) {
					// Check to see if it's possible to do matchesSelector
					// on a disconnected node (IE 9)
					support.disconnectedMatch = matches.call(div, "div");

					// This should fail with an exception
					// Gecko does not error, returns false instead
					matches.call(div, "[s!='']:x");
					rbuggyMatches.push("!=", pseudos);
				});
			}

			rbuggyQSA = rbuggyQSA.length &amp;&amp; new RegExp(rbuggyQSA.join("|"));
			rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp(rbuggyMatches.join("|"));

			/* Contains
   ---------------------------------------------------------------------- */
			hasCompare = rnative.test(docElem.compareDocumentPosition);

			// Element contains another
			// Purposefully self-exclusive
			// As in, an element does not contain itself
			contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
				    bup = b &amp;&amp; b.parentNode;
				return a === bup || !!(bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (adown.contains ? adown.contains(bup) : a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition(bup) &amp; 16));
			} : function (a, b) {
				if (b) {
					while (b = b.parentNode) {
						if (b === a) {
							return true;
						}
					}
				}
				return false;
			};

			/* Sorting
   ---------------------------------------------------------------------- */

			// Document order sorting
			sortOrder = hasCompare ? function (a, b) {

				// Flag for duplicate removal
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				// Sort on method existence if only one input has compareDocumentPosition
				var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
				if (compare) {
					return compare;
				}

				// Calculate position if both inputs belong to the same document
				compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :

				// Otherwise we know they are disconnected
				1;

				// Disconnected nodes
				if (compare &amp; 1 || !support.sortDetached &amp;&amp; b.compareDocumentPosition(a) === compare) {

					// Choose the first element that is related to our preferred document
					if (a === document || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, a)) {
						return -1;
					}
					if (b === document || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, b)) {
						return 1;
					}

					// Maintain original order
					return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
				}

				return compare &amp; 4 ? -1 : 1;
			} : function (a, b) {
				// Exit early if the nodes are identical
				if (a === b) {
					hasDuplicate = true;
					return 0;
				}

				var cur,
				    i = 0,
				    aup = a.parentNode,
				    bup = b.parentNode,
				    ap = [a],
				    bp = [b];

				// Parentless nodes are either documents or disconnected
				if (!aup || !bup) {
					return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;

					// If the nodes are siblings, we can do a quick check
				} else if (aup === bup) {
					return siblingCheck(a, b);
				}

				// Otherwise we need full lists of their ancestors for comparison
				cur = a;
				while (cur = cur.parentNode) {
					ap.unshift(cur);
				}
				cur = b;
				while (cur = cur.parentNode) {
					bp.unshift(cur);
				}

				// Walk down the tree looking for a discrepancy
				while (ap[i] === bp[i]) {
					i++;
				}

				return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck(ap[i], bp[i]) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
			};

			return document;
		};

		Sizzle.matches = function (expr, elements) {
			return Sizzle(expr, null, null, elements);
		};

		Sizzle.matchesSelector = function (elem, expr) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			// Make sure that attribute selectors are quoted
			expr = expr.replace(rattributeQuotes, "='$1']");

			if (support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp; !compilerCache[expr + " "] &amp;&amp; (!rbuggyMatches || !rbuggyMatches.test(expr)) &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test(expr))) {

				try {
					var ret = matches.call(elem, expr);

					// IE 9's matchesSelector returns false on disconnected nodes
					if (ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document &amp;&amp; elem.document.nodeType !== 11) {
						return ret;
					}
				} catch (e) {}
			}

			return Sizzle(expr, document, null, [elem]).length > 0;
		};

		Sizzle.contains = function (context, elem) {
			// Set document vars if needed
			if ((context.ownerDocument || context) !== document) {
				setDocument(context);
			}
			return contains(context, elem);
		};

		Sizzle.attr = function (elem, name) {
			// Set document vars if needed
			if ((elem.ownerDocument || elem) !== document) {
				setDocument(elem);
			}

			var fn = Expr.attrHandle[name.toLowerCase()],

			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn &amp;&amp; hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

			return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ? val.value : null;
		};

		Sizzle.error = function (msg) {
			throw new Error("Syntax error, unrecognized expression: " + msg);
		};

		/**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
		Sizzle.uniqueSort = function (results) {
			var elem,
			    duplicates = [],
			    j = 0,
			    i = 0;

			// Unless we *know* we can detect duplicates, assume their presence
			hasDuplicate = !support.detectDuplicates;
			sortInput = !support.sortStable &amp;&amp; results.slice(0);
			results.sort(sortOrder);

			if (hasDuplicate) {
				while (elem = results[i++]) {
					if (elem === results[i]) {
						j = duplicates.push(i);
					}
				}
				while (j--) {
					results.splice(duplicates[j], 1);
				}
			}

			// Clear input after sorting to release objects
			// See https://github.com/jquery/sizzle/pull/225
			sortInput = null;

			return results;
		};

		/**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
		getText = Sizzle.getText = function (elem) {
			var node,
			    ret = "",
			    i = 0,
			    nodeType = elem.nodeType;

			if (!nodeType) {
				// If no nodeType, this is expected to be an array
				while (node = elem[i++]) {
					// Do not traverse comment nodes
					ret += getText(node);
				}
			} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
				// Use textContent for elements
				// innerText usage removed for consistency of new lines (jQuery #11153)
				if (typeof elem.textContent === "string") {
					return elem.textContent;
				} else {
					// Traverse its children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						ret += getText(elem);
					}
				}
			} else if (nodeType === 3 || nodeType === 4) {
				return elem.nodeValue;
			}
			// Do not include comment or processing instruction nodes

			return ret;
		};

		Expr = Sizzle.selectors = {

			// Can be adjusted by the user
			cacheLength: 50,

			createPseudo: markFunction,

			match: matchExpr,

			attrHandle: {},

			find: {},

			relative: {
				">": { dir: "parentNode", first: true },
				" ": { dir: "parentNode" },
				"+": { dir: "previousSibling", first: true },
				"~": { dir: "previousSibling" }
			},

			preFilter: {
				"ATTR": function ATTR(match) {
					match[1] = match[1].replace(runescape, funescape);

					// Move the given value to match[3] whether quoted or unquoted
					match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

					if (match[2] === "~=") {
						match[3] = " " + match[3] + " ";
					}

					return match.slice(0, 4);
				},

				"CHILD": function CHILD(match) {
					/* matches from matchExpr["CHILD"]
     	1 type (only|nth|...)
     	2 what (child|of-type)
     	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
     	4 xn-component of xn+y argument ([+-]?\d*n|)
     	5 sign of xn-component
     	6 x of xn-component
     	7 sign of y-component
     	8 y of y-component
     */
					match[1] = match[1].toLowerCase();

					if (match[1].slice(0, 3) === "nth") {
						// nth-* requires argument
						if (!match[3]) {
							Sizzle.error(match[0]);
						}

						// numeric x and y parameters for Expr.filter.CHILD
						// remember that false/true cast respectively to 0/1
						match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
						match[5] = +(match[7] + match[8] || match[3] === "odd");

						// other types prohibit arguments
					} else if (match[3]) {
						Sizzle.error(match[0]);
					}

					return match;
				},

				"PSEUDO": function PSEUDO(match) {
					var excess,
					    unquoted = !match[6] &amp;&amp; match[2];

					if (matchExpr["CHILD"].test(match[0])) {
						return null;
					}

					// Accept quoted arguments as-is
					if (match[3]) {
						match[2] = match[4] || match[5] || "";

						// Strip excess characters from unquoted arguments
					} else if (unquoted &amp;&amp; rpseudo.test(unquoted) &amp;&amp; (
					// Get excess from tokenize (recursively)
					excess = tokenize(unquoted, true)) &amp;&amp; (
					// advance to the next closing parenthesis
					excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

						// excess is a negative index
						match[0] = match[0].slice(0, excess);
						match[2] = unquoted.slice(0, excess);
					}

					// Return only captures needed by the pseudo filter method (type and argument)
					return match.slice(0, 3);
				}
			},

			filter: {

				"TAG": function TAG(nodeNameSelector) {
					var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
					return nodeNameSelector === "*" ? function () {
						return true;
					} : function (elem) {
						return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
					};
				},

				"CLASS": function CLASS(className) {
					var pattern = classCache[className + " "];

					return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &amp;&amp; classCache(className, function (elem) {
						return pattern.test(typeof elem.className === "string" &amp;&amp; elem.className || typeof elem.getAttribute !== "undefined" &amp;&amp; elem.getAttribute("class") || "");
					});
				},

				"ATTR": function ATTR(name, operator, check) {
					return function (elem) {
						var result = Sizzle.attr(elem, name);

						if (result == null) {
							return operator === "!=";
						}
						if (!operator) {
							return true;
						}

						result += "";

						return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check &amp;&amp; result.indexOf(check) === 0 : operator === "*=" ? check &amp;&amp; result.indexOf(check) > -1 : operator === "$=" ? check &amp;&amp; result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
					};
				},

				"CHILD": function CHILD(type, what, argument, first, last) {
					var simple = type.slice(0, 3) !== "nth",
					    forward = type.slice(-4) !== "last",
					    ofType = what === "of-type";

					return first === 1 &amp;&amp; last === 0 ?

					// Shortcut for :nth-*(n)
					function (elem) {
						return !!elem.parentNode;
					} : function (elem, context, xml) {
						var cache,
						    uniqueCache,
						    outerCache,
						    node,
						    nodeIndex,
						    start,
						    dir = simple !== forward ? "nextSibling" : "previousSibling",
						    parent = elem.parentNode,
						    name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
						    useCache = !xml &amp;&amp; !ofType,
						    diff = false;

						if (parent) {

							// :(first|last|only)-(child|of-type)
							if (simple) {
								while (dir) {
									node = elem;
									while (node = node[dir]) {
										if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" &amp;&amp; !start &amp;&amp; "nextSibling";
								}
								return true;
							}

							start = [forward ? parent.firstChild : parent.lastChild];

							// non-xml :nth-child(...) stores cache data on `parent`
							if (forward &amp;&amp; useCache) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[expando] || (node[expando] = {});

								// Support: IE &lt;9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

								cache = uniqueCache[type] || [];
								nodeIndex = cache[0] === dirruns &amp;&amp; cache[1];
								diff = nodeIndex &amp;&amp; cache[2];
								node = nodeIndex &amp;&amp; parent.childNodes[nodeIndex];

								while (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[dir] || (

								// Fallback to seeking `elem` from the start
								diff = nodeIndex = 0) || start.pop()) {

									// When found, cache indexes on `parent` and break
									if (node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem) {
										uniqueCache[type] = [dirruns, nodeIndex, diff];
										break;
									}
								}
							} else {
								// Use previously-cached element index if available
								if (useCache) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[expando] || (node[expando] = {});

									// Support: IE &lt;9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

									cache = uniqueCache[type] || [];
									nodeIndex = cache[0] === dirruns &amp;&amp; cache[1];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if (diff === false) {
									// Use the same loop as above to seek `elem` from the start
									while (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[dir] || (diff = nodeIndex = 0) || start.pop()) {

										if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) &amp;&amp; ++diff) {

											// Cache the index of each encountered element
											if (useCache) {
												outerCache = node[expando] || (node[expando] = {});

												// Support: IE &lt;9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

												uniqueCache[type] = [dirruns, diff];
											}

											if (node === elem) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || diff % first === 0 &amp;&amp; diff / first >= 0;
						}
					};
				},

				"PSEUDO": function PSEUDO(pseudo, argument) {
					// pseudo-class names are case-insensitive
					// http://www.w3.org/TR/selectors/#pseudo-classes
					// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
					// Remember that setFilters inherits from pseudos
					var args,
					    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

					// The user may use createPseudo to indicate that
					// arguments are needed to create the filter function
					// just as Sizzle does
					if (fn[expando]) {
						return fn(argument);
					}

					// But maintain support for old signatures
					if (fn.length > 1) {
						args = [pseudo, pseudo, "", argument];
						return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
							var idx,
							    matched = fn(seed, argument),
							    i = matched.length;
							while (i--) {
								idx = indexOf(seed, matched[i]);
								seed[idx] = !(matches[idx] = matched[i]);
							}
						}) : function (elem) {
							return fn(elem, 0, args);
						};
					}

					return fn;
				}
			},

			pseudos: {
				// Potentially complex pseudos
				"not": markFunction(function (selector) {
					// Trim the selector passed to compile
					// to avoid treating leading and trailing
					// spaces as combinators
					var input = [],
					    results = [],
					    matcher = compile(selector.replace(rtrim, "$1"));

					return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
						var elem,
						    unmatched = matcher(seed, null, xml, []),
						    i = seed.length;

						// Match elements unmatched by `matcher`
						while (i--) {
							if (elem = unmatched[i]) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) : function (elem, context, xml) {
						input[0] = elem;
						matcher(input, null, xml, results);
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
				}),

				"has": markFunction(function (selector) {
					return function (elem) {
						return Sizzle(selector, elem).length > 0;
					};
				}),

				"contains": markFunction(function (text) {
					text = text.replace(runescape, funescape);
					return function (elem) {
						return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
					};
				}),

				// "Whether an element is represented by a :lang() selector
				// is based solely on the element's language value
				// being equal to the identifier C,
				// or beginning with the identifier C immediately followed by "-".
				// The matching of C against the element's language value is performed case-insensitively.
				// The identifier C does not have to be a valid language name."
				// http://www.w3.org/TR/selectors/#lang-pseudo
				"lang": markFunction(function (lang) {
					// lang value must be a valid identifier
					if (!ridentifier.test(lang || "")) {
						Sizzle.error("unsupported lang: " + lang);
					}
					lang = lang.replace(runescape, funescape).toLowerCase();
					return function (elem) {
						var elemLang;
						do {
							if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {

								elemLang = elemLang.toLowerCase();
								return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
							}
						} while ((elem = elem.parentNode) &amp;&amp; elem.nodeType === 1);
						return false;
					};
				}),

				// Miscellaneous
				"target": function target(elem) {
					var hash = window.location &amp;&amp; window.location.hash;
					return hash &amp;&amp; hash.slice(1) === elem.id;
				},

				"root": function root(elem) {
					return elem === docElem;
				},

				"focus": function focus(elem) {
					return elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
				},

				// Boolean properties
				"enabled": function enabled(elem) {
					return elem.disabled === false;
				},

				"disabled": function disabled(elem) {
					return elem.disabled === true;
				},

				"checked": function checked(elem) {
					// In CSS3, :checked should return both checked and selected elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					var nodeName = elem.nodeName.toLowerCase();
					return nodeName === "input" &amp;&amp; !!elem.checked || nodeName === "option" &amp;&amp; !!elem.selected;
				},

				"selected": function selected(elem) {
					// Accessing this property makes selected-by-default
					// options in Safari work properly
					if (elem.parentNode) {
						elem.parentNode.selectedIndex;
					}

					return elem.selected === true;
				},

				// Contents
				"empty": function empty(elem) {
					// http://www.w3.org/TR/selectors/#empty-pseudo
					// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
					//   but not by others (comment: 8; processing instruction: 7; etc.)
					// nodeType &lt; 6 works because attributes (2) do not appear as children
					for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
						if (elem.nodeType &lt; 6) {
							return false;
						}
					}
					return true;
				},

				"parent": function parent(elem) {
					return !Expr.pseudos["empty"](elem);
				},

				// Element/input types
				"header": function header(elem) {
					return rheader.test(elem.nodeName);
				},

				"input": function input(elem) {
					return rinputs.test(elem.nodeName);
				},

				"button": function button(elem) {
					var name = elem.nodeName.toLowerCase();
					return name === "input" &amp;&amp; elem.type === "button" || name === "button";
				},

				"text": function text(elem) {
					var attr;
					return elem.nodeName.toLowerCase() === "input" &amp;&amp; elem.type === "text" &amp;&amp; (

					// Support: IE&lt;8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					(attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
				},

				// Position-in-collection
				"first": createPositionalPseudo(function () {
					return [0];
				}),

				"last": createPositionalPseudo(function (matchIndexes, length) {
					return [length - 1];
				}),

				"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
					return [argument &lt; 0 ? argument + length : argument];
				}),

				"even": createPositionalPseudo(function (matchIndexes, length) {
					var i = 0;
					for (; i &lt; length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"odd": createPositionalPseudo(function (matchIndexes, length) {
					var i = 1;
					for (; i &lt; length; i += 2) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument &lt; 0 ? argument + length : argument;
					for (; --i >= 0;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				}),

				"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
					var i = argument &lt; 0 ? argument + length : argument;
					for (; ++i &lt; length;) {
						matchIndexes.push(i);
					}
					return matchIndexes;
				})
			}
		};

		Expr.pseudos["nth"] = Expr.pseudos["eq"];

		// Add button/input type pseudos
		for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
			Expr.pseudos[i] = createInputPseudo(i);
		}
		for (i in { submit: true, reset: true }) {
			Expr.pseudos[i] = createButtonPseudo(i);
		}

		// Easy API for creating new setFilters
		function setFilters() {}
		setFilters.prototype = Expr.filters = Expr.pseudos;
		Expr.setFilters = new setFilters();

		tokenize = Sizzle.tokenize = function (selector, parseOnly) {
			var matched,
			    match,
			    tokens,
			    type,
			    soFar,
			    groups,
			    preFilters,
			    cached = tokenCache[selector + " "];

			if (cached) {
				return parseOnly ? 0 : cached.slice(0);
			}

			soFar = selector;
			groups = [];
			preFilters = Expr.preFilter;

			while (soFar) {

				// Comma and first run
				if (!matched || (match = rcomma.exec(soFar))) {
					if (match) {
						// Don't consume trailing commas as valid
						soFar = soFar.slice(match[0].length) || soFar;
					}
					groups.push(tokens = []);
				}

				matched = false;

				// Combinators
				if (match = rcombinators.exec(soFar)) {
					matched = match.shift();
					tokens.push({
						value: matched,
						// Cast descendant combinators to space
						type: match[0].replace(rtrim, " ")
					});
					soFar = soFar.slice(matched.length);
				}

				// Filters
				for (type in Expr.filter) {
					if ((match = matchExpr[type].exec(soFar)) &amp;&amp; (!preFilters[type] || (match = preFilters[type](match)))) {
						matched = match.shift();
						tokens.push({
							value: matched,
							type: type,
							matches: match
						});
						soFar = soFar.slice(matched.length);
					}
				}

				if (!matched) {
					break;
				}
			}

			// Return the length of the invalid excess
			// if we're just parsing
			// Otherwise, throw an error or return tokens
			return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
			// Cache the tokens
			tokenCache(selector, groups).slice(0);
		};

		function toSelector(tokens) {
			var i = 0,
			    len = tokens.length,
			    selector = "";
			for (; i &lt; len; i++) {
				selector += tokens[i].value;
			}
			return selector;
		}

		function addCombinator(matcher, combinator, base) {
			var dir = combinator.dir,
			    checkNonElements = base &amp;&amp; dir === "parentNode",
			    doneName = done++;

			return combinator.first ?
			// Check against closest ancestor/preceding element
			function (elem, context, xml) {
				while (elem = elem[dir]) {
					if (elem.nodeType === 1 || checkNonElements) {
						return matcher(elem, context, xml);
					}
				}
			} :

			// Check against all ancestor/preceding elements
			function (elem, context, xml) {
				var oldCache,
				    uniqueCache,
				    outerCache,
				    newCache = [dirruns, doneName];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if (xml) {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							if (matcher(elem, context, xml)) {
								return true;
							}
						}
					}
				} else {
					while (elem = elem[dir]) {
						if (elem.nodeType === 1 || checkNonElements) {
							outerCache = elem[expando] || (elem[expando] = {});

							// Support: IE &lt;9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

							if ((oldCache = uniqueCache[dir]) &amp;&amp; oldCache[0] === dirruns &amp;&amp; oldCache[1] === doneName) {

								// Assign to newCache so results back-propagate to previous elements
								return newCache[2] = oldCache[2];
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[dir] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if (newCache[2] = matcher(elem, context, xml)) {
									return true;
								}
							}
						}
					}
				}
			};
		}

		function elementMatcher(matchers) {
			return matchers.length > 1 ? function (elem, context, xml) {
				var i = matchers.length;
				while (i--) {
					if (!matchers[i](elem, context, xml)) {
						return false;
					}
				}
				return true;
			} : matchers[0];
		}

		function multipleContexts(selector, contexts, results) {
			var i = 0,
			    len = contexts.length;
			for (; i &lt; len; i++) {
				Sizzle(selector, contexts[i], results);
			}
			return results;
		}

		function condense(unmatched, map, filter, context, xml) {
			var elem,
			    newUnmatched = [],
			    i = 0,
			    len = unmatched.length,
			    mapped = map != null;

			for (; i &lt; len; i++) {
				if (elem = unmatched[i]) {
					if (!filter || filter(elem, context, xml)) {
						newUnmatched.push(elem);
						if (mapped) {
							map.push(i);
						}
					}
				}
			}

			return newUnmatched;
		}

		function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
			if (postFilter &amp;&amp; !postFilter[expando]) {
				postFilter = setMatcher(postFilter);
			}
			if (postFinder &amp;&amp; !postFinder[expando]) {
				postFinder = setMatcher(postFinder, postSelector);
			}
			return markFunction(function (seed, results, context, xml) {
				var temp,
				    i,
				    elem,
				    preMap = [],
				    postMap = [],
				    preexisting = results.length,


				// Get initial elements from seed or context
				elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),


				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter &amp;&amp; (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
				    matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || (seed ? preFilter : preexisting || postFilter) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results : matcherIn;

				// Find primary matches
				if (matcher) {
					matcher(matcherIn, matcherOut, context, xml);
				}

				// Apply postFilter
				if (postFilter) {
					temp = condense(matcherOut, postMap);
					postFilter(temp, [], context, xml);

					// Un-match failing elements by moving them back to matcherIn
					i = temp.length;
					while (i--) {
						if (elem = temp[i]) {
							matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
						}
					}
				}

				if (seed) {
					if (postFinder || preFilter) {
						if (postFinder) {
							// Get the final matcherOut by condensing this intermediate into postFinder contexts
							temp = [];
							i = matcherOut.length;
							while (i--) {
								if (elem = matcherOut[i]) {
									// Restore matcherIn since elem is not yet a final match
									temp.push(matcherIn[i] = elem);
								}
							}
							postFinder(null, matcherOut = [], temp, xml);
						}

						// Move matched elements from seed to results to keep them synchronized
						i = matcherOut.length;
						while (i--) {
							if ((elem = matcherOut[i]) &amp;&amp; (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

								seed[temp] = !(results[temp] = elem);
							}
						}
					}

					// Add elements to results, through postFinder if defined
				} else {
					matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
					if (postFinder) {
						postFinder(null, results, matcherOut, xml);
					} else {
						push.apply(results, matcherOut);
					}
				}
			});
		}

		function matcherFromTokens(tokens) {
			var checkContext,
			    matcher,
			    j,
			    len = tokens.length,
			    leadingRelative = Expr.relative[tokens[0].type],
			    implicitRelative = leadingRelative || Expr.relative[" "],
			    i = leadingRelative ? 1 : 0,


			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator(function (elem) {
				return elem === checkContext;
			}, implicitRelative, true),
			    matchAnyContext = addCombinator(function (elem) {
				return indexOf(checkContext, elem) > -1;
			}, implicitRelative, true),
			    matchers = [function (elem, context, xml) {
				var ret = !leadingRelative &amp;&amp; (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			}];

			for (; i &lt; len; i++) {
				if (matcher = Expr.relative[tokens[i].type]) {
					matchers = [addCombinator(elementMatcher(matchers), matcher)];
				} else {
					matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

					// Return special upon seeing a positional matcher
					if (matcher[expando]) {
						// Find the next relative operator (if any) for proper handling
						j = ++i;
						for (; j &lt; len; j++) {
							if (Expr.relative[tokens[j].type]) {
								break;
							}
						}
						return setMatcher(i > 1 &amp;&amp; elementMatcher(matchers), i > 1 &amp;&amp; toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i &lt; j &amp;&amp; matcherFromTokens(tokens.slice(i, j)), j &lt; len &amp;&amp; matcherFromTokens(tokens = tokens.slice(j)), j &lt; len &amp;&amp; toSelector(tokens));
					}
					matchers.push(matcher);
				}
			}

			return elementMatcher(matchers);
		}

		function matcherFromGroupMatchers(elementMatchers, setMatchers) {
			var bySet = setMatchers.length > 0,
			    byElement = elementMatchers.length > 0,
			    superMatcher = function superMatcher(seed, context, xml, results, outermost) {
				var elem,
				    j,
				    matcher,
				    matchedCount = 0,
				    i = "0",
				    unmatched = seed &amp;&amp; [],
				    setMatched = [],
				    contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement &amp;&amp; Expr.find["TAG"]("*", outermost),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
				    len = elems.length;

				if (outermost) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE&lt;9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: &lt;number>) matching elements by id
				for (; i !== len &amp;&amp; (elem = elems[i]) != null; i++) {
					if (byElement &amp;&amp; elem) {
						j = 0;
						if (!context &amp;&amp; elem.ownerDocument !== document) {
							setDocument(elem);
							xml = !documentIsHTML;
						}
						while (matcher = elementMatchers[j++]) {
							if (matcher(elem, context || document, xml)) {
								results.push(elem);
								break;
							}
						}
						if (outermost) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if (bySet) {
						// They will have gone through all possible matchers
						if (elem = !matcher &amp;&amp; elem) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if (seed) {
							unmatched.push(elem);
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if (bySet &amp;&amp; i !== matchedCount) {
					j = 0;
					while (matcher = setMatchers[j++]) {
						matcher(unmatched, setMatched, context, xml);
					}

					if (seed) {
						// Reintegrate element matches to eliminate the need for sorting
						if (matchedCount > 0) {
							while (i--) {
								if (!(unmatched[i] || setMatched[i])) {
									setMatched[i] = pop.call(results);
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense(setMatched);
					}

					// Add matches to results
					push.apply(results, setMatched);

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if (outermost &amp;&amp; !seed &amp;&amp; setMatched.length > 0 &amp;&amp; matchedCount + setMatchers.length > 1) {

						Sizzle.uniqueSort(results);
					}
				}

				// Override manipulation of globals by nested matchers
				if (outermost) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

			return bySet ? markFunction(superMatcher) : superMatcher;
		}

		compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
			var i,
			    setMatchers = [],
			    elementMatchers = [],
			    cached = compilerCache[selector + " "];

			if (!cached) {
				// Generate a function of recursive functions that can be used to check each element
				if (!match) {
					match = tokenize(selector);
				}
				i = match.length;
				while (i--) {
					cached = matcherFromTokens(match[i]);
					if (cached[expando]) {
						setMatchers.push(cached);
					} else {
						elementMatchers.push(cached);
					}
				}

				// Cache the compiled function
				cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

				// Save selector and tokenization
				cached.selector = selector;
			}
			return cached;
		};

		/**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
		select = Sizzle.select = function (selector, context, results, seed) {
			var i,
			    tokens,
			    token,
			    type,
			    find,
			    compiled = typeof selector === "function" &amp;&amp; selector,
			    match = !seed &amp;&amp; tokenize(selector = compiled.selector || selector);

			results = results || [];

			// Try to minimize operations if there is only one selector in the list and no seed
			// (the latter of which guarantees us context)
			if (match.length === 1) {

				// Reduce context if the leading compound selector is an ID
				tokens = match[0] = match[0].slice(0);
				if (tokens.length > 2 &amp;&amp; (token = tokens[0]).type === "ID" &amp;&amp; support.getById &amp;&amp; context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp; Expr.relative[tokens[1].type]) {

					context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
					if (!context) {
						return results;

						// Precompiled matchers will still verify ancestry, so step up a level
					} else if (compiled) {
						context = context.parentNode;
					}

					selector = selector.slice(tokens.shift().value.length);
				}

				// Fetch a seed set for right-to-left matching
				i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
				while (i--) {
					token = tokens[i];

					// Abort if we hit a combinator
					if (Expr.relative[type = token.type]) {
						break;
					}
					if (find = Expr.find[type]) {
						// Search, expanding context for leading sibling combinators
						if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) &amp;&amp; testContext(context.parentNode) || context)) {

							// If seed is empty or no tokens remain, we can return early
							tokens.splice(i, 1);
							selector = seed.length &amp;&amp; toSelector(tokens);
							if (!selector) {
								push.apply(results, seed);
								return results;
							}

							break;
						}
					}
				}
			}

			// Compile and execute a filtering function if one is not provided
			// Provide `match` to avoid retokenization if we modified the selector above
			(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) &amp;&amp; testContext(context.parentNode) || context);
			return results;
		};

		// One-time assignments

		// Sort stability
		support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

		// Support: Chrome 14-35+
		// Always assume duplicates if they aren't passed to the comparison function
		support.detectDuplicates = !!hasDuplicate;

		// Initialize against the default document
		setDocument();

		// Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
		// Detached nodes confoundingly follow *each other*
		support.sortDetached = assert(function (div1) {
			// Should return 1, but returns 4 (following)
			return div1.compareDocumentPosition(document.createElement("div")) &amp; 1;
		});

		// Support: IE&lt;8
		// Prevent attribute/property "interpolation"
		// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
		if (!assert(function (div) {
			div.innerHTML = "&lt;a href='#'>&lt;/a>";
			return div.firstChild.getAttribute("href") === "#";
		})) {
			addHandle("type|href|height|width", function (elem, name, isXML) {
				if (!isXML) {
					return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
				}
			});
		}

		// Support: IE&lt;9
		// Use defaultValue in place of getAttribute("value")
		if (!support.attributes || !assert(function (div) {
			div.innerHTML = "&lt;input/>";
			div.firstChild.setAttribute("value", "");
			return div.firstChild.getAttribute("value") === "";
		})) {
			addHandle("value", function (elem, name, isXML) {
				if (!isXML &amp;&amp; elem.nodeName.toLowerCase() === "input") {
					return elem.defaultValue;
				}
			});
		}

		// Support: IE&lt;9
		// Use getAttributeNode to fetch booleans when getAttribute lies
		if (!assert(function (div) {
			return div.getAttribute("disabled") == null;
		})) {
			addHandle(booleans, function (elem, name, isXML) {
				var val;
				if (!isXML) {
					return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ? val.value : null;
				}
			});
		}

		return Sizzle;
	}(window);

	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	jQuery.expr[":"] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;

	var dir = function dir(elem, _dir, until) {
		var matched = [],
		    truncate = until !== undefined;

		while ((elem = elem[_dir]) &amp;&amp; elem.nodeType !== 9) {
			if (elem.nodeType === 1) {
				if (truncate &amp;&amp; jQuery(elem).is(until)) {
					break;
				}
				matched.push(elem);
			}
		}
		return matched;
	};

	var _siblings = function _siblings(n, elem) {
		var matched = [];

		for (; n; n = n.nextSibling) {
			if (n.nodeType === 1 &amp;&amp; n !== elem) {
				matched.push(n);
			}
		}

		return matched;
	};

	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = /^&lt;([\w-]+)\s*\/?>(?:&lt;\/\1>|)$/;

	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow(elements, qualifier, not) {
		if (jQuery.isFunction(qualifier)) {
			return jQuery.grep(elements, function (elem, i) {
				/* jshint -W018 */
				return !!qualifier.call(elem, i, elem) !== not;
			});
		}

		if (qualifier.nodeType) {
			return jQuery.grep(elements, function (elem) {
				return elem === qualifier !== not;
			});
		}

		if (typeof qualifier === "string") {
			if (risSimple.test(qualifier)) {
				return jQuery.filter(qualifier, elements, not);
			}

			qualifier = jQuery.filter(qualifier, elements);
		}

		return jQuery.grep(elements, function (elem) {
			return indexOf.call(qualifier, elem) > -1 !== not;
		});
	}

	jQuery.filter = function (expr, elems, not) {
		var elem = elems[0];

		if (not) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 &amp;&amp; elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
			return elem.nodeType === 1;
		}));
	};

	jQuery.fn.extend({
		find: function find(selector) {
			var i,
			    len = this.length,
			    ret = [],
			    self = this;

			if (typeof selector !== "string") {
				return this.pushStack(jQuery(selector).filter(function () {
					for (i = 0; i &lt; len; i++) {
						if (jQuery.contains(self[i], this)) {
							return true;
						}
					}
				}));
			}

			for (i = 0; i &lt; len; i++) {
				jQuery.find(selector, self[i], ret);
			}

			// Needed because $( selector, context ) becomes $( context ).find( selector )
			ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
			ret.selector = this.selector ? this.selector + " " + selector : selector;
			return ret;
		},
		filter: function filter(selector) {
			return this.pushStack(winnow(this, selector || [], false));
		},
		not: function not(selector) {
			return this.pushStack(winnow(this, selector || [], true));
		},
		is: function is(selector) {
			return !!winnow(this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" &amp;&amp; rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
		}
	});

	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,


	// A simple way to check for HTML strings
	// Prioritize #id over &lt;tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with &lt;)
	rquickExpr = /^(?:\s*(&lt;[\w\W]+>)[^>]*|#([\w-]*))$/,
	    init = jQuery.fn.init = function (selector, context, root) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if (!selector) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if (typeof selector === "string") {
			if (selector[0] === "&lt;" &amp;&amp; selector[selector.length - 1] === ">" &amp;&amp; selector.length >= 3) {

				// Assume that strings that start and end with &lt;> are HTML and skip the regex check
				match = [null, selector, null];
			} else {
				match = rquickExpr.exec(selector);
			}

			// Match html or make sure no context is specified for #id
			if (match &amp;&amp; (match[1] || !context)) {

				// HANDLE: $(html) -> $(array)
				if (match[1]) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge(this, jQuery.parseHTML(match[1], context &amp;&amp; context.nodeType ? context.ownerDocument || context : document, true));

					// HANDLE: $(html, props)
					if (rsingleTag.test(match[1]) &amp;&amp; jQuery.isPlainObject(context)) {
						for (match in context) {

							// Properties of context are called as methods if possible
							if (jQuery.isFunction(this[match])) {
								this[match](context[match]);

								// ...and otherwise set as attributes
							} else {
								this.attr(match, context[match]);
							}
						}
					}

					return this;

					// HANDLE: $(#id)
				} else {
					elem = document.getElementById(match[2]);

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if (elem &amp;&amp; elem.parentNode) {

						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

				// HANDLE: $(expr, $(...))
			} else if (!context || context.jquery) {
				return (context || root).find(selector);

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor(context).find(selector);
			}

			// HANDLE: $(DOMElement)
		} else if (selector.nodeType) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

			// HANDLE: $(function)
			// Shortcut for document ready
		} else if (jQuery.isFunction(selector)) {
			return root.ready !== undefined ? root.ready(selector) :

			// Execute immediately if ready is not present
			selector(jQuery);
		}

		if (selector.selector !== undefined) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray(selector, this);
	};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery(document);

	var rparentsprev = /^(?:parents|prev(?:Until|All))/,


	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

	jQuery.fn.extend({
		has: function has(target) {
			var targets = jQuery(target, this),
			    l = targets.length;

			return this.filter(function () {
				var i = 0;
				for (; i &lt; l; i++) {
					if (jQuery.contains(this, targets[i])) {
						return true;
					}
				}
			});
		},

		closest: function closest(selectors, context) {
			var cur,
			    i = 0,
			    l = this.length,
			    matched = [],
			    pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;

			for (; i &lt; l; i++) {
				for (cur = this[i]; cur &amp;&amp; cur !== context; cur = cur.parentNode) {

					// Always skip document fragments
					if (cur.nodeType &lt; 11 &amp;&amp; (pos ? pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &amp;&amp; jQuery.find.matchesSelector(cur, selectors))) {

						matched.push(cur);
						break;
					}
				}
			}

			return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
		},

		// Determine the position of an element within the set
		index: function index(elem) {

			// No argument, return index in parent
			if (!elem) {
				return this[0] &amp;&amp; this[0].parentNode ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if (typeof elem === "string") {
				return indexOf.call(jQuery(elem), this[0]);
			}

			// Locate the position of the desired element
			return indexOf.call(this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem);
		},

		add: function add(selector, context) {
			return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
		},

		addBack: function addBack(selector) {
			return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
		}
	});

	function sibling(cur, dir) {
		while ((cur = cur[dir]) &amp;&amp; cur.nodeType !== 1) {}
		return cur;
	}

	jQuery.each({
		parent: function parent(elem) {
			var parent = elem.parentNode;
			return parent &amp;&amp; parent.nodeType !== 11 ? parent : null;
		},
		parents: function parents(elem) {
			return dir(elem, "parentNode");
		},
		parentsUntil: function parentsUntil(elem, i, until) {
			return dir(elem, "parentNode", until);
		},
		next: function next(elem) {
			return sibling(elem, "nextSibling");
		},
		prev: function prev(elem) {
			return sibling(elem, "previousSibling");
		},
		nextAll: function nextAll(elem) {
			return dir(elem, "nextSibling");
		},
		prevAll: function prevAll(elem) {
			return dir(elem, "previousSibling");
		},
		nextUntil: function nextUntil(elem, i, until) {
			return dir(elem, "nextSibling", until);
		},
		prevUntil: function prevUntil(elem, i, until) {
			return dir(elem, "previousSibling", until);
		},
		siblings: function siblings(elem) {
			return _siblings((elem.parentNode || {}).firstChild, elem);
		},
		children: function children(elem) {
			return _siblings(elem.firstChild);
		},
		contents: function contents(elem) {
			return elem.contentDocument || jQuery.merge([], elem.childNodes);
		}
	}, function (name, fn) {
		jQuery.fn[name] = function (until, selector) {
			var matched = jQuery.map(this, fn, until);

			if (name.slice(-5) !== "Until") {
				selector = until;
			}

			if (selector &amp;&amp; typeof selector === "string") {
				matched = jQuery.filter(selector, matched);
			}

			if (this.length > 1) {

				// Remove duplicates
				if (!guaranteedUnique[name]) {
					jQuery.uniqueSort(matched);
				}

				// Reverse order for parents* and prev-derivatives
				if (rparentsprev.test(name)) {
					matched.reverse();
				}
			}

			return this.pushStack(matched);
		};
	});
	var rnotwhite = /\S+/g;

	// Convert String-formatted options into Object-formatted ones
	function createOptions(options) {
		var object = {};
		jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
			object[flag] = true;
		});
		return object;
	}

	/*
  * Create a callback list using the following parameters:
  *
  *	options: an optional list of space-separated options that will change how
  *			the callback list behaves or a more traditional option object
  *
  * By default a callback list will act like an event callback list and can be
  * "fired" multiple times.
  *
  * Possible options:
  *
  *	once:			will ensure the callback list can only be fired once (like a Deferred)
  *
  *	memory:			will keep track of previous values and will call any callback added
  *					after the list has been fired right away with the latest "memorized"
  *					values (like a Deferred)
  *
  *	unique:			will ensure a callback can only be added once (no duplicate in the list)
  *
  *	stopOnFalse:	interrupt callings when a callback returns false
  *
  */
	jQuery.Callbacks = function (options) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

		var // Flag to know if list is currently firing
		firing,


		// Last fire value for non-forgettable lists
		memory,


		// Flag to know if list was already fired
		_fired,


		// Flag to prevent firing
		_locked,


		// Actual callback list
		list = [],


		// Queue of execution data for repeatable lists
		queue = [],


		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,


		// Fire callbacks
		fire = function fire() {

			// Enforce single-firing
			_locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			_fired = firing = true;
			for (; queue.length; firingIndex = -1) {
				memory = queue.shift();
				while (++firingIndex &lt; list.length) {

					// Run callback and check for early termination
					if (list[firingIndex].apply(memory[0], memory[1]) === false &amp;&amp; options.stopOnFalse) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if (!options.memory) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if (_locked) {

				// Keep an empty list if we have data for future add calls
				if (memory) {
					list = [];

					// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},


		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function add() {
				if (list) {

					// If we have memory from a past run, we should fire after adding
					if (memory &amp;&amp; !firing) {
						firingIndex = list.length - 1;
						queue.push(memory);
					}

					(function add(args) {
						jQuery.each(args, function (_, arg) {
							if (jQuery.isFunction(arg)) {
								if (!options.unique || !self.has(arg)) {
									list.push(arg);
								}
							} else if (arg &amp;&amp; arg.length &amp;&amp; jQuery.type(arg) !== "string") {

								// Inspect recursively
								add(arg);
							}
						});
					})(arguments);

					if (memory &amp;&amp; !firing) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function remove() {
				jQuery.each(arguments, function (_, arg) {
					var index;
					while ((index = jQuery.inArray(arg, list, index)) > -1) {
						list.splice(index, 1);

						// Handle firing indexes
						if (index &lt;= firingIndex) {
							firingIndex--;
						}
					}
				});
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function has(fn) {
				return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function empty() {
				if (list) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function disable() {
				_locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function disabled() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function lock() {
				_locked = queue = [];
				if (!memory) {
					list = memory = "";
				}
				return this;
			},
			locked: function locked() {
				return !!_locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function fireWith(context, args) {
				if (!_locked) {
					args = args || [];
					args = [context, args.slice ? args.slice() : args];
					queue.push(args);
					if (!firing) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function fire() {
				self.fireWith(this, arguments);
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function fired() {
				return !!_fired;
			}
		};

		return self;
	};

	jQuery.extend({

		Deferred: function Deferred(func) {
			var tuples = [

			// action, add listener, listener list, final state
			["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
			    _state = "pending",
			    _promise = {
				state: function state() {
					return _state;
				},
				always: function always() {
					deferred.done(arguments).fail(arguments);
					return this;
				},
				then: function then() /* fnDone, fnFail, fnProgress */{
					var fns = arguments;
					return jQuery.Deferred(function (newDefer) {
						jQuery.each(tuples, function (i, tuple) {
							var fn = jQuery.isFunction(fns[i]) &amp;&amp; fns[i];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[tuple[1]](function () {
								var returned = fn &amp;&amp; fn.apply(this, arguments);
								if (returned &amp;&amp; jQuery.isFunction(returned.promise)) {
									returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
								} else {
									newDefer[tuple[0] + "With"](this === _promise ? newDefer.promise() : this, fn ? [returned] : arguments);
								}
							});
						});
						fns = null;
					}).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function promise(obj) {
					return obj != null ? jQuery.extend(obj, _promise) : _promise;
				}
			},
			    deferred = {};

			// Keep pipe for back-compat
			_promise.pipe = _promise.then;

			// Add list-specific methods
			jQuery.each(tuples, function (i, tuple) {
				var list = tuple[2],
				    stateString = tuple[3];

				// promise[ done | fail | progress ] = list.add
				_promise[tuple[1]] = list.add;

				// Handle state
				if (stateString) {
					list.add(function () {

						// state = [ resolved | rejected ]
						_state = stateString;

						// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
				}

				// deferred[ resolve | reject | notify ]
				deferred[tuple[0]] = function () {
					deferred[tuple[0] + "With"](this === deferred ? _promise : this, arguments);
					return this;
				};
				deferred[tuple[0] + "With"] = list.fireWith;
			});

			// Make the deferred a promise
			_promise.promise(deferred);

			// Call given func if any
			if (func) {
				func.call(deferred, deferred);
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function when(subordinate /* , ..., subordinateN */) {
			var i = 0,
			    resolveValues = _slice.call(arguments),
			    length = resolveValues.length,


			// the count of uncompleted subordinates
			remaining = length !== 1 || subordinate &amp;&amp; jQuery.isFunction(subordinate.promise) ? length : 0,


			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),


			// Update function for both resolve and progress values
			updateFunc = function updateFunc(i, contexts, values) {
				return function (value) {
					contexts[i] = this;
					values[i] = arguments.length > 1 ? _slice.call(arguments) : value;
					if (values === progressValues) {
						deferred.notifyWith(contexts, values);
					} else if (! --remaining) {
						deferred.resolveWith(contexts, values);
					}
				};
			},
			    progressValues,
			    progressContexts,
			    resolveContexts;

			// Add listeners to Deferred subordinates; treat others as resolved
			if (length > 1) {
				progressValues = new Array(length);
				progressContexts = new Array(length);
				resolveContexts = new Array(length);
				for (; i &lt; length; i++) {
					if (resolveValues[i] &amp;&amp; jQuery.isFunction(resolveValues[i].promise)) {
						resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
					} else {
						--remaining;
					}
				}
			}

			// If we're not waiting on anything, resolve the master
			if (!remaining) {
				deferred.resolveWith(resolveContexts, resolveValues);
			}

			return deferred.promise();
		}
	});

	// The deferred used on DOM ready
	var readyList;

	jQuery.fn.ready = function (fn) {

		// Add the callback
		jQuery.ready.promise().done(fn);

		return this;
	};

	jQuery.extend({

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function holdReady(hold) {
			if (hold) {
				jQuery.readyWait++;
			} else {
				jQuery.ready(true);
			}
		},

		// Handle when the DOM is ready
		ready: function ready(wait) {

			// Abort if there are pending holds or we're already ready
			if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if (wait !== true &amp;&amp; --jQuery.readyWait > 0) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith(document, [jQuery]);

			// Trigger any bound ready events
			if (jQuery.fn.triggerHandler) {
				jQuery(document).triggerHandler("ready");
				jQuery(document).off("ready");
			}
		}
	});

	/**
  * The ready event handler and self cleanup method
  */
	function completed() {
		document.removeEventListener("DOMContentLoaded", completed);
		window.removeEventListener("load", completed);
		jQuery.ready();
	}

	jQuery.ready.promise = function (obj) {
		if (!readyList) {

			readyList = jQuery.Deferred();

			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE9-10 only
			// Older IE sometimes signals "interactive" too soon
			if (document.readyState === "complete" || document.readyState !== "loading" &amp;&amp; !document.documentElement.doScroll) {

				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout(jQuery.ready);
			} else {

				// Use the handy event callback
				document.addEventListener("DOMContentLoaded", completed);

				// A fallback to window.onload, that will always work
				window.addEventListener("load", completed);
			}
		}
		return readyList.promise(obj);
	};

	// Kick off the DOM ready check even if the user does not
	jQuery.ready.promise();

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
		var i = 0,
		    len = elems.length,
		    bulk = key == null;

		// Sets many values
		if (jQuery.type(key) === "object") {
			chainable = true;
			for (i in key) {
				access(elems, fn, i, key[i], true, emptyGet, raw);
			}

			// Sets one value
		} else if (value !== undefined) {
			chainable = true;

			if (!jQuery.isFunction(value)) {
				raw = true;
			}

			if (bulk) {

				// Bulk operations run against the entire set
				if (raw) {
					fn.call(elems, value);
					fn = null;

					// ...except when executing function values
				} else {
					bulk = fn;
					fn = function fn(elem, key, value) {
						return bulk.call(jQuery(elem), value);
					};
				}
			}

			if (fn) {
				for (; i &lt; len; i++) {
					fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
				}
			}
		}

		return chainable ? elems :

		// Gets
		bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
	};
	var acceptData = function acceptData(owner) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		/* jshint -W018 */
		return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
	};

	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		register: function register(owner, initial) {
			var value = initial || {};

			// If it is a node unlikely to be stringify-ed or looped over
			// use plain assignment
			if (owner.nodeType) {
				owner[this.expando] = value;

				// Otherwise secure it in a non-enumerable, non-writable property
				// configurability must be true to allow the property to be
				// deleted with the delete operator
			} else {
				Object.defineProperty(owner, this.expando, {
					value: value,
					writable: true,
					configurable: true
				});
			}
			return owner[this.expando];
		},
		cache: function cache(owner) {

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if (!acceptData(owner)) {
				return {};
			}

			// Check if the owner object already has a cache
			var value = owner[this.expando];

			// If not, create one
			if (!value) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if (acceptData(owner)) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if (owner.nodeType) {
						owner[this.expando] = value;

						// Otherwise secure it in a non-enumerable property
						// configurable must be true to allow the property to be
						// deleted when data is removed
					} else {
						Object.defineProperty(owner, this.expando, {
							value: value,
							configurable: true
						});
					}
				}
			}

			return value;
		},
		set: function set(owner, data, value) {
			var prop,
			    cache = this.cache(owner);

			// Handle: [ owner, key, value ] args
			if (typeof data === "string") {
				cache[data] = value;

				// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for (prop in data) {
					cache[prop] = data[prop];
				}
			}
			return cache;
		},
		get: function get(owner, key) {
			return key === undefined ? this.cache(owner) : owner[this.expando] &amp;&amp; owner[this.expando][key];
		},
		access: function access(owner, key, value) {
			var stored;

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if (key === undefined || key &amp;&amp; typeof key === "string" &amp;&amp; value === undefined) {

				stored = this.get(owner, key);

				return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set(owner, key, value);

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function remove(owner, key) {
			var i,
			    name,
			    camel,
			    cache = owner[this.expando];

			if (cache === undefined) {
				return;
			}

			if (key === undefined) {
				this.register(owner);
			} else {

				// Support array or space separated string of keys
				if (jQuery.isArray(key)) {

					// If "name" is an array of keys...
					// When data is initially created, via ("key", "val") signature,
					// keys will be converted to camelCase.
					// Since there is no way to tell _how_ a key was added, remove
					// both plain key and camelCase key. #12786
					// This will only penalize the array argument path.
					name = key.concat(key.map(jQuery.camelCase));
				} else {
					camel = jQuery.camelCase(key);

					// Try the string as a key before any manipulation
					if (key in cache) {
						name = [key, camel];
					} else {

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						name = camel;
						name = name in cache ? [name] : name.match(rnotwhite) || [];
					}
				}

				i = name.length;

				while (i--) {
					delete cache[name[i]];
				}
			}

			// Remove the expando if there's no more data
			if (key === undefined || jQuery.isEmptyObject(cache)) {

				// Support: Chrome &lt;= 35-45+
				// Webkit &amp; Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://code.google.com/p/chromium/issues/detail?id=378607
				if (owner.nodeType) {
					owner[this.expando] = undefined;
				} else {
					delete owner[this.expando];
				}
			}
		},
		hasData: function hasData(owner) {
			var cache = owner[this.expando];
			return cache !== undefined &amp;&amp; !jQuery.isEmptyObject(cache);
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();

	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	    rmultiDash = /[A-Z]/g;

	function dataAttr(elem, key, data) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if (data === undefined &amp;&amp; elem.nodeType === 1) {
			name = "data-" + key.replace(rmultiDash, "-$&amp;").toLowerCase();
			data = elem.getAttribute(name);

			if (typeof data === "string") {
				try {
					data = data === "true" ? true : data === "false" ? false : data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
				} catch (e) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set(elem, key, data);
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend({
		hasData: function hasData(elem) {
			return dataUser.hasData(elem) || dataPriv.hasData(elem);
		},

		data: function data(elem, name, _data) {
			return dataUser.access(elem, name, _data);
		},

		removeData: function removeData(elem, name) {
			dataUser.remove(elem, name);
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function _data(elem, name, data) {
			return dataPriv.access(elem, name, data);
		},

		_removeData: function _removeData(elem, name) {
			dataPriv.remove(elem, name);
		}
	});

	jQuery.fn.extend({
		data: function data(key, value) {
			var i,
			    name,
			    data,
			    elem = this[0],
			    attrs = elem &amp;&amp; elem.attributes;

			// Gets all values
			if (key === undefined) {
				if (this.length) {
					data = dataUser.get(elem);

					if (elem.nodeType === 1 &amp;&amp; !dataPriv.get(elem, "hasDataAttrs")) {
						i = attrs.length;
						while (i--) {

							// Support: IE11+
							// The attrs elements can be null (#14894)
							if (attrs[i]) {
								name = attrs[i].name;
								if (name.indexOf("data-") === 0) {
									name = jQuery.camelCase(name.slice(5));
									dataAttr(elem, name, data[name]);
								}
							}
						}
						dataPriv.set(elem, "hasDataAttrs", true);
					}
				}

				return data;
			}

			// Sets multiple values
			if ((typeof key === "undefined" ? "undefined" : _typeof(key)) === "object") {
				return this.each(function () {
					dataUser.set(this, key);
				});
			}

			return access(this, function (value) {
				var data, camelKey;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if (elem &amp;&amp; value === undefined) {

					// Attempt to get data from the cache
					// with the key as-is
					data = dataUser.get(elem, key) ||

					// Try to find dashed key if it exists (gh-2779)
					// This is for 2.2.x only
					dataUser.get(elem, key.replace(rmultiDash, "-$&amp;").toLowerCase());

					if (data !== undefined) {
						return data;
					}

					camelKey = jQuery.camelCase(key);

					// Attempt to get data from the cache
					// with the key camelized
					data = dataUser.get(elem, camelKey);
					if (data !== undefined) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr(elem, camelKey, undefined);
					if (data !== undefined) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				camelKey = jQuery.camelCase(key);
				this.each(function () {

					// First, attempt to store a copy or reference of any
					// data that might've been store with a camelCased key.
					var data = dataUser.get(this, camelKey);

					// For HTML5 data-* attribute interop, we have to
					// store property names with dashes in a camelCase form.
					// This might not apply to all properties...*
					dataUser.set(this, camelKey, value);

					// *... In the case of properties that might _actually_
					// have dashes, we need to also store a copy of that
					// unchanged property.
					if (key.indexOf("-") > -1 &amp;&amp; data !== undefined) {
						dataUser.set(this, key, value);
					}
				});
			}, null, value, arguments.length > 1, null, true);
		},

		removeData: function removeData(key) {
			return this.each(function () {
				dataUser.remove(this, key);
			});
		}
	});

	jQuery.extend({
		queue: function queue(elem, type, data) {
			var queue;

			if (elem) {
				type = (type || "fx") + "queue";
				queue = dataPriv.get(elem, type);

				// Speed up dequeue by getting out quickly if this is just a lookup
				if (data) {
					if (!queue || jQuery.isArray(data)) {
						queue = dataPriv.access(elem, type, jQuery.makeArray(data));
					} else {
						queue.push(data);
					}
				}
				return queue || [];
			}
		},

		dequeue: function dequeue(elem, type) {
			type = type || "fx";

			var queue = jQuery.queue(elem, type),
			    startLength = queue.length,
			    fn = queue.shift(),
			    hooks = jQuery._queueHooks(elem, type),
			    next = function next() {
				jQuery.dequeue(elem, type);
			};

			// If the fx queue is dequeued, always remove the progress sentinel
			if (fn === "inprogress") {
				fn = queue.shift();
				startLength--;
			}

			if (fn) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if (type === "fx") {
					queue.unshift("inprogress");
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call(elem, next, hooks);
			}

			if (!startLength &amp;&amp; hooks) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function _queueHooks(elem, type) {
			var key = type + "queueHooks";
			return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
				empty: jQuery.Callbacks("once memory").add(function () {
					dataPriv.remove(elem, [type + "queue", key]);
				})
			});
		}
	});

	jQuery.fn.extend({
		queue: function queue(type, data) {
			var setter = 2;

			if (typeof type !== "string") {
				data = type;
				type = "fx";
				setter--;
			}

			if (arguments.length &lt; setter) {
				return jQuery.queue(this[0], type);
			}

			return data === undefined ? this : this.each(function () {
				var queue = jQuery.queue(this, type, data);

				// Ensure a hooks for this queue
				jQuery._queueHooks(this, type);

				if (type === "fx" &amp;&amp; queue[0] !== "inprogress") {
					jQuery.dequeue(this, type);
				}
			});
		},
		dequeue: function dequeue(type) {
			return this.each(function () {
				jQuery.dequeue(this, type);
			});
		},
		clearQueue: function clearQueue(type) {
			return this.queue(type || "fx", []);
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function promise(type, obj) {
			var tmp,
			    count = 1,
			    defer = jQuery.Deferred(),
			    elements = this,
			    i = this.length,
			    resolve = function resolve() {
				if (! --count) {
					defer.resolveWith(elements, [elements]);
				}
			};

			if (typeof type !== "string") {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while (i--) {
				tmp = dataPriv.get(elements[i], type + "queueHooks");
				if (tmp &amp;&amp; tmp.empty) {
					count++;
					tmp.empty.add(resolve);
				}
			}
			resolve();
			return defer.promise(obj);
		}
	});
	var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

	var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");

	var cssExpand = ["Top", "Right", "Bottom", "Left"];

	var isHidden = function isHidden(elem, el) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
	};

	function adjustCSS(elem, prop, valueParts, tween) {
		var adjusted,
		    scale = 1,
		    maxIterations = 20,
		    currentValue = tween ? function () {
			return tween.cur();
		} : function () {
			return jQuery.css(elem, prop, "");
		},
		    initial = currentValue(),
		    unit = valueParts &amp;&amp; valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),


		// Starting value computation is required for potential unit mismatches
		initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" &amp;&amp; +initial) &amp;&amp; rcssNum.exec(jQuery.css(elem, prop));

		if (initialInUnit &amp;&amp; initialInUnit[3] !== unit) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[3];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style(elem, prop, initialInUnit + unit);

				// Update scale, tolerating zero or NaN from tween.cur()
				// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (scale !== (scale = currentValue() / initial) &amp;&amp; scale !== 1 &amp;&amp; --maxIterations);
		}

		if (valueParts) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
			if (tween) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	var rcheckableType = /^(?:checkbox|radio)$/i;

	var rtagName = /&lt;([\w:-]+)/;

	var rscriptType = /^$|\/(?:java|ecma)script/i;

	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE9
		option: [1, "&lt;select multiple='multiple'>", "&lt;/select>"],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting &lt;tbody> or other required elements.
		thead: [1, "&lt;table>", "&lt;/table>"],
		col: [2, "&lt;table>&lt;colgroup>", "&lt;/colgroup>&lt;/table>"],
		tr: [2, "&lt;table>&lt;tbody>", "&lt;/tbody>&lt;/table>"],
		td: [3, "&lt;table>&lt;tbody>&lt;tr>", "&lt;/tr>&lt;/tbody>&lt;/table>"],

		_default: [0, "", ""]
	};

	// Support: IE9
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	function getAll(context, tag) {

		// Support: IE9-11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];

		return tag === undefined || tag &amp;&amp; jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval(elems, refElements) {
		var i = 0,
		    l = elems.length;

		for (; i &lt; l; i++) {
			dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
		}
	}

	var rhtml = /&lt;|&amp;#?\w+;/;

	function buildFragment(elems, context, scripts, selection, ignored) {
		var elem,
		    tmp,
		    tag,
		    wrap,
		    contains,
		    j,
		    fragment = context.createDocumentFragment(),
		    nodes = [],
		    i = 0,
		    l = elems.length;

		for (; i &lt; l; i++) {
			elem = elems[i];

			if (elem || elem === 0) {

				// Add nodes directly
				if (jQuery.type(elem) === "object") {

					// Support: Android&lt;4.1, PhantomJS&lt;2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

					// Convert non-html into a text node
				} else if (!rhtml.test(elem)) {
					nodes.push(context.createTextNode(elem));

					// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild(context.createElement("div"));

					// Deserialize a standard representation
					tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
					wrap = wrapMap[tag] || wrapMap._default;
					tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while (j--) {
						tmp = tmp.lastChild;
					}

					// Support: Android&lt;4.1, PhantomJS&lt;2
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge(nodes, tmp.childNodes);

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while (elem = nodes[i++]) {

			// Skip elements already in the context collection (trac-4087)
			if (selection &amp;&amp; jQuery.inArray(elem, selection) > -1) {
				if (ignored) {
					ignored.push(elem);
				}
				continue;
			}

			contains = jQuery.contains(elem.ownerDocument, elem);

			// Append to fragment
			tmp = getAll(fragment.appendChild(elem), "script");

			// Preserve script evaluation history
			if (contains) {
				setGlobalEval(tmp);
			}

			// Capture executables
			if (scripts) {
				j = 0;
				while (elem = tmp[j++]) {
					if (rscriptType.test(elem.type || "")) {
						scripts.push(elem);
					}
				}
			}
		}

		return fragment;
	}

	(function () {
		var fragment = document.createDocumentFragment(),
		    div = fragment.appendChild(document.createElement("div")),
		    input = document.createElement("input");

		// Support: Android 4.0-4.3, Safari&lt;=5.1
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute("type", "radio");
		input.setAttribute("checked", "checked");
		input.setAttribute("name", "t");

		div.appendChild(input);

		// Support: Safari&lt;=5.1, Android&lt;4.2
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

		// Support: IE&lt;=11+
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "&lt;textarea>x&lt;/textarea>";
		support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
	})();

	var rkeyEvent = /^key/,
	    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE9
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch (err) {}
	}

	function _on(elem, types, selector, data, fn, one) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {

			// ( types-Object, selector, data )
			if (typeof selector !== "string") {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for (type in types) {
				_on(elem, type, selector, data, types[type], one);
			}
			return elem;
		}

		if (data == null &amp;&amp; fn == null) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if (fn == null) {
			if (typeof selector === "string") {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if (fn === false) {
			fn = returnFalse;
		} else if (!fn) {
			return elem;
		}

		if (one === 1) {
			origFn = fn;
			fn = function fn(event) {

				// Can use an empty set, since event contains the info
				jQuery().off(event);
				return origFn.apply(this, arguments);
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
		}
		return elem.each(function () {
			jQuery.event.add(this, types, fn, data, selector);
		});
	}

	/*
  * Helper functions for managing events -- not part of the public interface.
  * Props to Dean Edwards' addEvent library for many of the ideas.
  */
	jQuery.event = {

		global: {},

		add: function add(elem, types, handler, data, selector) {

			var handleObjIn,
			    eventHandle,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.get(elem);

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if (!elemData) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if (handler.handler) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if (!handler.guid) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if (!(events = elemData.events)) {
				events = elemData.events = {};
			}
			if (!(eventHandle = elemData.handle)) {
				eventHandle = elemData.handle = function (e) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" &amp;&amp; jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = (types || "").match(rnotwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// There *must* be a type, no attaching namespace-only handlers
				if (!type) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[type] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = (selector ? special.delegateType : special.bindType) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[type] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend({
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test(selector),
					namespace: namespaces.join(".")
				}, handleObjIn);

				// Init the event handler queue if we're the first
				if (!(handlers = events[type])) {
					handlers = events[type] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {

						if (elem.addEventListener) {
							elem.addEventListener(type, eventHandle);
						}
					}
				}

				if (special.add) {
					special.add.call(elem, handleObj);

					if (!handleObj.handler.guid) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if (selector) {
					handlers.splice(handlers.delegateCount++, 0, handleObj);
				} else {
					handlers.push(handleObj);
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[type] = true;
			}
		},

		// Detach an event or set of events from an element
		remove: function remove(elem, types, handler, selector, mappedTypes) {

			var j,
			    origCount,
			    tmp,
			    events,
			    t,
			    handleObj,
			    special,
			    handlers,
			    type,
			    namespaces,
			    origType,
			    elemData = dataPriv.hasData(elem) &amp;&amp; dataPriv.get(elem);

			if (!elemData || !(events = elemData.events)) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = (types || "").match(rnotwhite) || [""];
			t = types.length;
			while (t--) {
				tmp = rtypenamespace.exec(types[t]) || [];
				type = origType = tmp[1];
				namespaces = (tmp[2] || "").split(".").sort();

				// Unbind all events (on this namespace, if provided) for the element
				if (!type) {
					for (type in events) {
						jQuery.event.remove(elem, type + types[t], handler, selector, true);
					}
					continue;
				}

				special = jQuery.event.special[type] || {};
				type = (selector ? special.delegateType : special.bindType) || type;
				handlers = events[type] || [];
				tmp = tmp[2] &amp;&amp; new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

				// Remove matching events
				origCount = j = handlers.length;
				while (j--) {
					handleObj = handlers[j];

					if ((mappedTypes || origType === handleObj.origType) &amp;&amp; (!handler || handler.guid === handleObj.guid) &amp;&amp; (!tmp || tmp.test(handleObj.namespace)) &amp;&amp; (!selector || selector === handleObj.selector || selector === "**" &amp;&amp; handleObj.selector)) {
						handlers.splice(j, 1);

						if (handleObj.selector) {
							handlers.delegateCount--;
						}
						if (special.remove) {
							special.remove.call(elem, handleObj);
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if (origCount &amp;&amp; !handlers.length) {
					if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {

						jQuery.removeEvent(elem, type, elemData.handle);
					}

					delete events[type];
				}
			}

			// Remove data and the expando if it's no longer used
			if (jQuery.isEmptyObject(events)) {
				dataPriv.remove(elem, "handle events");
			}
		},

		dispatch: function dispatch(event) {

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix(event);

			var i,
			    j,
			    ret,
			    matched,
			    handleObj,
			    handlerQueue = [],
			    args = _slice.call(arguments),
			    handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
			    special = jQuery.event.special[event.type] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[0] = event;
			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if (special.preDispatch &amp;&amp; special.preDispatch.call(this, event) === false) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call(this, event, handlers);

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ((matched = handlerQueue[i++]) &amp;&amp; !event.isPropagationStopped()) {
				event.currentTarget = matched.elem;

				j = 0;
				while ((handleObj = matched.handlers[j++]) &amp;&amp; !event.isImmediatePropagationStopped()) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

						if (ret !== undefined) {
							if ((event.result = ret) === false) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if (special.postDispatch) {
				special.postDispatch.call(this, event);
			}

			return event.result;
		},

		handlers: function handlers(event, _handlers) {
			var i,
			    matches,
			    sel,
			    handleObj,
			    handlerQueue = [],
			    delegateCount = _handlers.delegateCount,
			    cur = event.target;

			// Support (at least): Chrome, IE9
			// Find delegate handlers
			// Black-hole SVG &lt;use> instance trees (#13180)
			//
			// Support: Firefox&lt;=42+
			// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
			if (delegateCount &amp;&amp; cur.nodeType &amp;&amp; (event.type !== "click" || isNaN(event.button) || event.button &lt; 1)) {

				for (; cur !== this; cur = cur.parentNode || this) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if (cur.nodeType === 1 &amp;&amp; (cur.disabled !== true || event.type !== "click")) {
						matches = [];
						for (i = 0; i &lt; delegateCount; i++) {
							handleObj = _handlers[i];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if (matches[sel] === undefined) {
								matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
							}
							if (matches[sel]) {
								matches.push(handleObj);
							}
						}
						if (matches.length) {
							handlerQueue.push({ elem: cur, handlers: matches });
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			if (delegateCount &lt; _handlers.length) {
				handlerQueue.push({ elem: this, handlers: _handlers.slice(delegateCount) });
			}

			return handlerQueue;
		},

		// Includes some event props shared by KeyEvent and MouseEvent
		props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),

		fixHooks: {},

		keyHooks: {
			props: "char charCode key keyCode".split(" "),
			filter: function filter(event, original) {

				// Add which for key events
				if (event.which == null) {
					event.which = original.charCode != null ? original.charCode : original.keyCode;
				}

				return event;
			}
		},

		mouseHooks: {
			props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
			filter: function filter(event, original) {
				var eventDoc,
				    doc,
				    body,
				    button = original.button;

				// Calculate pageX/Y if missing and clientX/Y available
				if (event.pageX == null &amp;&amp; original.clientX != null) {
					eventDoc = event.target.ownerDocument || document;
					doc = eventDoc.documentElement;
					body = eventDoc.body;

					event.pageX = original.clientX + (doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0) - (doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0);
					event.pageY = original.clientY + (doc &amp;&amp; doc.scrollTop || body &amp;&amp; body.scrollTop || 0) - (doc &amp;&amp; doc.clientTop || body &amp;&amp; body.clientTop || 0);
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				// Note: button is not normalized, so don't use it
				if (!event.which &amp;&amp; button !== undefined) {
					event.which = button &amp; 1 ? 1 : button &amp; 2 ? 3 : button &amp; 4 ? 2 : 0;
				}

				return event;
			}
		},

		fix: function fix(event) {
			if (event[jQuery.expando]) {
				return event;
			}

			// Create a writable copy of the event object and normalize some properties
			var i,
			    prop,
			    copy,
			    type = event.type,
			    originalEvent = event,
			    fixHook = this.fixHooks[type];

			if (!fixHook) {
				this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
			}
			copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

			event = new jQuery.Event(originalEvent);

			i = copy.length;
			while (i--) {
				prop = copy[i];
				event[prop] = originalEvent[prop];
			}

			// Support: Cordova 2.5 (WebKit) (#13255)
			// All events should have a target; Cordova deviceready doesn't
			if (!event.target) {
				event.target = document;
			}

			// Support: Safari 6.0+, Chrome&lt;28
			// Target should not be a text node (#504, #13143)
			if (event.target.nodeType === 3) {
				event.target = event.target.parentNode;
			}

			return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function trigger() {
					if (this !== safeActiveElement() &amp;&amp; this.focus) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function trigger() {
					if (this === safeActiveElement() &amp;&amp; this.blur) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function trigger() {
					if (this.type === "checkbox" &amp;&amp; this.click &amp;&amp; jQuery.nodeName(this, "input")) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function _default(event) {
					return jQuery.nodeName(event.target, "a");
				}
			},

			beforeunload: {
				postDispatch: function postDispatch(event) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if (event.result !== undefined &amp;&amp; event.originalEvent) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function (elem, type, handle) {

		// This "if" is needed for plain objects
		if (elem.removeEventListener) {
			elem.removeEventListener(type, handle);
		}
	};

	jQuery.Event = function (src, props) {

		// Allow instantiation without the 'new' keyword
		if (!(this instanceof jQuery.Event)) {
			return new jQuery.Event(src, props);
		}

		// Event object
		if (src &amp;&amp; src.type) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &amp;&amp;

			// Support: Android&lt;4.0
			src.returnValue === false ? returnTrue : returnFalse;

			// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if (props) {
			jQuery.extend(this, props);
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[jQuery.expando] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function preventDefault() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if (e &amp;&amp; !this.isSimulated) {
				e.preventDefault();
			}
		},
		stopPropagation: function stopPropagation() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if (e &amp;&amp; !this.isSimulated) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function stopImmediatePropagation() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if (e &amp;&amp; !this.isSimulated) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://code.google.com/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function (orig, fix) {
		jQuery.event.special[orig] = {
			delegateType: fix,
			bindType: fix,

			handle: function handle(event) {
				var ret,
				    target = this,
				    related = event.relatedTarget,
				    handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if (!related || related !== target &amp;&amp; !jQuery.contains(target, related)) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply(this, arguments);
					event.type = fix;
				}
				return ret;
			}
		};
	});

	jQuery.fn.extend({
		on: function on(types, selector, data, fn) {
			return _on(this, types, selector, data, fn);
		},
		one: function one(types, selector, data, fn) {
			return _on(this, types, selector, data, fn, 1);
		},
		off: function off(types, selector, fn) {
			var handleObj, type;
			if (types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
				return this;
			}
			if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {

				// ( types-object [, selector] )
				for (type in types) {
					this.off(type, selector, types[type]);
				}
				return this;
			}
			if (selector === false || typeof selector === "function") {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if (fn === false) {
				fn = returnFalse;
			}
			return this.each(function () {
				jQuery.event.remove(this, types, fn, selector);
			});
		}
	});

	var rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,


	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /&lt;script|&lt;style|&lt;link/i,


	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	    rscriptTypeMasked = /^true\/(.*)/,
	    rcleanScript = /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Manipulating tables requires a tbody
	function manipulationTarget(elem, content) {
		return jQuery.nodeName(elem, "table") &amp;&amp; jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript(elem) {
		elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
		return elem;
	}
	function restoreScript(elem) {
		var match = rscriptTypeMasked.exec(elem.type);

		if (match) {
			elem.type = match[1];
		} else {
			elem.removeAttribute("type");
		}

		return elem;
	}

	function cloneCopyEvent(src, dest) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if (dest.nodeType !== 1) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if (dataPriv.hasData(src)) {
			pdataOld = dataPriv.access(src);
			pdataCur = dataPriv.set(dest, pdataOld);
			events = pdataOld.events;

			if (events) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for (type in events) {
					for (i = 0, l = events[type].length; i &lt; l; i++) {
						jQuery.event.add(dest, type, events[type][i]);
					}
				}
			}
		}

		// 2. Copy user data
		if (dataUser.hasData(src)) {
			udataOld = dataUser.access(src);
			udataCur = jQuery.extend({}, udataOld);

			dataUser.set(dest, udataCur);
		}
	}

	// Fix IE bugs, see support tests
	function fixInput(src, dest) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if (nodeName === "input" &amp;&amp; rcheckableType.test(src.type)) {
			dest.checked = src.checked;

			// Fails to return the selected option to the default selected state when cloning options
		} else if (nodeName === "input" || nodeName === "textarea") {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip(collection, args, callback, ignored) {

		// Flatten any nested arrays
		args = concat.apply([], args);

		var fragment,
		    first,
		    scripts,
		    hasScripts,
		    node,
		    doc,
		    i = 0,
		    l = collection.length,
		    iNoClone = l - 1,
		    value = args[0],
		    isFunction = jQuery.isFunction(value);

		// We can't cloneNode fragments that contain checked, in WebKit
		if (isFunction || l > 1 &amp;&amp; typeof value === "string" &amp;&amp; !support.checkClone &amp;&amp; rchecked.test(value)) {
			return collection.each(function (index) {
				var self = collection.eq(index);
				if (isFunction) {
					args[0] = value.call(this, index, self.html());
				}
				domManip(self, args, callback, ignored);
			});
		}

		if (l) {
			fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
			first = fragment.firstChild;

			if (fragment.childNodes.length === 1) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if (first || ignored) {
				scripts = jQuery.map(getAll(fragment, "script"), disableScript);
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for (; i &lt; l; i++) {
					node = fragment;

					if (i !== iNoClone) {
						node = jQuery.clone(node, true, true);

						// Keep references to cloned scripts for later restoration
						if (hasScripts) {

							// Support: Android&lt;4.1, PhantomJS&lt;2
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge(scripts, getAll(node, "script"));
						}
					}

					callback.call(collection[i], node, i);
				}

				if (hasScripts) {
					doc = scripts[scripts.length - 1].ownerDocument;

					// Reenable scripts
					jQuery.map(scripts, restoreScript);

					// Evaluate executable scripts on first document insertion
					for (i = 0; i &lt; hasScripts; i++) {
						node = scripts[i];
						if (rscriptType.test(node.type || "") &amp;&amp; !dataPriv.access(node, "globalEval") &amp;&amp; jQuery.contains(doc, node)) {

							if (node.src) {

								// Optional AJAX dependency, but won't run scripts if not present
								if (jQuery._evalUrl) {
									jQuery._evalUrl(node.src);
								}
							} else {
								jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function _remove(elem, selector, keepData) {
		var node,
		    nodes = selector ? jQuery.filter(selector, elem) : elem,
		    i = 0;

		for (; (node = nodes[i]) != null; i++) {
			if (!keepData &amp;&amp; node.nodeType === 1) {
				jQuery.cleanData(getAll(node));
			}

			if (node.parentNode) {
				if (keepData &amp;&amp; jQuery.contains(node.ownerDocument, node)) {
					setGlobalEval(getAll(node, "script"));
				}
				node.parentNode.removeChild(node);
			}
		}

		return elem;
	}

	jQuery.extend({
		htmlPrefilter: function htmlPrefilter(html) {
			return html.replace(rxhtmlTag, "&lt;$1>&lt;/$2>");
		},

		clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
			var i,
			    l,
			    srcElements,
			    destElements,
			    clone = elem.cloneNode(true),
			    inPage = jQuery.contains(elem.ownerDocument, elem);

			// Fix IE cloning issues
			if (!support.noCloneChecked &amp;&amp; (elem.nodeType === 1 || elem.nodeType === 11) &amp;&amp; !jQuery.isXMLDoc(elem)) {

				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
				destElements = getAll(clone);
				srcElements = getAll(elem);

				for (i = 0, l = srcElements.length; i &lt; l; i++) {
					fixInput(srcElements[i], destElements[i]);
				}
			}

			// Copy the events from the original to the clone
			if (dataAndEvents) {
				if (deepDataAndEvents) {
					srcElements = srcElements || getAll(elem);
					destElements = destElements || getAll(clone);

					for (i = 0, l = srcElements.length; i &lt; l; i++) {
						cloneCopyEvent(srcElements[i], destElements[i]);
					}
				} else {
					cloneCopyEvent(elem, clone);
				}
			}

			// Preserve script evaluation history
			destElements = getAll(clone, "script");
			if (destElements.length > 0) {
				setGlobalEval(destElements, !inPage &amp;&amp; getAll(elem, "script"));
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function cleanData(elems) {
			var data,
			    elem,
			    type,
			    special = jQuery.event.special,
			    i = 0;

			for (; (elem = elems[i]) !== undefined; i++) {
				if (acceptData(elem)) {
					if (data = elem[dataPriv.expando]) {
						if (data.events) {
							for (type in data.events) {
								if (special[type]) {
									jQuery.event.remove(elem, type);

									// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent(elem, type, data.handle);
								}
							}
						}

						// Support: Chrome &lt;= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataPriv.expando] = undefined;
					}
					if (elem[dataUser.expando]) {

						// Support: Chrome &lt;= 35-45+
						// Assign undefined instead of using delete, see Data#remove
						elem[dataUser.expando] = undefined;
					}
				}
			}
		}
	});

	jQuery.fn.extend({

		// Keep domManip exposed until 3.0 (gh-2225)
		domManip: domManip,

		detach: function detach(selector) {
			return _remove(this, selector, true);
		},

		remove: function remove(selector) {
			return _remove(this, selector);
		},

		text: function text(value) {
			return access(this, function (value) {
				return value === undefined ? jQuery.text(this) : this.empty().each(function () {
					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						this.textContent = value;
					}
				});
			}, null, value, arguments.length);
		},

		append: function append() {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.appendChild(elem);
				}
			});
		},

		prepend: function prepend() {
			return domManip(this, arguments, function (elem) {
				if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
					var target = manipulationTarget(this, elem);
					target.insertBefore(elem, target.firstChild);
				}
			});
		},

		before: function before() {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this);
				}
			});
		},

		after: function after() {
			return domManip(this, arguments, function (elem) {
				if (this.parentNode) {
					this.parentNode.insertBefore(elem, this.nextSibling);
				}
			});
		},

		empty: function empty() {
			var elem,
			    i = 0;

			for (; (elem = this[i]) != null; i++) {
				if (elem.nodeType === 1) {

					// Prevent memory leaks
					jQuery.cleanData(getAll(elem, false));

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function clone(dataAndEvents, deepDataAndEvents) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map(function () {
				return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
			});
		},

		html: function html(value) {
			return access(this, function (value) {
				var elem = this[0] || {},
				    i = 0,
				    l = this.length;

				if (value === undefined &amp;&amp; elem.nodeType === 1) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if (typeof value === "string" &amp;&amp; !rnoInnerhtml.test(value) &amp;&amp; !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

					value = jQuery.htmlPrefilter(value);

					try {
						for (; i &lt; l; i++) {
							elem = this[i] || {};

							// Remove element nodes and prevent memory leaks
							if (elem.nodeType === 1) {
								jQuery.cleanData(getAll(elem, false));
								elem.innerHTML = value;
							}
						}

						elem = 0;

						// If using innerHTML throws an exception, use the fallback method
					} catch (e) {}
				}

				if (elem) {
					this.empty().append(value);
				}
			}, null, value, arguments.length);
		},

		replaceWith: function replaceWith() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip(this, arguments, function (elem) {
				var parent = this.parentNode;

				if (jQuery.inArray(this, ignored) &lt; 0) {
					jQuery.cleanData(getAll(this));
					if (parent) {
						parent.replaceChild(elem, this);
					}
				}

				// Force callback invocation
			}, ignored);
		}
	});

	jQuery.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function (name, original) {
		jQuery.fn[name] = function (selector) {
			var elems,
			    ret = [],
			    insert = jQuery(selector),
			    last = insert.length - 1,
			    i = 0;

			for (; i &lt;= last; i++) {
				elems = i === last ? this : this.clone(true);
				jQuery(insert[i])[original](elems);

				// Support: QtWebKit
				// .get() because push.apply(_, arraylike) throws
				push.apply(ret, elems.get());
			}

			return this.pushStack(ret);
		};
	});

	var iframe,
	    elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

	/**
  * Retrieve the actual display of a element
  * @param {String} name nodeName of the element
  * @param {Object} doc Document object
  */

	// Called only from within defaultDisplay
	function actualDisplay(name, doc) {
		var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
		    display = jQuery.css(elem[0], "display");

		// We don't have any data stored on the element,
		// so use "detach" method as fast way to get rid of the element
		elem.detach();

		return display;
	}

	/**
  * Try to determine the default display value of an element
  * @param {String} nodeName
  */
	function defaultDisplay(nodeName) {
		var doc = document,
		    display = elemdisplay[nodeName];

		if (!display) {
			display = actualDisplay(nodeName, doc);

			// If the simple way fails, read from inside an iframe
			if (display === "none" || !display) {

				// Use the already-created iframe if possible
				iframe = (iframe || jQuery("&lt;iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

				// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
				doc = iframe[0].contentDocument;

				// Support: IE
				doc.write();
				doc.close();

				display = actualDisplay(nodeName, doc);
				iframe.detach();
			}

			// Store the correct default display
			elemdisplay[nodeName] = display;
		}

		return display;
	}
	var rmargin = /^margin/;

	var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

	var getStyles = function getStyles(elem) {

		// Support: IE&lt;=11+, Firefox&lt;=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if (!view || !view.opener) {
			view = window;
		}

		return view.getComputedStyle(elem);
	};

	var swap = function swap(elem, options, callback, args) {
		var ret,
		    name,
		    old = {};

		// Remember the old values, and insert the new ones
		for (name in options) {
			old[name] = elem.style[name];
			elem.style[name] = options[name];
		}

		ret = callback.apply(elem, args || []);

		// Revert the old values
		for (name in options) {
			elem.style[name] = old[name];
		}

		return ret;
	};

	var documentElement = document.documentElement;

	(function () {
		var pixelPositionVal,
		    boxSizingReliableVal,
		    pixelMarginRightVal,
		    reliableMarginLeftVal,
		    container = document.createElement("div"),
		    div = document.createElement("div");

		// Finish early in limited (non-browser) environments
		if (!div.style) {
			return;
		}

		// Support: IE9-11+
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode(true).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
		container.appendChild(div);

		// Executing both pixelPosition &amp; boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
			div.style.cssText =

			// Support: Firefox&lt;29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild(container);

			var divStyle = window.getComputedStyle(div);
			pixelPositionVal = divStyle.top !== "1%";
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild(container);
		}

		jQuery.extend(support, {
			pixelPosition: function pixelPosition() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function boxSizingReliable() {
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return boxSizingReliableVal;
			},
			pixelMarginRight: function pixelMarginRight() {

				// Support: Android 4.0-4.3
				// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
				// since that compresses better and they're computed together anyway.
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function reliableMarginLeft() {

				// Support: IE &lt;=8 only, Android 4.0 - 4.3 only, Firefox &lt;=3 - 37
				if (boxSizingReliableVal == null) {
					computeStyleTests();
				}
				return reliableMarginLeftVal;
			},
			reliableMarginRight: function reliableMarginRight() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
				    marginDiv = div.appendChild(document.createElement("div"));

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				documentElement.appendChild(container);

				ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);

				documentElement.removeChild(container);
				div.removeChild(marginDiv);

				return ret;
			}
		});
	})();

	function curCSS(elem, name, computed) {
		var width,
		    minWidth,
		    maxWidth,
		    ret,
		    style = elem.style;

		computed = computed || getStyles(elem);
		ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;

		// Support: Opera 12.1x only
		// Fall back to style even without computed
		// computed is undefined for elems on document fragments
		if ((ret === "" || ret === undefined) &amp;&amp; !jQuery.contains(elem.ownerDocument, elem)) {
			ret = jQuery.style(elem, name);
		}

		// Support: IE9
		// getPropertyValue is only needed for .css('filter') (#12537)
		if (computed) {

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// http://dev.w3.org/csswg/cssom/#resolved-values
			if (!support.pixelMarginRight() &amp;&amp; rnumnonpx.test(ret) &amp;&amp; rmargin.test(name)) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

		// Support: IE9-11+
		// IE returns zIndex value as an integer.
		ret + "" : ret;
	}

	function addGetHookIf(conditionFn, hookFn) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function get() {
				if (conditionFn()) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return (this.get = hookFn).apply(this, arguments);
			}
		};
	}

	var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	    cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},
	    cssPrefixes = ["Webkit", "O", "Moz", "ms"],
	    emptyStyle = document.createElement("div").style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName(name) {

		// Shortcut for names that are not vendor prefixed
		if (name in emptyStyle) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[0].toUpperCase() + name.slice(1),
		    i = cssPrefixes.length;

		while (i--) {
			name = cssPrefixes[i] + capName;
			if (name in emptyStyle) {
				return name;
			}
		}
	}

	function setPositiveNumber(elem, value, subtract) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec(value);
		return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
	}

	function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
		var i = extra === (isBorderBox ? "border" : "content") ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,
		    val = 0;

		for (; i &lt; 4; i += 2) {

			// Both box models exclude margin, so add it if we want it
			if (extra === "margin") {
				val += jQuery.css(elem, extra + cssExpand[i], true, styles);
			}

			if (isBorderBox) {

				// border-box includes padding, so remove it if we want content
				if (extra === "content") {
					val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
				}

				// At this point, extra isn't border nor margin, so remove border
				if (extra !== "margin") {
					val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

				// At this point, extra isn't content nor padding, so add border
				if (extra !== "padding") {
					val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
				}
			}
		}

		return val;
	}

	function getWidthOrHeight(elem, name, extra) {

		// Start with offset property, which is equivalent to the border-box value
		var valueIsBorderBox = true,
		    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		    styles = getStyles(elem),
		    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if (val &lt;= 0 || val == null) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS(elem, name, styles);
			if (val &lt; 0 || val == null) {
				val = elem.style[name];
			}

			// Computed unit is not pixels. Stop here and return.
			if (rnumnonpx.test(val)) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &amp;&amp; (support.boxSizingReliable() || val === elem.style[name]);

			// Normalize "", auto, and prepare for extra
			val = parseFloat(val) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
	}

	function showHide(elements, show) {
		var display,
		    elem,
		    hidden,
		    values = [],
		    index = 0,
		    length = elements.length;

		for (; index &lt; length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}

			values[index] = dataPriv.get(elem, "olddisplay");
			display = elem.style.display;
			if (show) {

				// Reset the inline display of this element to learn if it is
				// being hidden by cascaded rules or not
				if (!values[index] &amp;&amp; display === "none") {
					elem.style.display = "";
				}

				// Set elements which have been overridden with display: none
				// in a stylesheet to whatever the default browser style is
				// for such an element
				if (elem.style.display === "" &amp;&amp; isHidden(elem)) {
					values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
				}
			} else {
				hidden = isHidden(elem);

				if (display !== "none" || !hidden) {
					dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
				}
			}
		}

		// Set the display of most of the elements in a second loop
		// to avoid the constant reflow
		for (index = 0; index &lt; length; index++) {
			elem = elements[index];
			if (!elem.style) {
				continue;
			}
			if (!show || elem.style.display === "none" || elem.style.display === "") {
				elem.style.display = show ? values[index] || "" : "none";
			}
		}

		return elements;
	}

	jQuery.extend({

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function get(elem, computed) {
					if (computed) {

						// We should always get a number back from opacity
						var ret = curCSS(elem, "opacity");
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function style(elem, name, value, extra) {

			// Don't set styles on text and comment nodes
			if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
				return;
			}

			// Make sure that we're working with the right name
			var ret,
			    type,
			    hooks,
			    origName = jQuery.camelCase(name),
			    style = elem.style;

			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// Check if we're setting a value
			if (value !== undefined) {
				type = typeof value === "undefined" ? "undefined" : _typeof(value);

				// Convert "+=" or "-=" to relative numbers (#7345)
				if (type === "string" &amp;&amp; (ret = rcssNum.exec(value)) &amp;&amp; ret[1]) {
					value = adjustCSS(elem, name, ret);

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if (value == null || value !== value) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if (type === "number") {
					value += ret &amp;&amp; ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
				}

				// Support: IE9-11+
				// background-* props affect original clone's values
				if (!support.clearCloneStyle &amp;&amp; value === "" &amp;&amp; name.indexOf("background") === 0) {
					style[name] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {

					style[name] = value;
				}
			} else {

				// If a hook was provided get the non-computed value from there
				if (hooks &amp;&amp; "get" in hooks &amp;&amp; (ret = hooks.get(elem, false, extra)) !== undefined) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[name];
			}
		},

		css: function css(elem, name, extra, styles) {
			var val,
			    num,
			    hooks,
			    origName = jQuery.camelCase(name);

			// Make sure that we're working with the right name
			name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

			// If a hook was provided get the computed value from there
			if (hooks &amp;&amp; "get" in hooks) {
				val = hooks.get(elem, true, extra);
			}

			// Otherwise, if a way to get the computed value exists, use that
			if (val === undefined) {
				val = curCSS(elem, name, styles);
			}

			// Convert "normal" to computed value
			if (val === "normal" &amp;&amp; name in cssNormalTransform) {
				val = cssNormalTransform[name];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if (extra === "" || extra) {
				num = parseFloat(val);
				return extra === true || isFinite(num) ? num || 0 : val;
			}
			return val;
		}
	});

	jQuery.each(["height", "width"], function (i, name) {
		jQuery.cssHooks[name] = {
			get: function get(elem, computed, extra) {
				if (computed) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test(jQuery.css(elem, "display")) &amp;&amp; elem.offsetWidth === 0 ? swap(elem, cssShow, function () {
						return getWidthOrHeight(elem, name, extra);
					}) : getWidthOrHeight(elem, name, extra);
				}
			},

			set: function set(elem, value, extra) {
				var matches,
				    styles = extra &amp;&amp; getStyles(elem),
				    subtract = extra &amp;&amp; augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);

				// Convert to pixels if value adjustment is needed
				if (subtract &amp;&amp; (matches = rcssNum.exec(value)) &amp;&amp; (matches[3] || "px") !== "px") {

					elem.style[name] = value;
					value = jQuery.css(elem, name);
				}

				return setPositiveNumber(elem, value, subtract);
			}
		};
	});

	jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
		if (computed) {
			return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
				return elem.getBoundingClientRect().left;
			})) + "px";
		}
	});

	// Support: Android 2.3
	jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
		if (computed) {
			return swap(elem, { "display": "inline-block" }, curCSS, [elem, "marginRight"]);
		}
	});

	// These hooks are used by animate to expand properties
	jQuery.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function (prefix, suffix) {
		jQuery.cssHooks[prefix + suffix] = {
			expand: function expand(value) {
				var i = 0,
				    expanded = {},


				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [value];

				for (; i &lt; 4; i++) {
					expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
				}

				return expanded;
			}
		};

		if (!rmargin.test(prefix)) {
			jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
		}
	});

	jQuery.fn.extend({
		css: function css(name, value) {
			return access(this, function (elem, name, value) {
				var styles,
				    len,
				    map = {},
				    i = 0;

				if (jQuery.isArray(name)) {
					styles = getStyles(elem);
					len = name.length;

					for (; i &lt; len; i++) {
						map[name[i]] = jQuery.css(elem, name[i], false, styles);
					}

					return map;
				}

				return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
			}, name, value, arguments.length > 1);
		},
		show: function show() {
			return showHide(this, true);
		},
		hide: function hide() {
			return showHide(this);
		},
		toggle: function toggle(state) {
			if (typeof state === "boolean") {
				return state ? this.show() : this.hide();
			}

			return this.each(function () {
				if (isHidden(this)) {
					jQuery(this).show();
				} else {
					jQuery(this).hide();
				}
			});
		}
	});

	function Tween(elem, options, prop, end, easing) {
		return new Tween.prototype.init(elem, options, prop, end, easing);
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function init(elem, options, prop, end, easing, unit) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
		},
		cur: function cur() {
			var hooks = Tween.propHooks[this.prop];

			return hooks &amp;&amp; hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
		},
		run: function run(percent) {
			var eased,
			    hooks = Tween.propHooks[this.prop];

			if (this.options.duration) {
				this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
			} else {
				this.pos = eased = percent;
			}
			this.now = (this.end - this.start) * eased + this.start;

			if (this.options.step) {
				this.options.step.call(this.elem, this.now, this);
			}

			if (hooks &amp;&amp; hooks.set) {
				hooks.set(this);
			} else {
				Tween.propHooks._default.set(this);
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function get(tween) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null &amp;&amp; tween.elem.style[tween.prop] == null) {
					return tween.elem[tween.prop];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css(tween.elem, tween.prop, "");

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function set(tween) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if (jQuery.fx.step[tween.prop]) {
					jQuery.fx.step[tween.prop](tween);
				} else if (tween.elem.nodeType === 1 &amp;&amp; (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
					jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
				} else {
					tween.elem[tween.prop] = tween.now;
				}
			}
		}
	};

	// Support: IE9
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function set(tween) {
			if (tween.elem.nodeType &amp;&amp; tween.elem.parentNode) {
				tween.elem[tween.prop] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function linear(p) {
			return p;
		},
		swing: function swing(p) {
			return 0.5 - Math.cos(p * Math.PI) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back Compat &lt;1.8 extension point
	jQuery.fx.step = {};

	var fxNow,
	    timerId,
	    rfxtypes = /^(?:toggle|show|hide)$/,
	    rrun = /queueHooks$/;

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout(function () {
			fxNow = undefined;
		});
		return fxNow = jQuery.now();
	}

	// Generate parameters to create a standard animation
	function genFx(type, includeWidth) {
		var which,
		    i = 0,
		    attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for (; i &lt; 4; i += 2 - includeWidth) {
			which = cssExpand[i];
			attrs["margin" + which] = attrs["padding" + which] = type;
		}

		if (includeWidth) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween(value, prop, animation) {
		var tween,
		    collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
		    index = 0,
		    length = collection.length;
		for (; index &lt; length; index++) {
			if (tween = collection[index].call(animation, prop, value)) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter(elem, props, opts) {
		/* jshint validthis: true */
		var prop,
		    value,
		    toggle,
		    tween,
		    hooks,
		    oldfire,
		    display,
		    checkDisplay,
		    anim = this,
		    orig = {},
		    style = elem.style,
		    hidden = elem.nodeType &amp;&amp; isHidden(elem),
		    dataShow = dataPriv.get(elem, "fxshow");

		// Handle queue: false promises
		if (!opts.queue) {
			hooks = jQuery._queueHooks(elem, "fx");
			if (hooks.unqueued == null) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function () {
					if (!hooks.unqueued) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always(function () {

				// Ensure the complete handler is called before this completes
				anim.always(function () {
					hooks.unqueued--;
					if (!jQuery.queue(elem, "fx").length) {
						hooks.empty.fire();
					}
				});
			});
		}

		// Height/width overflow pass
		if (elem.nodeType === 1 &amp;&amp; ("height" in props || "width" in props)) {

			// Make sure that nothing sneaks out
			// Record all 3 overflow attributes because IE9-10 do not
			// change the overflow attribute when overflowX and
			// overflowY are set to the same value
			opts.overflow = [style.overflow, style.overflowX, style.overflowY];

			// Set display property to inline-block for height/width
			// animations on inline elements that are having width/height animated
			display = jQuery.css(elem, "display");

			// Test default display if display is currently "none"
			checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

			if (checkDisplay === "inline" &amp;&amp; jQuery.css(elem, "float") === "none") {
				style.display = "inline-block";
			}
		}

		if (opts.overflow) {
			style.overflow = "hidden";
			anim.always(function () {
				style.overflow = opts.overflow[0];
				style.overflowX = opts.overflow[1];
				style.overflowY = opts.overflow[2];
			});
		}

		// show/hide pass
		for (prop in props) {
			value = props[prop];
			if (rfxtypes.exec(value)) {
				delete props[prop];
				toggle = toggle || value === "toggle";
				if (value === (hidden ? "hide" : "show")) {

					// If there is dataShow left over from a stopped hide or show
					// and we are going to proceed with show, we should pretend to be hidden
					if (value === "show" &amp;&amp; dataShow &amp;&amp; dataShow[prop] !== undefined) {
						hidden = true;
					} else {
						continue;
					}
				}
				orig[prop] = dataShow &amp;&amp; dataShow[prop] || jQuery.style(elem, prop);

				// Any non-fx value stops us from restoring the original display value
			} else {
				display = undefined;
			}
		}

		if (!jQuery.isEmptyObject(orig)) {
			if (dataShow) {
				if ("hidden" in dataShow) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access(elem, "fxshow", {});
			}

			// Store state if its toggle - enables .stop().toggle() to "reverse"
			if (toggle) {
				dataShow.hidden = !hidden;
			}
			if (hidden) {
				jQuery(elem).show();
			} else {
				anim.done(function () {
					jQuery(elem).hide();
				});
			}
			anim.done(function () {
				var prop;

				dataPriv.remove(elem, "fxshow");
				for (prop in orig) {
					jQuery.style(elem, prop, orig[prop]);
				}
			});
			for (prop in orig) {
				tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

				if (!(prop in dataShow)) {
					dataShow[prop] = tween.start;
					if (hidden) {
						tween.end = tween.start;
						tween.start = prop === "width" || prop === "height" ? 1 : 0;
					}
				}
			}

			// If this is a noop like .hide().hide(), restore an overwritten display value
		} else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
			style.display = display;
		}
	}

	function propFilter(props, specialEasing) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for (index in props) {
			name = jQuery.camelCase(index);
			easing = specialEasing[name];
			value = props[index];
			if (jQuery.isArray(value)) {
				easing = value[1];
				value = props[index] = value[0];
			}

			if (index !== name) {
				props[name] = value;
				delete props[index];
			}

			hooks = jQuery.cssHooks[name];
			if (hooks &amp;&amp; "expand" in hooks) {
				value = hooks.expand(value);
				delete props[name];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for (index in value) {
					if (!(index in props)) {
						props[index] = value[index];
						specialEasing[index] = easing;
					}
				}
			} else {
				specialEasing[name] = easing;
			}
		}
	}

	function Animation(elem, properties, options) {
		var result,
		    stopped,
		    index = 0,
		    length = Animation.prefilters.length,
		    deferred = jQuery.Deferred().always(function () {

			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		    tick = function tick() {
			if (stopped) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
			    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),


			// Support: Android 2.3
			// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
			temp = remaining / animation.duration || 0,
			    percent = 1 - temp,
			    index = 0,
			    length = animation.tweens.length;

			for (; index &lt; length; index++) {
				animation.tweens[index].run(percent);
			}

			deferred.notifyWith(elem, [animation, percent, remaining]);

			if (percent &lt; 1 &amp;&amp; length) {
				return remaining;
			} else {
				deferred.resolveWith(elem, [animation]);
				return false;
			}
		},
		    animation = deferred.promise({
			elem: elem,
			props: jQuery.extend({}, properties),
			opts: jQuery.extend(true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function createTween(prop, end) {
				var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
				animation.tweens.push(tween);
				return tween;
			},
			stop: function stop(gotoEnd) {
				var index = 0,


				// If we are going to the end, we want to run all the tweens
				// otherwise we skip this part
				length = gotoEnd ? animation.tweens.length : 0;
				if (stopped) {
					return this;
				}
				stopped = true;
				for (; index &lt; length; index++) {
					animation.tweens[index].run(1);
				}

				// Resolve when we played the last frame; otherwise, reject
				if (gotoEnd) {
					deferred.notifyWith(elem, [animation, 1, 0]);
					deferred.resolveWith(elem, [animation, gotoEnd]);
				} else {
					deferred.rejectWith(elem, [animation, gotoEnd]);
				}
				return this;
			}
		}),
		    props = animation.props;

		propFilter(props, animation.opts.specialEasing);

		for (; index &lt; length; index++) {
			result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
			if (result) {
				if (jQuery.isFunction(result.stop)) {
					jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
				}
				return result;
			}
		}

		jQuery.map(props, createTween, animation);

		if (jQuery.isFunction(animation.opts.start)) {
			animation.opts.start.call(elem, animation);
		}

		jQuery.fx.timer(jQuery.extend(tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		}));

		// attach callbacks from options
		return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
	}

	jQuery.Animation = jQuery.extend(Animation, {
		tweeners: {
			"*": [function (prop, value) {
				var tween = this.createTween(prop, value);
				adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
				return tween;
			}]
		},

		tweener: function tweener(props, callback) {
			if (jQuery.isFunction(props)) {
				callback = props;
				props = ["*"];
			} else {
				props = props.match(rnotwhite);
			}

			var prop,
			    index = 0,
			    length = props.length;

			for (; index &lt; length; index++) {
				prop = props[index];
				Animation.tweeners[prop] = Animation.tweeners[prop] || [];
				Animation.tweeners[prop].unshift(callback);
			}
		},

		prefilters: [defaultPrefilter],

		prefilter: function prefilter(callback, prepend) {
			if (prepend) {
				Animation.prefilters.unshift(callback);
			} else {
				Animation.prefilters.push(callback);
			}
		}
	});

	jQuery.speed = function (speed, easing, fn) {
		var opt = speed &amp;&amp; (typeof speed === "undefined" ? "undefined" : _typeof(speed)) === "object" ? jQuery.extend({}, speed) : {
			complete: fn || !fn &amp;&amp; easing || jQuery.isFunction(speed) &amp;&amp; speed,
			duration: speed,
			easing: fn &amp;&amp; easing || easing &amp;&amp; !jQuery.isFunction(easing) &amp;&amp; easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

		// Normalize opt.queue - true/undefined/null -> "fx"
		if (opt.queue == null || opt.queue === true) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function () {
			if (jQuery.isFunction(opt.old)) {
				opt.old.call(this);
			}

			if (opt.queue) {
				jQuery.dequeue(this, opt.queue);
			}
		};

		return opt;
	};

	jQuery.fn.extend({
		fadeTo: function fadeTo(speed, to, easing, callback) {

			// Show any hidden elements after setting opacity to 0
			return this.filter(isHidden).css("opacity", 0).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback);
		},
		animate: function animate(prop, speed, easing, callback) {
			var empty = jQuery.isEmptyObject(prop),
			    optall = jQuery.speed(speed, easing, callback),
			    doAnimation = function doAnimation() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation(this, jQuery.extend({}, prop), optall);

				// Empty animations, or finishing resolves immediately
				if (empty || dataPriv.get(this, "finish")) {
					anim.stop(true);
				}
			};
			doAnimation.finish = doAnimation;

			return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
		},
		stop: function stop(type, clearQueue, gotoEnd) {
			var stopQueue = function stopQueue(hooks) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop(gotoEnd);
			};

			if (typeof type !== "string") {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if (clearQueue &amp;&amp; type !== false) {
				this.queue(type || "fx", []);
			}

			return this.each(function () {
				var dequeue = true,
				    index = type != null &amp;&amp; type + "queueHooks",
				    timers = jQuery.timers,
				    data = dataPriv.get(this);

				if (index) {
					if (data[index] &amp;&amp; data[index].stop) {
						stopQueue(data[index]);
					}
				} else {
					for (index in data) {
						if (data[index] &amp;&amp; data[index].stop &amp;&amp; rrun.test(index)) {
							stopQueue(data[index]);
						}
					}
				}

				for (index = timers.length; index--;) {
					if (timers[index].elem === this &amp;&amp; (type == null || timers[index].queue === type)) {

						timers[index].anim.stop(gotoEnd);
						dequeue = false;
						timers.splice(index, 1);
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if (dequeue || !gotoEnd) {
					jQuery.dequeue(this, type);
				}
			});
		},
		finish: function finish(type) {
			if (type !== false) {
				type = type || "fx";
			}
			return this.each(function () {
				var index,
				    data = dataPriv.get(this),
				    queue = data[type + "queue"],
				    hooks = data[type + "queueHooks"],
				    timers = jQuery.timers,
				    length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue(this, type, []);

				if (hooks &amp;&amp; hooks.stop) {
					hooks.stop.call(this, true);
				}

				// Look for any active animations, and finish them
				for (index = timers.length; index--;) {
					if (timers[index].elem === this &amp;&amp; timers[index].queue === type) {
						timers[index].anim.stop(true);
						timers.splice(index, 1);
					}
				}

				// Look for any animations in the old queue and finish them
				for (index = 0; index &lt; length; index++) {
					if (queue[index] &amp;&amp; queue[index].finish) {
						queue[index].finish.call(this);
					}
				}

				// Turn off finishing flag
				delete data.finish;
			});
		}
	});

	jQuery.each(["toggle", "show", "hide"], function (i, name) {
		var cssFn = jQuery.fn[name];
		jQuery.fn[name] = function (speed, easing, callback) {
			return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
		};
	});

	// Generate shortcuts for custom animations
	jQuery.each({
		slideDown: genFx("show"),
		slideUp: genFx("hide"),
		slideToggle: genFx("toggle"),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function (name, props) {
		jQuery.fn[name] = function (speed, easing, callback) {
			return this.animate(props, speed, easing, callback);
		};
	});

	jQuery.timers = [];
	jQuery.fx.tick = function () {
		var timer,
		    i = 0,
		    timers = jQuery.timers;

		fxNow = jQuery.now();

		for (; i &lt; timers.length; i++) {
			timer = timers[i];

			// Checks the timer has not already been removed
			if (!timer() &amp;&amp; timers[i] === timer) {
				timers.splice(i--, 1);
			}
		}

		if (!timers.length) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function (timer) {
		jQuery.timers.push(timer);
		if (timer()) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function () {
		if (!timerId) {
			timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
		}
	};

	jQuery.fx.stop = function () {
		window.clearInterval(timerId);

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};

	// Based off of the plugin by Clint Helfers, with permission.
	// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function (time, type) {
		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
		type = type || "fx";

		return this.queue(type, function (next, hooks) {
			var timeout = window.setTimeout(next, time);
			hooks.stop = function () {
				window.clearTimeout(timeout);
			};
		});
	};

	(function () {
		var input = document.createElement("input"),
		    select = document.createElement("select"),
		    opt = select.appendChild(document.createElement("option"));

		input.type = "checkbox";

		// Support: iOS&lt;=5.1, Android&lt;=4.2+
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE&lt;=11+
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: Android&lt;=2.3
		// Options inside disabled selects are incorrectly marked as disabled
		select.disabled = true;
		support.optDisabled = !opt.disabled;

		// Support: IE&lt;=11+
		// An input loses its value after becoming a radio
		input = document.createElement("input");
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	})();

	var boolHook,
	    attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend({
		attr: function attr(name, value) {
			return access(this, jQuery.attr, name, value, arguments.length > 1);
		},

		removeAttr: function removeAttr(name) {
			return this.each(function () {
				jQuery.removeAttr(this, name);
			});
		}
	});

	jQuery.extend({
		attr: function attr(elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if (typeof elem.getAttribute === "undefined") {
				return jQuery.prop(elem, name, value);
			}

			// All attributes are lowercase
			// Grab necessary hook if one is defined
			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
				name = name.toLowerCase();
				hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
			}

			if (value !== undefined) {
				if (value === null) {
					jQuery.removeAttr(elem, name);
					return;
				}

				if (hooks &amp;&amp; "set" in hooks &amp;&amp; (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				elem.setAttribute(name, value + "");
				return value;
			}

			if (hooks &amp;&amp; "get" in hooks &amp;&amp; (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			ret = jQuery.find.attr(elem, name);

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function set(elem, value) {
					if (!support.radioValue &amp;&amp; value === "radio" &amp;&amp; jQuery.nodeName(elem, "input")) {
						var val = elem.value;
						elem.setAttribute("type", value);
						if (val) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function removeAttr(elem, value) {
			var name,
			    propName,
			    i = 0,
			    attrNames = value &amp;&amp; value.match(rnotwhite);

			if (attrNames &amp;&amp; elem.nodeType === 1) {
				while (name = attrNames[i++]) {
					propName = jQuery.propFix[name] || name;

					// Boolean attributes get special treatment (#10870)
					if (jQuery.expr.match.bool.test(name)) {

						// Set corresponding property to false
						elem[propName] = false;
					}

					elem.removeAttribute(name);
				}
			}
		}
	});

	// Hooks for boolean attributes
	boolHook = {
		set: function set(elem, value, name) {
			if (value === false) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr(elem, name);
			} else {
				elem.setAttribute(name, name);
			}
			return name;
		}
	};
	jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
		var getter = attrHandle[name] || jQuery.find.attr;

		attrHandle[name] = function (elem, name, isXML) {
			var ret, handle;
			if (!isXML) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[name];
				attrHandle[name] = ret;
				ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
				attrHandle[name] = handle;
			}
			return ret;
		};
	});

	var rfocusable = /^(?:input|select|textarea|button)$/i,
	    rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend({
		prop: function prop(name, value) {
			return access(this, jQuery.prop, name, value, arguments.length > 1);
		},

		removeProp: function removeProp(name) {
			return this.each(function () {
				delete this[jQuery.propFix[name] || name];
			});
		}
	});

	jQuery.extend({
		prop: function prop(elem, name, value) {
			var ret,
			    hooks,
			    nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if (nType === 3 || nType === 8 || nType === 2) {
				return;
			}

			if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

				// Fix name and attach hooks
				name = jQuery.propFix[name] || name;
				hooks = jQuery.propHooks[name];
			}

			if (value !== undefined) {
				if (hooks &amp;&amp; "set" in hooks &amp;&amp; (ret = hooks.set(elem, value, name)) !== undefined) {
					return ret;
				}

				return elem[name] = value;
			}

			if (hooks &amp;&amp; "get" in hooks &amp;&amp; (ret = hooks.get(elem, name)) !== null) {
				return ret;
			}

			return elem[name];
		},

		propHooks: {
			tabIndex: {
				get: function get(elem) {

					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr(elem, "tabindex");

					return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) &amp;&amp; elem.href ? 0 : -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	});

	// Support: IE &lt;=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	if (!support.optSelected) {
		jQuery.propHooks.selected = {
			get: function get(elem) {
				var parent = elem.parentNode;
				if (parent &amp;&amp; parent.parentNode) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function set(elem) {
				var parent = elem.parentNode;
				if (parent) {
					parent.selectedIndex;

					if (parent.parentNode) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
		jQuery.propFix[this.toLowerCase()] = this;
	});

	var rclass = /[\t\r\n\f]/g;

	function getClass(elem) {
		return elem.getAttribute &amp;&amp; elem.getAttribute("class") || "";
	}

	jQuery.fn.extend({
		addClass: function addClass(value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).addClass(value.call(this, j, getClass(this)));
				});
			}

			if (typeof value === "string" &amp;&amp; value) {
				classes = value.match(rnotwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);
					cur = elem.nodeType === 1 &amp;&amp; (" " + curValue + " ").replace(rclass, " ");

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {
							if (cur.indexOf(" " + clazz + " ") &lt; 0) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		removeClass: function removeClass(value) {
			var classes,
			    elem,
			    cur,
			    curValue,
			    clazz,
			    j,
			    finalValue,
			    i = 0;

			if (jQuery.isFunction(value)) {
				return this.each(function (j) {
					jQuery(this).removeClass(value.call(this, j, getClass(this)));
				});
			}

			if (!arguments.length) {
				return this.attr("class", "");
			}

			if (typeof value === "string" &amp;&amp; value) {
				classes = value.match(rnotwhite) || [];

				while (elem = this[i++]) {
					curValue = getClass(elem);

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 &amp;&amp; (" " + curValue + " ").replace(rclass, " ");

					if (cur) {
						j = 0;
						while (clazz = classes[j++]) {

							// Remove *all* instances
							while (cur.indexOf(" " + clazz + " ") > -1) {
								cur = cur.replace(" " + clazz + " ", " ");
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = jQuery.trim(cur);
						if (curValue !== finalValue) {
							elem.setAttribute("class", finalValue);
						}
					}
				}
			}

			return this;
		},

		toggleClass: function toggleClass(value, stateVal) {
			var type = typeof value === "undefined" ? "undefined" : _typeof(value);

			if (typeof stateVal === "boolean" &amp;&amp; type === "string") {
				return stateVal ? this.addClass(value) : this.removeClass(value);
			}

			if (jQuery.isFunction(value)) {
				return this.each(function (i) {
					jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
				});
			}

			return this.each(function () {
				var className, i, self, classNames;

				if (type === "string") {

					// Toggle individual class names
					i = 0;
					self = jQuery(this);
					classNames = value.match(rnotwhite) || [];

					while (className = classNames[i++]) {

						// Check each className given, space separated list
						if (self.hasClass(className)) {
							self.removeClass(className);
						} else {
							self.addClass(className);
						}
					}

					// Toggle whole class name
				} else if (value === undefined || type === "boolean") {
					className = getClass(this);
					if (className) {

						// Store className if set
						dataPriv.set(this, "__className__", className);
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if (this.setAttribute) {
						this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
					}
				}
			});
		},

		hasClass: function hasClass(selector) {
			var className,
			    elem,
			    i = 0;

			className = " " + selector + " ";
			while (elem = this[i++]) {
				if (elem.nodeType === 1 &amp;&amp; (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
					return true;
				}
			}

			return false;
		}
	});

	var rreturn = /\r/g,
	    rspaces = /[\x20\t\r\n\f]+/g;

	jQuery.fn.extend({
		val: function val(value) {
			var hooks,
			    ret,
			    isFunction,
			    elem = this[0];

			if (!arguments.length) {
				if (elem) {
					hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

					if (hooks &amp;&amp; "get" in hooks &amp;&amp; (ret = hooks.get(elem, "value")) !== undefined) {
						return ret;
					}

					ret = elem.value;

					return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace(rreturn, "") :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction(value);

			return this.each(function (i) {
				var val;

				if (this.nodeType !== 1) {
					return;
				}

				if (isFunction) {
					val = value.call(this, i, jQuery(this).val());
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if (val == null) {
					val = "";
				} else if (typeof val === "number") {
					val += "";
				} else if (jQuery.isArray(val)) {
					val = jQuery.map(val, function (value) {
						return value == null ? "" : value + "";
					});
				}

				hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

				// If set returns undefined, fall back to normal setting
				if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
					this.value = val;
				}
			});
		}
	});

	jQuery.extend({
		valHooks: {
			option: {
				get: function get(elem) {

					var val = jQuery.find.attr(elem, "value");
					return val != null ? val :

					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
				}
			},
			select: {
				get: function get(elem) {
					var value,
					    option,
					    options = elem.options,
					    index = elem.selectedIndex,
					    one = elem.type === "select-one" || index &lt; 0,
					    values = one ? null : [],
					    max = one ? index + 1 : options.length,
					    i = index &lt; 0 ? max : one ? index : 0;

					// Loop through all the selected options
					for (; i &lt; max; i++) {
						option = options[i];

						// IE8-9 doesn't update selected after form reset (#2551)
						if ((option.selected || i === index) &amp;&amp; (

						// Don't return options that are disabled or in a disabled optgroup
						support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &amp;&amp; (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

							// Get the specific value for the option
							value = jQuery(option).val();

							// We don't need an array for one selects
							if (one) {
								return value;
							}

							// Multi-Selects return an array
							values.push(value);
						}
					}

					return values;
				},

				set: function set(elem, value) {
					var optionSet,
					    option,
					    options = elem.options,
					    values = jQuery.makeArray(value),
					    i = options.length;

					while (i--) {
						option = options[i];
						if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if (!optionSet) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	});

	// Radios and checkboxes getter/setter
	jQuery.each(["radio", "checkbox"], function () {
		jQuery.valHooks[this] = {
			set: function set(elem, value) {
				if (jQuery.isArray(value)) {
					return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
				}
			}
		};
		if (!support.checkOn) {
			jQuery.valHooks[this].get = function (elem) {
				return elem.getAttribute("value") === null ? "on" : elem.value;
			};
		}
	});

	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend(jQuery.event, {

		trigger: function trigger(event, data, elem, onlyHandlers) {

			var i,
			    cur,
			    tmp,
			    bubbleType,
			    ontype,
			    handle,
			    special,
			    eventPath = [elem || document],
			    type = hasOwn.call(event, "type") ? event.type : event,
			    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if (elem.nodeType === 3 || elem.nodeType === 8) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if (rfocusMorph.test(type + jQuery.event.triggered)) {
				return;
			}

			if (type.indexOf(".") > -1) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split(".");
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf(":") &lt; 0 &amp;&amp; "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[jQuery.expando] ? event : new jQuery.Event(type, (typeof event === "undefined" ? "undefined" : _typeof(event)) === "object" &amp;&amp; event);

			// Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join(".");
			event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if (!event.target) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ? [event] : jQuery.makeArray(data, [event]);

			// Allow special events to draw outside the lines
			special = jQuery.event.special[type] || {};
			if (!onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply(elem, data) === false) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if (!onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow(elem)) {

				bubbleType = special.delegateType || type;
				if (!rfocusMorph.test(bubbleType + type)) {
					cur = cur.parentNode;
				}
				for (; cur; cur = cur.parentNode) {
					eventPath.push(cur);
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if (tmp === (elem.ownerDocument || document)) {
					eventPath.push(tmp.defaultView || tmp.parentWindow || window);
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ((cur = eventPath[i++]) &amp;&amp; !event.isPropagationStopped()) {

				event.type = i > 1 ? bubbleType : special.bindType || type;

				// jQuery handler
				handle = (dataPriv.get(cur, "events") || {})[event.type] &amp;&amp; dataPriv.get(cur, "handle");
				if (handle) {
					handle.apply(cur, data);
				}

				// Native handler
				handle = ontype &amp;&amp; cur[ontype];
				if (handle &amp;&amp; handle.apply &amp;&amp; acceptData(cur)) {
					event.result = handle.apply(cur, data);
					if (event.result === false) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if (!onlyHandlers &amp;&amp; !event.isDefaultPrevented()) {

				if ((!special._default || special._default.apply(eventPath.pop(), data) === false) &amp;&amp; acceptData(elem)) {

					// Call a native DOM method on the target with the same name name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if (ontype &amp;&amp; jQuery.isFunction(elem[type]) &amp;&amp; !jQuery.isWindow(elem)) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ontype];

						if (tmp) {
							elem[ontype] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[type]();
						jQuery.event.triggered = undefined;

						if (tmp) {
							elem[ontype] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function simulate(type, elem, event) {
			var e = jQuery.extend(new jQuery.Event(), event, {
				type: type,
				isSimulated: true
			});

			jQuery.event.trigger(e, null, elem);
		}

	});

	jQuery.fn.extend({

		trigger: function trigger(type, data) {
			return this.each(function () {
				jQuery.event.trigger(type, data, this);
			});
		},
		triggerHandler: function triggerHandler(type, data) {
			var elem = this[0];
			if (elem) {
				return jQuery.event.trigger(type, data, elem, true);
			}
		}
	});

	jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

		// Handle event binding
		jQuery.fn[name] = function (data, fn) {
			return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
		};
	});

	jQuery.fn.extend({
		hover: function hover(fnOver, fnOut) {
			return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
		}
	});

	support.focusin = "onfocusin" in window;

	// Support: Firefox
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome, Safari
	// focus(in | out) events fire after focus &amp; blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
	if (!support.focusin) {
		jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function handler(event) {
				jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
			};

			jQuery.event.special[fix] = {
				setup: function setup() {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix);

					if (!attaches) {
						doc.addEventListener(orig, handler, true);
					}
					dataPriv.access(doc, fix, (attaches || 0) + 1);
				},
				teardown: function teardown() {
					var doc = this.ownerDocument || this,
					    attaches = dataPriv.access(doc, fix) - 1;

					if (!attaches) {
						doc.removeEventListener(orig, handler, true);
						dataPriv.remove(doc, fix);
					} else {
						dataPriv.access(doc, fix, attaches);
					}
				}
			};
		});
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = /\?/;

	// Support: Android 2.3
	// Workaround failure to string-cast null input
	jQuery.parseJSON = function (data) {
		return JSON.parse(data + "");
	};

	// Cross-browser xml parsing
	jQuery.parseXML = function (data) {
		var xml;
		if (!data || typeof data !== "string") {
			return null;
		}

		// Support: IE9
		try {
			xml = new window.DOMParser().parseFromString(data, "text/xml");
		} catch (e) {
			xml = undefined;
		}

		if (!xml || xml.getElementsByTagName("parsererror").length) {
			jQuery.error("Invalid XML: " + data);
		}
		return xml;
	};

	var rhash = /#.*$/,
	    rts = /([?&amp;])_=[^&amp;]*/,
	    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,


	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	    rnoContent = /^(?:GET|HEAD)$/,
	    rprotocol = /^\/\//,


	/* Prefilters
  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  * 2) These are called:
  *    - BEFORE asking for a transport
  *    - AFTER param serialization (s.data is a string if s.processData is true)
  * 3) key is the dataType
  * 4) the catchall symbol "*" can be used
  * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  */
	prefilters = {},


	/* Transports bindings
  * 1) key is the dataType
  * 2) the catchall symbol "*" can be used
  * 3) selection will start with transport dataType and THEN go to "*" if needed
  */
	transports = {},


	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*"),


	// Anchor tag for parsing the document origin
	originAnchor = document.createElement("a");
	originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports(structure) {

		// dataTypeExpression is optional and defaults to "*"
		return function (dataTypeExpression, func) {

			if (typeof dataTypeExpression !== "string") {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
			    i = 0,
			    dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

			if (jQuery.isFunction(func)) {

				// For each dataType in the dataTypeExpression
				while (dataType = dataTypes[i++]) {

					// Prepend if requested
					if (dataType[0] === "+") {
						dataType = dataType.slice(1) || "*";
						(structure[dataType] = structure[dataType] || []).unshift(func);

						// Otherwise append
					} else {
						(structure[dataType] = structure[dataType] || []).push(func);
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

		var inspected = {},
		    seekingTransport = structure === transports;

		function inspect(dataType) {
			var selected;
			inspected[dataType] = true;
			jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
				var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
				if (typeof dataTypeOrTransport === "string" &amp;&amp; !seekingTransport &amp;&amp; !inspected[dataTypeOrTransport]) {

					options.dataTypes.unshift(dataTypeOrTransport);
					inspect(dataTypeOrTransport);
					return false;
				} else if (seekingTransport) {
					return !(selected = dataTypeOrTransport);
				}
			});
			return selected;
		}

		return inspect(options.dataTypes[0]) || !inspected["*"] &amp;&amp; inspect("*");
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend(target, src) {
		var key,
		    deep,
		    flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for (key in src) {
			if (src[key] !== undefined) {
				(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
			}
		}
		if (deep) {
			jQuery.extend(true, target, deep);
		}

		return target;
	}

	/* Handles responses to an ajax request:
  * - finds the right dataType (mediates between content-type and expected dataType)
  * - returns the corresponding response
  */
	function ajaxHandleResponses(s, jqXHR, responses) {

		var ct,
		    type,
		    finalDataType,
		    firstDataType,
		    contents = s.contents,
		    dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while (dataTypes[0] === "*") {
			dataTypes.shift();
			if (ct === undefined) {
				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
			}
		}

		// Check if we're dealing with a known content-type
		if (ct) {
			for (type in contents) {
				if (contents[type] &amp;&amp; contents[type].test(ct)) {
					dataTypes.unshift(type);
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if (dataTypes[0] in responses) {
			finalDataType = dataTypes[0];
		} else {

			// Try convertible dataTypes
			for (type in responses) {
				if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
					finalDataType = type;
					break;
				}
				if (!firstDataType) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if (finalDataType) {
			if (finalDataType !== dataTypes[0]) {
				dataTypes.unshift(finalDataType);
			}
			return responses[finalDataType];
		}
	}

	/* Chain conversions given the request and the original response
  * Also sets the responseXXX fields on the jqXHR instance
  */
	function ajaxConvert(s, response, jqXHR, isSuccess) {
		var conv2,
		    current,
		    conv,
		    tmp,
		    prev,
		    converters = {},


		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if (dataTypes[1]) {
			for (conv in s.converters) {
				converters[conv.toLowerCase()] = s.converters[conv];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while (current) {

			if (s.responseFields[current]) {
				jqXHR[s.responseFields[current]] = response;
			}

			// Apply the dataFilter if provided
			if (!prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter) {
				response = s.dataFilter(response, s.dataType);
			}

			prev = current;
			current = dataTypes.shift();

			if (current) {

				// There's only work to do if current dataType is non-auto
				if (current === "*") {

					current = prev;

					// Convert response if prev dataType is non-auto and differs from current
				} else if (prev !== "*" &amp;&amp; prev !== current) {

					// Seek a direct converter
					conv = converters[prev + " " + current] || converters["* " + current];

					// If none found, seek a pair
					if (!conv) {
						for (conv2 in converters) {

							// If conv2 outputs current
							tmp = conv2.split(" ");
							if (tmp[1] === current) {

								// If prev can be converted to accepted input
								conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
								if (conv) {

									// Condense equivalence converters
									if (conv === true) {
										conv = converters[conv2];

										// Otherwise, insert the intermediate dataType
									} else if (converters[conv2] !== true) {
										current = tmp[0];
										dataTypes.unshift(tmp[1]);
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if (conv !== true) {

						// Unless errors are allowed to bubble, catch and return them
						if (conv &amp;&amp; s.throws) {
							response = conv(response);
						} else {
							try {
								response = conv(response);
							} catch (e) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend({

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test(location.protocol),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			/*
   timeout: 0,
   data: null,
   dataType: null,
   username: null,
   password: null,
   cache: null,
   throws: false,
   traditional: false,
   headers: {},
   */

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": jQuery.parseJSON,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function ajaxSetup(target, settings) {
			return settings ?

			// Building a settings object
			ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

			// Extending ajaxSettings
			ajaxExtend(jQuery.ajaxSettings, target);
		},

		ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
		ajaxTransport: addToPrefiltersOrTransports(transports),

		// Main method
		ajax: function ajax(url, options) {

			// If url is an object, simulate pre-1.5 signature
			if ((typeof url === "undefined" ? "undefined" : _typeof(url)) === "object") {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,


			// URL without anti-cache param
			cacheURL,


			// Response headers
			responseHeadersString,
			    responseHeaders,


			// timeout handle
			timeoutTimer,


			// Url cleanup var
			urlAnchor,


			// To know if global events are to be dispatched
			fireGlobals,


			// Loop variable
			i,


			// Create the final options object
			s = jQuery.ajaxSetup({}, options),


			// Callbacks context
			callbackContext = s.context || s,


			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &amp;&amp; (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,


			// Deferreds
			deferred = jQuery.Deferred(),
			    completeDeferred = jQuery.Callbacks("once memory"),


			// Status-dependent callbacks
			_statusCode = s.statusCode || {},


			// Headers (they are sent all at once)
			requestHeaders = {},
			    requestHeadersNames = {},


			// The jqXHR state
			state = 0,


			// Default abort message
			strAbort = "canceled",


			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function getResponseHeader(key) {
					var match;
					if (state === 2) {
						if (!responseHeaders) {
							responseHeaders = {};
							while (match = rheaders.exec(responseHeadersString)) {
								responseHeaders[match[1].toLowerCase()] = match[2];
							}
						}
						match = responseHeaders[key.toLowerCase()];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function getAllResponseHeaders() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function setRequestHeader(name, value) {
					var lname = name.toLowerCase();
					if (!state) {
						name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
						requestHeaders[name] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function overrideMimeType(type) {
					if (!state) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function statusCode(map) {
					var code;
					if (map) {
						if (state &lt; 2) {
							for (code in map) {

								// Lazy-add the new callback in a way that preserves old ones
								_statusCode[code] = [_statusCode[code], map[code]];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always(map[jqXHR.status]);
						}
					}
					return this;
				},

				// Cancel the request
				abort: function abort(statusText) {
					var finalText = statusText || strAbort;
					if (transport) {
						transport.abort(finalText);
					}
					done(0, finalText);
					return this;
				}
			};

			// Attach deferreds
			deferred.promise(jqXHR).complete = completeDeferred.add;
			jqXHR.success = jqXHR.done;
			jqXHR.error = jqXHR.fail;

			// Remove hash character (#7531: and string promotion)
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if (s.crossDomain == null) {
				urlAnchor = document.createElement("a");

				// Support: IE8-11+
				// IE throws exception if url is malformed, e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE8-11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
				} catch (e) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if (s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== "string") {
				s.data = jQuery.param(s.data, s.traditional);
			}

			// Apply prefilters
			inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

			// If request was aborted inside a prefilter, stop there
			if (state === 2) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event &amp;&amp; s.global;

			// Watch for a new set of requests
			if (fireGlobals &amp;&amp; jQuery.active++ === 0) {
				jQuery.event.trigger("ajaxStart");
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test(s.type);

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			cacheURL = s.url;

			// More options handling for requests with no content
			if (!s.hasContent) {

				// If data is available, append data to url
				if (s.data) {
					cacheURL = s.url += (rquery.test(cacheURL) ? "&amp;" : "?") + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add anti-cache in url if needed
				if (s.cache === false) {
					s.url = rts.test(cacheURL) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace(rts, "$1_=" + nonce++) :

					// Otherwise add one to the end
					cacheURL + (rquery.test(cacheURL) ? "&amp;" : "?") + "_=" + nonce++;
				}
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if (s.ifModified) {
				if (jQuery.lastModified[cacheURL]) {
					jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
				}
				if (jQuery.etag[cacheURL]) {
					jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
				}
			}

			// Set the correct header, if data is being sent
			if (s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType) {
				jqXHR.setRequestHeader("Content-Type", s.contentType);
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader("Accept", s.dataTypes[0] &amp;&amp; s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

			// Check for headers option
			for (i in s.headers) {
				jqXHR.setRequestHeader(i, s.headers[i]);
			}

			// Allow custom headers/mimetypes and early abort
			if (s.beforeSend &amp;&amp; (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			for (i in { success: 1, error: 1, complete: 1 }) {
				jqXHR[i](s[i]);
			}

			// Get transport
			transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

			// If no transport, we auto-abort
			if (!transport) {
				done(-1, "No Transport");
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if (fireGlobals) {
					globalEventContext.trigger("ajaxSend", [jqXHR, s]);
				}

				// If request was aborted inside ajaxSend, stop there
				if (state === 2) {
					return jqXHR;
				}

				// Timeout
				if (s.async &amp;&amp; s.timeout > 0) {
					timeoutTimer = window.setTimeout(function () {
						jqXHR.abort("timeout");
					}, s.timeout);
				}

				try {
					state = 1;
					transport.send(requestHeaders, done);
				} catch (e) {

					// Propagate exception as error if not done
					if (state &lt; 2) {
						done(-1, e);

						// Simply rethrow otherwise
					} else {
						throw e;
					}
				}
			}

			// Callback for when everything is done
			function done(status, nativeStatusText, responses, headers) {
				var isSuccess,
				    success,
				    error,
				    response,
				    modified,
				    statusText = nativeStatusText;

				// Called once
				if (state === 2) {
					return;
				}

				// State is "done" now
				state = 2;

				// Clear timeout if it exists
				if (timeoutTimer) {
					window.clearTimeout(timeoutTimer);
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 &amp;&amp; status &lt; 300 || status === 304;

				// Get response data
				if (responses) {
					response = ajaxHandleResponses(s, jqXHR, responses);
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert(s, response, jqXHR, isSuccess);

				// If successful, handle type chaining
				if (isSuccess) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if (s.ifModified) {
						modified = jqXHR.getResponseHeader("Last-Modified");
						if (modified) {
							jQuery.lastModified[cacheURL] = modified;
						}
						modified = jqXHR.getResponseHeader("etag");
						if (modified) {
							jQuery.etag[cacheURL] = modified;
						}
					}

					// if no content
					if (status === 204 || s.type === "HEAD") {
						statusText = "nocontent";

						// if not modified
					} else if (status === 304) {
						statusText = "notmodified";

						// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if (status || !statusText) {
						statusText = "error";
						if (status &lt; 0) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = (nativeStatusText || statusText) + "";

				// Success/Error
				if (isSuccess) {
					deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
				} else {
					deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
				}

				// Status-dependent callbacks
				jqXHR.statusCode(_statusCode);
				_statusCode = undefined;

				if (fireGlobals) {
					globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
				}

				// Complete
				completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

				if (fireGlobals) {
					globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

					// Handle the global AJAX counter
					if (! --jQuery.active) {
						jQuery.event.trigger("ajaxStop");
					}
				}
			}

			return jqXHR;
		},

		getJSON: function getJSON(url, data, callback) {
			return jQuery.get(url, data, callback, "json");
		},

		getScript: function getScript(url, callback) {
			return jQuery.get(url, undefined, callback, "script");
		}
	});

	jQuery.each(["get", "post"], function (i, method) {
		jQuery[method] = function (url, data, callback, type) {

			// Shift arguments if data argument was omitted
			if (jQuery.isFunction(data)) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax(jQuery.extend({
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject(url) &amp;&amp; url));
		};
	});

	jQuery._evalUrl = function (url) {
		return jQuery.ajax({
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	};

	jQuery.fn.extend({
		wrapAll: function wrapAll(html) {
			var wrap;

			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapAll(html.call(this, i));
				});
			}

			if (this[0]) {

				// The elements to wrap the target around
				wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

				if (this[0].parentNode) {
					wrap.insertBefore(this[0]);
				}

				wrap.map(function () {
					var elem = this;

					while (elem.firstElementChild) {
						elem = elem.firstElementChild;
					}

					return elem;
				}).append(this);
			}

			return this;
		},

		wrapInner: function wrapInner(html) {
			if (jQuery.isFunction(html)) {
				return this.each(function (i) {
					jQuery(this).wrapInner(html.call(this, i));
				});
			}

			return this.each(function () {
				var self = jQuery(this),
				    contents = self.contents();

				if (contents.length) {
					contents.wrapAll(html);
				} else {
					self.append(html);
				}
			});
		},

		wrap: function wrap(html) {
			var isFunction = jQuery.isFunction(html);

			return this.each(function (i) {
				jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
			});
		},

		unwrap: function unwrap() {
			return this.parent().each(function () {
				if (!jQuery.nodeName(this, "body")) {
					jQuery(this).replaceWith(this.childNodes);
				}
			}).end();
		}
	});

	jQuery.expr.filters.hidden = function (elem) {
		return !jQuery.expr.filters.visible(elem);
	};
	jQuery.expr.filters.visible = function (elem) {

		// Support: Opera &lt;= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		// Use OR instead of AND as the element is not visible if either is true
		// See tickets #10406 and #13132
		return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
	};

	var r20 = /%20/g,
	    rbracket = /\[\]$/,
	    rCRLF = /\r?\n/g,
	    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	    rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams(prefix, obj, traditional, add) {
		var name;

		if (jQuery.isArray(obj)) {

			// Serialize array item.
			jQuery.each(obj, function (i, v) {
				if (traditional || rbracket.test(prefix)) {

					// Treat each array item as a scalar.
					add(prefix, v);
				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(prefix + "[" + ((typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" &amp;&amp; v != null ? i : "") + "]", v, traditional, add);
				}
			});
		} else if (!traditional &amp;&amp; jQuery.type(obj) === "object") {

			// Serialize object item.
			for (name in obj) {
				buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
			}
		} else {

			// Serialize scalar item.
			add(prefix, obj);
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function (a, traditional) {
		var prefix,
		    s = [],
		    add = function add(key, value) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
			s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
		};

		// Set traditional to true for jQuery &lt;= 1.3.2 behavior.
		if (traditional === undefined) {
			traditional = jQuery.ajaxSettings &amp;&amp; jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if (jQuery.isArray(a) || a.jquery &amp;&amp; !jQuery.isPlainObject(a)) {

			// Serialize the form elements
			jQuery.each(a, function () {
				add(this.name, this.value);
			});
		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for (prefix in a) {
				buildParams(prefix, a[prefix], traditional, add);
			}
		}

		// Return the resulting serialization
		return s.join("&amp;").replace(r20, "+");
	};

	jQuery.fn.extend({
		serialize: function serialize() {
			return jQuery.param(this.serializeArray());
		},
		serializeArray: function serializeArray() {
			return this.map(function () {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop(this, "elements");
				return elements ? jQuery.makeArray(elements) : this;
			}).filter(function () {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name &amp;&amp; !jQuery(this).is(":disabled") &amp;&amp; rsubmittable.test(this.nodeName) &amp;&amp; !rsubmitterTypes.test(type) &amp;&amp; (this.checked || !rcheckableType.test(type));
			}).map(function (i, elem) {
				var val = jQuery(this).val();

				return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
					return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
				}) : { name: elem.name, value: val.replace(rCRLF, "\r\n") };
			}).get();
		}
	});

	jQuery.ajaxSettings.xhr = function () {
		try {
			return new window.XMLHttpRequest();
		} catch (e) {}
	};

	var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	    xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported &amp;&amp; "withCredentials" in xhrSupported;
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport(function (options) {
		var _callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if (support.cors || xhrSupported &amp;&amp; !options.crossDomain) {
			return {
				send: function send(headers, complete) {
					var i,
					    xhr = options.xhr();

					xhr.open(options.type, options.url, options.async, options.username, options.password);

					// Apply custom fields if provided
					if (options.xhrFields) {
						for (i in options.xhrFields) {
							xhr[i] = options.xhrFields[i];
						}
					}

					// Override mime type if needed
					if (options.mimeType &amp;&amp; xhr.overrideMimeType) {
						xhr.overrideMimeType(options.mimeType);
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if (!options.crossDomain &amp;&amp; !headers["X-Requested-With"]) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for (i in headers) {
						xhr.setRequestHeader(i, headers[i]);
					}

					// Callback
					_callback = function callback(type) {
						return function () {
							if (_callback) {
								_callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if (type === "abort") {
									xhr.abort();
								} else if (type === "error") {

									// Support: IE9
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if (typeof xhr.status !== "number") {
										complete(0, "error");
									} else {
										complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status, xhr.statusText);
									}
								} else {
									complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,

									// Support: IE9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									(xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
								}
							}
						};
					};

					// Listen to events
					xhr.onload = _callback();
					errorCallback = xhr.onerror = _callback("error");

					// Support: IE9
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if (xhr.onabort !== undefined) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function () {

							// Check readyState before timeout as it changes
							if (xhr.readyState === 4) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout(function () {
									if (_callback) {
										errorCallback();
									}
								});
							}
						};
					}

					// Create the abort callback
					_callback = _callback("abort");

					try {

						// Do send the request (this may raise an exception)
						xhr.send(options.hasContent &amp;&amp; options.data || null);
					} catch (e) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if (_callback) {
							throw e;
						}
					}
				},

				abort: function abort() {
					if (_callback) {
						_callback();
					}
				}
			};
		}
	});

	// Install script dataType
	jQuery.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function textScript(text) {
				jQuery.globalEval(text);
				return text;
			}
		}
	});

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter("script", function (s) {
		if (s.cache === undefined) {
			s.cache = false;
		}
		if (s.crossDomain) {
			s.type = "GET";
		}
	});

	// Bind script tag hack transport
	jQuery.ajaxTransport("script", function (s) {

		// This transport only deals with cross domain requests
		if (s.crossDomain) {
			var script, _callback2;
			return {
				send: function send(_, complete) {
					script = jQuery("&lt;script>").prop({
						charset: s.scriptCharset,
						src: s.url
					}).on("load error", _callback2 = function callback(evt) {
						script.remove();
						_callback2 = null;
						if (evt) {
							complete(evt.type === "error" ? 404 : 200, evt.type);
						}
					});

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild(script[0]);
				},
				abort: function abort() {
					if (_callback2) {
						_callback2();
					}
				}
			};
		}
	});

	var oldCallbacks = [],
	    rjsonp = /(=)\?(?=&amp;|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function jsonpCallback() {
			var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
			this[callback] = true;
			return callback;
		}
	});

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

		var callbackName,
		    overwritten,
		    responseContainer,
		    jsonProp = s.jsonp !== false &amp;&amp; (rjsonp.test(s.url) ? "url" : typeof s.data === "string" &amp;&amp; (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 &amp;&amp; rjsonp.test(s.data) &amp;&amp; "data");

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if (jsonProp || s.dataTypes[0] === "jsonp") {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

			// Insert callback into url or form data
			if (jsonProp) {
				s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
			} else if (s.jsonp !== false) {
				s.url += (rquery.test(s.url) ? "&amp;" : "?") + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters["script json"] = function () {
				if (!responseContainer) {
					jQuery.error(callbackName + " was not called");
				}
				return responseContainer[0];
			};

			// Force json dataType
			s.dataTypes[0] = "json";

			// Install callback
			overwritten = window[callbackName];
			window[callbackName] = function () {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always(function () {

				// If previous value didn't exist - remove it
				if (overwritten === undefined) {
					jQuery(window).removeProp(callbackName);

					// Otherwise restore preexisting value
				} else {
					window[callbackName] = overwritten;
				}

				// Save back as free
				if (s[callbackName]) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push(callbackName);
				}

				// Call if it was a function and we have a response
				if (responseContainer &amp;&amp; jQuery.isFunction(overwritten)) {
					overwritten(responseContainer[0]);
				}

				responseContainer = overwritten = undefined;
			});

			// Delegate to script
			return "script";
		}
	});

	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function (data, context, keepScripts) {
		if (!data || typeof data !== "string") {
			return null;
		}
		if (typeof context === "boolean") {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec(data),
		    scripts = !keepScripts &amp;&amp; [];

		// Single tag
		if (parsed) {
			return [context.createElement(parsed[1])];
		}

		parsed = buildFragment([data], context, scripts);

		if (scripts &amp;&amp; scripts.length) {
			jQuery(scripts).remove();
		}

		return jQuery.merge([], parsed.childNodes);
	};

	// Keep a copy of the old load method
	var _load = jQuery.fn.load;

	/**
  * Load a url into a page
  */
	jQuery.fn.load = function (url, params, callback) {
		if (typeof url !== "string" &amp;&amp; _load) {
			return _load.apply(this, arguments);
		}

		var selector,
		    type,
		    response,
		    self = this,
		    off = url.indexOf(" ");

		if (off > -1) {
			selector = jQuery.trim(url.slice(off));
			url = url.slice(0, off);
		}

		// If it's a function
		if (jQuery.isFunction(params)) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

			// Otherwise, build a param string
		} else if (params &amp;&amp; (typeof params === "undefined" ? "undefined" : _typeof(params)) === "object") {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if (self.length > 0) {
			jQuery.ajax({
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			}).done(function (responseText) {

				// Save response for use in complete callback
				response = arguments;

				self.html(selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("&lt;div>").append(jQuery.parseHTML(responseText)).find(selector) :

				// Otherwise use the full result
				responseText);

				// If the request succeeds, this function gets "data", "status", "jqXHR"
				// but they are ignored because response was set above.
				// If it fails, this function gets "jqXHR", "status", "error"
			}).always(callback &amp;&amp; function (jqXHR, status) {
				self.each(function () {
					callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
				});
			});
		}

		return this;
	};

	// Attach a bunch of functions for handling common AJAX events
	jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
		jQuery.fn[type] = function (fn) {
			return this.on(type, fn);
		};
	});

	jQuery.expr.filters.animated = function (elem) {
		return jQuery.grep(jQuery.timers, function (fn) {
			return elem === fn.elem;
		}).length;
	};

	/**
  * Gets a window from an element
  */
	function getWindow(elem) {
		return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 &amp;&amp; elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function setOffset(elem, options, i) {
			var curPosition,
			    curLeft,
			    curCSSTop,
			    curTop,
			    curOffset,
			    curCSSLeft,
			    calculatePosition,
			    position = jQuery.css(elem, "position"),
			    curElem = jQuery(elem),
			    props = {};

			// Set position first, in-case top/left are set even on static elem
			if (position === "static") {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css(elem, "top");
			curCSSLeft = jQuery.css(elem, "left");
			calculatePosition = (position === "absolute" || position === "fixed") &amp;&amp; (curCSSTop + curCSSLeft).indexOf("auto") > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if (calculatePosition) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
			} else {
				curTop = parseFloat(curCSSTop) || 0;
				curLeft = parseFloat(curCSSLeft) || 0;
			}

			if (jQuery.isFunction(options)) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call(elem, i, jQuery.extend({}, curOffset));
			}

			if (options.top != null) {
				props.top = options.top - curOffset.top + curTop;
			}
			if (options.left != null) {
				props.left = options.left - curOffset.left + curLeft;
			}

			if ("using" in options) {
				options.using.call(elem, props);
			} else {
				curElem.css(props);
			}
		}
	};

	jQuery.fn.extend({
		offset: function offset(options) {
			if (arguments.length) {
				return options === undefined ? this : this.each(function (i) {
					jQuery.offset.setOffset(this, options, i);
				});
			}

			var docElem,
			    win,
			    elem = this[0],
			    box = { top: 0, left: 0 },
			    doc = elem &amp;&amp; elem.ownerDocument;

			if (!doc) {
				return;
			}

			docElem = doc.documentElement;

			// Make sure it's not a disconnected DOM node
			if (!jQuery.contains(docElem, elem)) {
				return box;
			}

			box = elem.getBoundingClientRect();
			win = getWindow(doc);
			return {
				top: box.top + win.pageYOffset - docElem.clientTop,
				left: box.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function position() {
			if (!this[0]) {
				return;
			}

			var offsetParent,
			    offset,
			    elem = this[0],
			    parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if (jQuery.css(elem, "position") === "fixed") {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();
			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if (!jQuery.nodeName(offsetParent[0], "html")) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
				parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
				left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function offsetParent() {
			return this.map(function () {
				var offsetParent = this.offsetParent;

				while (offsetParent &amp;&amp; jQuery.css(offsetParent, "position") === "static") {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			});
		}
	});

	// Create scrollLeft and scrollTop methods
	jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
		var top = "pageYOffset" === prop;

		jQuery.fn[method] = function (val) {
			return access(this, function (elem, method, val) {
				var win = getWindow(elem);

				if (val === undefined) {
					return win ? win[prop] : elem[method];
				}

				if (win) {
					win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
				} else {
					elem[method] = val;
				}
			}, method, val, arguments.length);
		};
	});

	// Support: Safari&lt;7-8+, Chrome&lt;37-44+
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each(["top", "left"], function (i, prop) {
		jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
			if (computed) {
				computed = curCSS(elem, prop);

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
			}
		});
	});

	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
		jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[funcName] = function (margin, value) {
				var chainable = arguments.length &amp;&amp; (defaultExtra || typeof margin !== "boolean"),
				    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

				return access(this, function (elem, type, value) {
					var doc;

					if (jQuery.isWindow(elem)) {

						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
						// isn't a whole lot we can do. See pull request at this URL for discussion:
						// https://github.com/jquery/jquery/pull/764
						return elem.document.documentElement["client" + name];
					}

					// Get document width or height
					if (elem.nodeType === 9) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
					}

					return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css(elem, type, extra) :

					// Set width or height on the element
					jQuery.style(elem, type, value, extra);
				}, type, chainable ? margin : undefined, chainable, null);
			};
		});
	});

	jQuery.fn.extend({

		bind: function bind(types, data, fn) {
			return this.on(types, null, data, fn);
		},
		unbind: function unbind(types, fn) {
			return this.off(types, null, fn);
		},

		delegate: function delegate(selector, types, data, fn) {
			return this.on(types, selector, data, fn);
		},
		undelegate: function undelegate(selector, types, fn) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
		},
		size: function size() {
			return this.length;
		}
	});

	jQuery.fn.andSelf = jQuery.fn.addBack;

	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if (true) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}

	var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,


	// Map over the $ in case of overwrite
	_$ = window.$;

	jQuery.noConflict = function (deep) {
		if (window.$ === jQuery) {
			window.$ = _$;
		}

		if (deep &amp;&amp; window.jQuery === jQuery) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if (!noGlobal) {
		window.jQuery = window.$ = jQuery;
	}

	return jQuery;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)(module)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node &amp;&amp; node.loc,
      line = undefined,
      column = undefined;
  if (loc) {
    line = loc.start.line;
    column = loc.start.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx &lt; errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  try {
    if (loc) {
      this.lineNumber = line;

      // Work around issue under safari where we can't directly set the column value
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(this, 'column', {
          value: column,
          enumerable: true
        });
      } else {
        this.column = column;
      }
    }
  } catch (nop) {
    /* Ignore if the browser is very particular */
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Freezer = exports.browserNotification = exports.tokenAuth = exports.AjaxSender = exports.unzipper = exports.commonTools = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by AHonyakov on 07.06.2017.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _pako = __webpack_require__(28);

var _pako2 = _interopRequireDefault(_pako);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

__webpack_require__(6);

var commonTools = exports.commonTools = function () {
    function commonTools(name) {
        _classCallCheck(this, commonTools);

        this.name = name;
    }

    _createClass(commonTools, [{
        key: 'getTimeStr',
        value: function getTimeStr(isodate) {
            var dateStr = isodate.substring(0, isodate.length - (isodate.length - 10));
            return dateStr;
        }
    }]);

    return commonTools;
}();

var unzipper = exports.unzipper = function () {
    function unzipper(zippedData) {
        _classCallCheck(this, unzipper);

        this.zippedData = zippedData;
        this.unzippedData = {};
        this._unzip();
    }

    _createClass(unzipper, [{
        key: '_unzip',
        value: function _unzip() {
            if (this.zippedData.message.type === "Buffer") {
                var b64 = this.zippedData.message.data;
                // Decode base64 (convert ascii to binary)
                var strData = atob(b64);
                // Convert binary string to character-number array
                var charData = strData.split('').map(function (x) {
                    return x.charCodeAt(0);
                });
                // Turn number array into byte-array
                var binData = new Uint8Array(charData);
                // Pako magic
                var data = JSON.parse(_pako2.default.inflate(binData, { to: 'string' }));
                this.unzippedData.status = this.zippedData.status;
                this.unzippedData.message = data;
            } else {
                this.unzippedData = this.zippedData;
            }
        }
    }]);

    return unzipper;
}();

var AjaxSender = exports.AjaxSender = function () {
    function AjaxSender(options) {
        _classCallCheck(this, AjaxSender);

        this.url = options.url;
        this.msg = options.msg;
        this.headerAccept = options.headerAccept;
        this.before = options.before;
    }

    _createClass(AjaxSender, [{
        key: 'sendQuery',
        value: function sendQuery() {
            var self = this; //передача контекста через замыкание
            return new Promise(function (resolve, reject) {
                var xhr = new XMLHttpRequest();
                if (self.headerAccept !== undefined) {
                    xhr.setRequestHeader('headerAccept', self.headerAccept);
                }
                xhr.open('POST', self.url, true);
                xhr.onload = function () {
                    if (this.status === 200) {
                        var serverAns = this.response;
                        //для заглушек
                        serverAns = serverAns.toString();
                        serverAns = JSON.parse(serverAns);
                        serverAns = new unzipper(serverAns).unzippedData;
                        console.log(serverAns);
                        if (serverAns.status === 'success') {
                            resolve(serverAns.message);
                        } else {
                            var error = new Error(serverAns.message);
                            error.code = 9999;
                            reject(error);
                        }
                    } else {
                        var _error = new Error(this.statusText);
                        _error.code = this.status;
                        reject(_error);
                    }
                };
                if (self.before !== undefined) {
                    self.before();
                }
                xhr.onerror = function () {
                    reject(new Error('Network Error'));
                };
                xhr.send(self.msg);
            });
        }
    }]);

    return AjaxSender;
}();

var tokenAuth = exports.tokenAuth = function () {
    function tokenAuth(name) {
        _classCallCheck(this, tokenAuth);

        this.name = name;
    }

    _createClass(tokenAuth, [{
        key: 'checkToken',
        value: function checkToken() {
            return this._getCookie(this.name);
        }
    }, {
        key: 'addToken',
        value: function addToken(token) {
            this._setCookie(this.name, token, { expires: 0 }); //устанавливаем "сессионное куки"
        }
    }, {
        key: '_setCookie',
        value: function _setCookie(name, value, options) {
            options = options || {};

            var expires = options.expires;

            if (typeof expires === "number" &amp;&amp; expires) {
                var d = new Date();
                d.setTime(d.getTime() + expires * 1000);
                expires = options.expires = d;
            }
            if (expires &amp;&amp; expires.toUTCString) {
                options.expires = expires.toUTCString();
            }

            value = encodeURIComponent(value);

            var updatedCookie = name + "=" + value;

            for (var propName in options) {
                updatedCookie += "; " + propName;
                var propValue = options[propName];
                if (propValue !== true) {
                    updatedCookie += "=" + propValue;
                }
            }

            document.cookie = updatedCookie;
        }
    }, {
        key: '_getCookie',
        value: function _getCookie(name) {
            var matches = document.cookie.match(new RegExp("(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"));
            return matches ? decodeURIComponent(matches[1]) : undefined;
        }
    }, {
        key: '_deleteCookie',
        value: function _deleteCookie() {
            this._setCookie(this.name, "", { expires: -1 });
        }
    }, {
        key: 'exit',
        value: function exit(page) {
            this._deleteCookie();
            document.location.href = page;
        }
    }]);

    return tokenAuth;
}();

var browserNotification = exports.browserNotification = function browserNotification(title, options) {
    _classCallCheck(this, browserNotification);

    // Проверим, поддерживает ли браузер HTML5 Notifications
    if (!("Notification" in window)) {
        alert('Ваш браузер не поддерживает HTML Notifications, его необходимо обновить.');
    }
    // Проверим, есть ли права на отправку уведомлений
    else if (Notification.permission === "granted") {
            var clickFunc = function clickFunc() {
                alert('Пользователь кликнул на уведомление');
            };

            // Если права есть, отправим уведомление
            var notification = new Notification(title, options);

            notification.onclick = clickFunc;
        }
        // Если прав нет, пытаемся их получить
        else if (Notification.permission !== 'denied') {
                Notification.requestPermission(function (permission) {
                    // Если права успешно получены, отправляем уведомление
                    if (permission === "granted") {
                        var _notification = new Notification(title, options);
                    } else {
                        alert('Вы запретили показывать уведомления'); // Юзер отклонил наш запрос на показ уведомлений
                    }
                });
            } else {
                // Пользователь ранее отклонил наш запрос на показ уведомлений
                // В этом месте мы можем, но не будем его беспокоить. Уважайте решения своих пользователей.
            }
};

var Freezer = exports.Freezer = function () {
    function Freezer(params) {
        _classCallCheck(this, Freezer);

        this.place = params.place || "";
        this.message = params.message;
    }

    _createClass(Freezer, [{
        key: 'lock',
        value: function lock() {
            $(this.place).block({
                css: {
                    border: 'none',
                    padding: '15px',
                    backgroundColor: '#000',
                    '-webkit-border-radius': '10px',
                    '-moz-border-radius': '10px',
                    opacity: .5,
                    color: '#fff'
                },
                message: '&lt;i class="fa fa-cog fa-spin fa-fw">&lt;/i> ' + this.message
            });
        }
    }, {
        key: 'unlock',
        value: function unlock() {
            $(this.place).unblock();
        }
    }]);

    return Freezer;
}();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj &amp;&amp; obj.__esModule ? obj : { 'default': obj };
}

var _utils = __webpack_require__(0);

var _exception = __webpack_require__(2);

var _exception2 = _interopRequireDefault(_exception);

var _helpers = __webpack_require__(13);

var _decorators = __webpack_require__(21);

var _logger = __webpack_require__(23);

var _logger2 = _interopRequireDefault(_logger);

var VERSION = '4.0.10';
exports.VERSION = VERSION;
var COMPILER_REVISION = 7;

exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '&lt;= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};

  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: _logger2['default'],
  log: _logger2['default'].log,

  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },

  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  }
};

var log = _logger2['default'].log;

exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];

/***/ }),
/* 5 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/
var jQuery = __webpack_require__(1);

/*!
 * jQuery blockUI plugin
 * Version 2.70.0-2014.11.23
 * Requires jQuery v1.7 or later
 *
 * Examples at: http://malsup.com/jquery/block/
 * Copyright (c) 2007-2013 M. Alsup
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * Thanks to Amir-Hossein Sobhi for some excellent contributions!
 */

;(function() {
/*jshint eqeqeq:false curly:false latedef:false */
"use strict";

	function setup($) {
		$.fn._fadeIn = $.fn.fadeIn;

		var noOp = $.noop || function() {};

		// this bit is to ensure we don't call setExpression when we shouldn't (with extra muscle to handle
		// confusing userAgent strings on Vista)
		var msie = /MSIE/.test(navigator.userAgent);
		var ie6  = /MSIE 6.0/.test(navigator.userAgent) &amp;&amp; ! /MSIE 8.0/.test(navigator.userAgent);
		var mode = document.documentMode || 0;
		var setExpr = $.isFunction( document.createElement('div').style.setExpression );

		// global $ methods for blocking/unblocking the entire page
		$.blockUI   = function(opts) { install(window, opts); };
		$.unblockUI = function(opts) { remove(window, opts); };

		// convenience method for quick growl-like notifications  (http://www.google.com/search?q=growl)
		$.growlUI = function(title, message, timeout, onClose) {
			var $m = $('&lt;div class="growlUI">&lt;/div>');
			if (title) $m.append('&lt;h1>'+title+'&lt;/h1>');
			if (message) $m.append('&lt;h2>'+message+'&lt;/h2>');
			if (timeout === undefined) timeout = 3000;

			// Added by konapun: Set timeout to 30 seconds if this growl is moused over, like normal toast notifications
			var callBlock = function(opts) {
				opts = opts || {};

				$.blockUI({
					message: $m,
					fadeIn : typeof opts.fadeIn  !== 'undefined' ? opts.fadeIn  : 700,
					fadeOut: typeof opts.fadeOut !== 'undefined' ? opts.fadeOut : 1000,
					timeout: typeof opts.timeout !== 'undefined' ? opts.timeout : timeout,
					centerY: false,
					showOverlay: false,
					onUnblock: onClose,
					css: $.blockUI.defaults.growlCSS
				});
			};

			callBlock();
			var nonmousedOpacity = $m.css('opacity');
			$m.mouseover(function() {
				callBlock({
					fadeIn: 0,
					timeout: 30000
				});

				var displayBlock = $('.blockMsg');
				displayBlock.stop(); // cancel fadeout if it has started
				displayBlock.fadeTo(300, 1); // make it easier to read the message by removing transparency
			}).mouseout(function() {
				$('.blockMsg').fadeOut(1000);
			});
			// End konapun additions
		};

		// plugin method for blocking element content
		$.fn.block = function(opts) {
			if ( this[0] === window ) {
				$.blockUI( opts );
				return this;
			}
			var fullOpts = $.extend({}, $.blockUI.defaults, opts || {});
			this.each(function() {
				var $el = $(this);
				if (fullOpts.ignoreIfBlocked &amp;&amp; $el.data('blockUI.isBlocked'))
					return;
				$el.unblock({ fadeOut: 0 });
			});

			return this.each(function() {
				if ($.css(this,'position') == 'static') {
					this.style.position = 'relative';
					$(this).data('blockUI.static', true);
				}
				this.style.zoom = 1; // force 'hasLayout' in ie
				install(this, opts);
			});
		};

		// plugin method for unblocking element content
		$.fn.unblock = function(opts) {
			if ( this[0] === window ) {
				$.unblockUI( opts );
				return this;
			}
			return this.each(function() {
				remove(this, opts);
			});
		};

		$.blockUI.version = 2.70; // 2nd generation blocking at no extra cost!

		// override these in your code to change the default behavior and style
		$.blockUI.defaults = {
			// message displayed when blocking (use null for no message)
			message:  '&lt;h1>Please wait...&lt;/h1>',

			title: null,		// title string; only used when theme == true
			draggable: true,	// only used when theme == true (requires jquery-ui.js to be loaded)

			theme: false, // set to true to use with jQuery UI themes

			// styles for the message when blocking; if you wish to disable
			// these and use an external stylesheet then do this in your code:
			// $.blockUI.defaults.css = {};
			css: {
				padding:	0,
				margin:		0,
				width:		'30%',
				top:		'40%',
				left:		'35%',
				textAlign:	'center',
				color:		'#000',
				border:		'3px solid #aaa',
				backgroundColor:'#fff',
				cursor:		'wait'
			},

			// minimal style set used when themes are used
			themedCSS: {
				width:	'30%',
				top:	'40%',
				left:	'35%'
			},

			// styles for the overlay
			overlayCSS:  {
				backgroundColor:	'#000',
				opacity:			0.6,
				cursor:				'wait'
			},

			// style to replace wait cursor before unblocking to correct issue
			// of lingering wait cursor
			cursorReset: 'default',

			// styles applied when using $.growlUI
			growlCSS: {
				width:		'350px',
				top:		'10px',
				left:		'',
				right:		'10px',
				border:		'none',
				padding:	'5px',
				opacity:	0.6,
				cursor:		'default',
				color:		'#fff',
				backgroundColor: '#000',
				'-webkit-border-radius':'10px',
				'-moz-border-radius':	'10px',
				'border-radius':		'10px'
			},

			// IE issues: 'about:blank' fails on HTTPS and javascript:false is s-l-o-w
			// (hat tip to Jorge H. N. de Vasconcelos)
			/*jshint scripturl:true */
			iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank',

			// force usage of iframe in non-IE browsers (handy for blocking applets)
			forceIframe: false,

			// z-index for the blocking overlay
			baseZ: 1000,

			// set these to true to have the message automatically centered
			centerX: true, // &lt;-- only effects element blocking (page block controlled via css above)
			centerY: true,

			// allow body element to be stetched in ie6; this makes blocking look better
			// on "short" pages.  disable if you wish to prevent changes to the body height
			allowBodyStretch: true,

			// enable if you want key and mouse events to be disabled for content that is blocked
			bindEvents: true,

			// be default blockUI will supress tab navigation from leaving blocking content
			// (if bindEvents is true)
			constrainTabKey: true,

			// fadeIn time in millis; set to 0 to disable fadeIn on block
			fadeIn:  200,

			// fadeOut time in millis; set to 0 to disable fadeOut on unblock
			fadeOut:  400,

			// time in millis to wait before auto-unblocking; set to 0 to disable auto-unblock
			timeout: 0,

			// disable if you don't want to show the overlay
			showOverlay: true,

			// if true, focus will be placed in the first available input field when
			// page blocking
			focusInput: true,

            // elements that can receive focus
            focusableElements: ':input:enabled:visible',

			// suppresses the use of overlay styles on FF/Linux (due to performance issues with opacity)
			// no longer needed in 2012
			// applyPlatformOpacityRules: true,

			// callback method invoked when fadeIn has completed and blocking message is visible
			onBlock: null,

			// callback method invoked when unblocking has completed; the callback is
			// passed the element that has been unblocked (which is the window object for page
			// blocks) and the options that were passed to the unblock call:
			//	onUnblock(element, options)
			onUnblock: null,

			// callback method invoked when the overlay area is clicked.
			// setting this will turn the cursor to a pointer, otherwise cursor defined in overlayCss will be used.
			onOverlayClick: null,

			// don't ask; if you really must know: http://groups.google.com/group/jquery-en/browse_thread/thread/36640a8730503595/2f6a79a77a78e493#2f6a79a77a78e493
			quirksmodeOffsetHack: 4,

			// class name of the message block
			blockMsgClass: 'blockMsg',

			// if it is already blocked, then ignore it (don't unblock and reblock)
			ignoreIfBlocked: false
		};

		// private data and functions follow...

		var pageBlock = null;
		var pageBlockEls = [];

		function install(el, opts) {
			var css, themedCSS;
			var full = (el == window);
			var msg = (opts &amp;&amp; opts.message !== undefined ? opts.message : undefined);
			opts = $.extend({}, $.blockUI.defaults, opts || {});

			if (opts.ignoreIfBlocked &amp;&amp; $(el).data('blockUI.isBlocked'))
				return;

			opts.overlayCSS = $.extend({}, $.blockUI.defaults.overlayCSS, opts.overlayCSS || {});
			css = $.extend({}, $.blockUI.defaults.css, opts.css || {});
			if (opts.onOverlayClick)
				opts.overlayCSS.cursor = 'pointer';

			themedCSS = $.extend({}, $.blockUI.defaults.themedCSS, opts.themedCSS || {});
			msg = msg === undefined ? opts.message : msg;

			// remove the current block (if there is one)
			if (full &amp;&amp; pageBlock)
				remove(window, {fadeOut:0});

			// if an existing element is being used as the blocking content then we capture
			// its current place in the DOM (and current display style) so we can restore
			// it when we unblock
			if (msg &amp;&amp; typeof msg != 'string' &amp;&amp; (msg.parentNode || msg.jquery)) {
				var node = msg.jquery ? msg[0] : msg;
				var data = {};
				$(el).data('blockUI.history', data);
				data.el = node;
				data.parent = node.parentNode;
				data.display = node.style.display;
				data.position = node.style.position;
				if (data.parent)
					data.parent.removeChild(node);
			}

			$(el).data('blockUI.onUnblock', opts.onUnblock);
			var z = opts.baseZ;

			// blockUI uses 3 layers for blocking, for simplicity they are all used on every platform;
			// layer1 is the iframe layer which is used to supress bleed through of underlying content
			// layer2 is the overlay layer which has opacity and a wait cursor (by default)
			// layer3 is the message content that is displayed while blocking
			var lyr1, lyr2, lyr3, s;
			if (msie || opts.forceIframe)
				lyr1 = $('&lt;iframe class="blockUI" style="z-index:'+ (z++) +';display:none;border:none;margin:0;padding:0;position:absolute;width:100%;height:100%;top:0;left:0" src="'+opts.iframeSrc+'">&lt;/iframe>');
			else
				lyr1 = $('&lt;div class="blockUI" style="display:none">&lt;/div>');

			if (opts.theme)
				lyr2 = $('&lt;div class="blockUI blockOverlay ui-widget-overlay" style="z-index:'+ (z++) +';display:none">&lt;/div>');
			else
				lyr2 = $('&lt;div class="blockUI blockOverlay" style="z-index:'+ (z++) +';display:none;border:none;margin:0;padding:0;width:100%;height:100%;top:0;left:0">&lt;/div>');

			if (opts.theme &amp;&amp; full) {
				s = '&lt;div class="blockUI ' + opts.blockMsgClass + ' blockPage ui-dialog ui-widget ui-corner-all" style="z-index:'+(z+10)+';display:none;position:fixed">';
				if ( opts.title ) {
					s += '&lt;div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">'+(opts.title || '&amp;nbsp;')+'&lt;/div>';
				}
				s += '&lt;div class="ui-widget-content ui-dialog-content">&lt;/div>';
				s += '&lt;/div>';
			}
			else if (opts.theme) {
				s = '&lt;div class="blockUI ' + opts.blockMsgClass + ' blockElement ui-dialog ui-widget ui-corner-all" style="z-index:'+(z+10)+';display:none;position:absolute">';
				if ( opts.title ) {
					s += '&lt;div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">'+(opts.title || '&amp;nbsp;')+'&lt;/div>';
				}
				s += '&lt;div class="ui-widget-content ui-dialog-content">&lt;/div>';
				s += '&lt;/div>';
			}
			else if (full) {
				s = '&lt;div class="blockUI ' + opts.blockMsgClass + ' blockPage" style="z-index:'+(z+10)+';display:none;position:fixed">&lt;/div>';
			}
			else {
				s = '&lt;div class="blockUI ' + opts.blockMsgClass + ' blockElement" style="z-index:'+(z+10)+';display:none;position:absolute">&lt;/div>';
			}
			lyr3 = $(s);

			// if we have a message, style it
			if (msg) {
				if (opts.theme) {
					lyr3.css(themedCSS);
					lyr3.addClass('ui-widget-content');
				}
				else
					lyr3.css(css);
			}

			// style the overlay
			if (!opts.theme /*&amp;&amp; (!opts.applyPlatformOpacityRules)*/)
				lyr2.css(opts.overlayCSS);
			lyr2.css('position', full ? 'fixed' : 'absolute');

			// make iframe layer transparent in IE
			if (msie || opts.forceIframe)
				lyr1.css('opacity',0.0);

			//$([lyr1[0],lyr2[0],lyr3[0]]).appendTo(full ? 'body' : el);
			var layers = [lyr1,lyr2,lyr3], $par = full ? $('body') : $(el);
			$.each(layers, function() {
				this.appendTo($par);
			});

			if (opts.theme &amp;&amp; opts.draggable &amp;&amp; $.fn.draggable) {
				lyr3.draggable({
					handle: '.ui-dialog-titlebar',
					cancel: 'li'
				});
			}

			// ie7 must use absolute positioning in quirks mode and to account for activex issues (when scrolling)
			var expr = setExpr &amp;&amp; (!$.support.boxModel || $('object,embed', full ? null : el).length > 0);
			if (ie6 || expr) {
				// give body 100% height
				if (full &amp;&amp; opts.allowBodyStretch &amp;&amp; $.support.boxModel)
					$('html,body').css('height','100%');

				// fix ie6 issue when blocked element has a border width
				if ((ie6 || !$.support.boxModel) &amp;&amp; !full) {
					var t = sz(el,'borderTopWidth'), l = sz(el,'borderLeftWidth');
					var fixT = t ? '(0 - '+t+')' : 0;
					var fixL = l ? '(0 - '+l+')' : 0;
				}

				// simulate fixed position
				$.each(layers, function(i,o) {
					var s = o[0].style;
					s.position = 'absolute';
					if (i &lt; 2) {
						if (full)
							s.setExpression('height','Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.support.boxModel?0:'+opts.quirksmodeOffsetHack+') + "px"');
						else
							s.setExpression('height','this.parentNode.offsetHeight + "px"');
						if (full)
							s.setExpression('width','jQuery.support.boxModel &amp;&amp; document.documentElement.clientWidth || document.body.clientWidth + "px"');
						else
							s.setExpression('width','this.parentNode.offsetWidth + "px"');
						if (fixL) s.setExpression('left', fixL);
						if (fixT) s.setExpression('top', fixT);
					}
					else if (opts.centerY) {
						if (full) s.setExpression('top','(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"');
						s.marginTop = 0;
					}
					else if (!opts.centerY &amp;&amp; full) {
						var top = (opts.css &amp;&amp; opts.css.top) ? parseInt(opts.css.top, 10) : 0;
						var expression = '((document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + '+top+') + "px"';
						s.setExpression('top',expression);
					}
				});
			}

			// show the message
			if (msg) {
				if (opts.theme)
					lyr3.find('.ui-widget-content').append(msg);
				else
					lyr3.append(msg);
				if (msg.jquery || msg.nodeType)
					$(msg).show();
			}

			if ((msie || opts.forceIframe) &amp;&amp; opts.showOverlay)
				lyr1.show(); // opacity is zero
			if (opts.fadeIn) {
				var cb = opts.onBlock ? opts.onBlock : noOp;
				var cb1 = (opts.showOverlay &amp;&amp; !msg) ? cb : noOp;
				var cb2 = msg ? cb : noOp;
				if (opts.showOverlay)
					lyr2._fadeIn(opts.fadeIn, cb1);
				if (msg)
					lyr3._fadeIn(opts.fadeIn, cb2);
			}
			else {
				if (opts.showOverlay)
					lyr2.show();
				if (msg)
					lyr3.show();
				if (opts.onBlock)
					opts.onBlock.bind(lyr3)();
			}

			// bind key and mouse events
			bind(1, el, opts);

			if (full) {
				pageBlock = lyr3[0];
				pageBlockEls = $(opts.focusableElements,pageBlock);
				if (opts.focusInput)
					setTimeout(focus, 20);
			}
			else
				center(lyr3[0], opts.centerX, opts.centerY);

			if (opts.timeout) {
				// auto-unblock
				var to = setTimeout(function() {
					if (full)
						$.unblockUI(opts);
					else
						$(el).unblock(opts);
				}, opts.timeout);
				$(el).data('blockUI.timeout', to);
			}
		}

		// remove the block
		function remove(el, opts) {
			var count;
			var full = (el == window);
			var $el = $(el);
			var data = $el.data('blockUI.history');
			var to = $el.data('blockUI.timeout');
			if (to) {
				clearTimeout(to);
				$el.removeData('blockUI.timeout');
			}
			opts = $.extend({}, $.blockUI.defaults, opts || {});
			bind(0, el, opts); // unbind events

			if (opts.onUnblock === null) {
				opts.onUnblock = $el.data('blockUI.onUnblock');
				$el.removeData('blockUI.onUnblock');
			}

			var els;
			if (full) // crazy selector to handle odd field errors in ie6/7
				els = $('body').children().filter('.blockUI').add('body > .blockUI');
			else
				els = $el.find('>.blockUI');

			// fix cursor issue
			if ( opts.cursorReset ) {
				if ( els.length > 1 )
					els[1].style.cursor = opts.cursorReset;
				if ( els.length > 2 )
					els[2].style.cursor = opts.cursorReset;
			}

			if (full)
				pageBlock = pageBlockEls = null;

			if (opts.fadeOut) {
				count = els.length;
				els.stop().fadeOut(opts.fadeOut, function() {
					if ( --count === 0)
						reset(els,data,opts,el);
				});
			}
			else
				reset(els, data, opts, el);
		}

		// move blocking element back into the DOM where it started
		function reset(els,data,opts,el) {
			var $el = $(el);
			if ( $el.data('blockUI.isBlocked') )
				return;

			els.each(function(i,o) {
				// remove via DOM calls so we don't lose event handlers
				if (this.parentNode)
					this.parentNode.removeChild(this);
			});

			if (data &amp;&amp; data.el) {
				data.el.style.display = data.display;
				data.el.style.position = data.position;
				data.el.style.cursor = 'default'; // #59
				if (data.parent)
					data.parent.appendChild(data.el);
				$el.removeData('blockUI.history');
			}

			if ($el.data('blockUI.static')) {
				$el.css('position', 'static'); // #22
			}

			if (typeof opts.onUnblock == 'function')
				opts.onUnblock(el,opts);

			// fix issue in Safari 6 where block artifacts remain until reflow
			var body = $(document.body), w = body.width(), cssW = body[0].style.width;
			body.width(w-1).width(w);
			body[0].style.width = cssW;
		}

		// bind/unbind the handler
		function bind(b, el, opts) {
			var full = el == window, $el = $(el);

			// don't bother unbinding if there is nothing to unbind
			if (!b &amp;&amp; (full &amp;&amp; !pageBlock || !full &amp;&amp; !$el.data('blockUI.isBlocked')))
				return;

			$el.data('blockUI.isBlocked', b);

			// don't bind events when overlay is not in use or if bindEvents is false
			if (!full || !opts.bindEvents || (b &amp;&amp; !opts.showOverlay))
				return;

			// bind anchors and inputs for mouse and key events
			var events = 'mousedown mouseup keydown keypress keyup touchstart touchend touchmove';
			if (b)
				$(document).bind(events, opts, handler);
			else
				$(document).unbind(events, handler);

		// former impl...
		//		var $e = $('a,:input');
		//		b ? $e.bind(events, opts, handler) : $e.unbind(events, handler);
		}

		// event handler to suppress keyboard/mouse events when blocking
		function handler(e) {
			// allow tab navigation (conditionally)
			if (e.type === 'keydown' &amp;&amp; e.keyCode &amp;&amp; e.keyCode == 9) {
				if (pageBlock &amp;&amp; e.data.constrainTabKey) {
					var els = pageBlockEls;
					var fwd = !e.shiftKey &amp;&amp; e.target === els[els.length-1];
					var back = e.shiftKey &amp;&amp; e.target === els[0];
					if (fwd || back) {
						setTimeout(function(){focus(back);},10);
						return false;
					}
				}
			}
			var opts = e.data;
			var target = $(e.target);
			if (target.hasClass('blockOverlay') &amp;&amp; opts.onOverlayClick)
				opts.onOverlayClick(e);

			// allow events within the message content
			if (target.parents('div.' + opts.blockMsgClass).length > 0)
				return true;

			// allow events for content that is not being blocked
			return target.parents().children().filter('div.blockUI').length === 0;
		}

		function focus(back) {
			if (!pageBlockEls)
				return;
			var e = pageBlockEls[back===true ? pageBlockEls.length-1 : 0];
			if (e)
				e.focus();
		}

		function center(el, x, y) {
			var p = el.parentNode, s = el.style;
			var l = ((p.offsetWidth - el.offsetWidth)/2) - sz(p,'borderLeftWidth');
			var t = ((p.offsetHeight - el.offsetHeight)/2) - sz(p,'borderTopWidth');
			if (x) s.left = l > 0 ? (l+'px') : '0';
			if (y) s.top  = t > 0 ? (t+'px') : '0';
		}

		function sz(el, p) {
			return parseInt($.css(el,p),10)||0;
		}

	}


	/*global define:true */
	if ("function" === 'function' &amp;&amp; __webpack_require__(5) &amp;&amp; __webpack_require__(5).jQuery) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (setup),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		setup(jQuery);
	}

})();



/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = __webpack_require__(12)['default'];

/***/ }),
/* 8 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {/**
 * Created by AHonyakov on 28.06.2017.
 */


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Layout = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _component = __webpack_require__(31);

var componentLib = _interopRequireWildcard(_component);

var _index = __webpack_require__(3);

var tools = _interopRequireWildcard(_index);

var _index2 = __webpack_require__(37);

var _index3 = _interopRequireDefault(_index2);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj &amp;&amp; obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call &amp;&amp; (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" &amp;&amp; superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

window.twoBe = _index3.default;

var Layout = exports.Layout = function (_componentLib$Compone) {
    _inherits(Layout, _componentLib$Compone);

    function Layout(param) {
        _classCallCheck(this, Layout);

        var _this = _possibleConstructorReturn(this, (Layout.__proto__ || Object.getPrototypeOf(Layout)).call(this, param));

        _this.panels = {};
        _this.saveInWindow();
        _this.getAttributes(param.element);
        _this.render();
        return _this;
    }

    _createClass(Layout, [{
        key: 'getAttributes',
        value: function getAttributes(attributes) {
            for (var i in attributes.elements) {
                this.panels[attributes.elements[i].properties.position] = attributes.elements[i];
            }
        }
    }, {
        key: 'refresh',
        value: function refresh() {
            for (var i in this.children) {
                this.children[i].refresh();
            }
        }
    }, {
        key: 'render',
        value: function render(place) {
            if (place === undefined) {
                place = this.box;
            }
            if (w2ui[this.id] !== undefined) {
                w2ui[this.id].destroy();
            }
            var panelObj = this.makew2uilayout();
            $(place).w2layout(panelObj);
            this.buildPanels();
        }

        /**
         * Делает объект для в2уай
         * @returns {{name: *}}
         * @private
         */

    }, {
        key: 'makew2uilayout',
        value: function makew2uilayout() {
            var obj = {
                name: this.id
            };
            var panels = [];
            for (var type in this.panels) {
                panels.push({
                    type: this.panels[type].properties.position,
                    size: this.panels[type].properties.width,
                    resizable: true
                });
                if (this.panels[type].elements.length !== 1 &amp;&amp; this.panels[type].elements.length !== 0) {
                    var error = new Error('Wrong format data');
                    throw error;
                }
            }
            obj.panels = panels;
            console.log(obj);
            return obj;
        }

        /**
         * Выполняет построение панелей и объектов в них
         * @private
         */

    }, {
        key: 'buildPanels',
        value: function buildPanels() {
            var _this2 = this;

            console.log(this.panels);

            var _loop = function _loop(panel) {
                if (_this2.panels[panel] === undefined) return 'continue';
                //определяем тип содержимого
                //содержимое таблица
                if (_this2.panels[panel].elements[0].type === 'grid') {
                    //запоминание контекста
                    var self = _this2;
                    //подключаем нужную библиотеку
                    var needLib = __webpack_require__(39)(function (mod) {
                        //строим таблицу
                        new mod.Grid({
                            box: w2ui[self.id].el(panel),
                            element: self.panels[panel].elements[0],
                            code: self.code,
                            content: self.content,
                            parent: self
                        });
                    });
                }
                if (_this2.panels[panel].elements[0].type === 'form') {
                    //запоминание контекста
                    var _self = _this2;
                    //подключаем нужную библиотеку
                    var _needLib = __webpack_require__(40)(function (mod) {
                        var form = new mod.Form({
                            element: _self.panels[panel].elements[0],
                            code: _self.code,
                            content: _self.content,
                            parent: _self
                        });
                        w2ui[_self.id].el(panel).appendChild(form.render());
                    });
                }
                if (_this2.panels[panel].elements[0].type === 'tabs') {
                    //запоминание контекста
                    var _self2 = _this2;
                    console.log(_self2);
                    //подключаем нужную библиотеку
                    var _needLib2 = __webpack_require__(41)(function (mod) {
                        var tabs = new mod.Tabs({
                            box: w2ui[_self2.id].el(panel),
                            element: _self2.panels[panel].elements[0],
                            code: _self2.code,
                            content: _self2.content,
                            parent: _self2
                        });
                    });
                }
                if (_this2.panels[panel].elements[0].type === 'map') {
                    //запоминание контекста
                    var _self3 = _this2;
                    console.log(_self3);
                    //подключаем нужную библиотеку
                    var _needLib3 = __webpack_require__(42)(function (mod) {
                        var m = new mod.Map({
                            box: w2ui[_self3.id].el(panel),
                            element: _self3.panels[panel].elements[0],
                            code: _self3.code,
                            content: _self3.content,
                            parent: _self3
                        });
                        console.log(m);
                    });
                }
            };

            for (var panel in this.panels) {
                var _ret = _loop(panel);

                if (_ret === 'continue') continue;
            }
        }
    }]);

    return Layout;
}(componentLib.Component);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 11 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj &amp;&amp; obj.__esModule ? obj : { 'default': obj };
}

// istanbul ignore next

function _interopRequireWildcard(obj) {
  if (obj &amp;&amp; obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj['default'] = obj;return newObj;
  }
}

var _handlebarsBase = __webpack_require__(4);

var base = _interopRequireWildcard(_handlebarsBase);

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var _handlebarsSafeString = __webpack_require__(24);

var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

var _handlebarsException = __webpack_require__(2);

var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

var _handlebarsUtils = __webpack_require__(0);

var Utils = _interopRequireWildcard(_handlebarsUtils);

var _handlebarsRuntime = __webpack_require__(25);

var runtime = _interopRequireWildcard(_handlebarsRuntime);

var _handlebarsNoConflict = __webpack_require__(26);

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj &amp;&amp; obj.__esModule ? obj : { 'default': obj };
}

var _helpersBlockHelperMissing = __webpack_require__(14);

var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

var _helpersEach = __webpack_require__(15);

var _helpersEach2 = _interopRequireDefault(_helpersEach);

var _helpersHelperMissing = __webpack_require__(16);

var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

var _helpersIf = __webpack_require__(17);

var _helpersIf2 = _interopRequireDefault(_helpersIf);

var _helpersLog = __webpack_require__(18);

var _helpersLog2 = _interopRequireDefault(_helpersLog);

var _helpersLookup = __webpack_require__(19);

var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

var _helpersWith = __webpack_require__(20);

var _helpersWith2 = _interopRequireDefault(_helpersWith);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(0);

exports['default'] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data &amp;&amp; options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });
};

module.exports = exports['default'];

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" &amp;&amp; typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj &amp;&amp; typeof Symbol === "function" &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj &amp;&amp; obj.__esModule ? obj : { 'default': obj };
}

var _utils = __webpack_require__(0);

var _exception = __webpack_require__(2);

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data &amp;&amp; options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = _utils.createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context &amp;&amp; (typeof context === 'undefined' ? 'undefined' : _typeof(context)) === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i &lt; j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else {
        var priorKey = undefined;

        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
        }
        if (priorKey !== undefined) {
          execIteration(priorKey, i - 1, true);
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });
};

module.exports = exports['default'];

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj &amp;&amp; obj.__esModule ? obj : { 'default': obj };
}

var _exception = __webpack_require__(2);

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};

module.exports = exports['default'];

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(0);

exports['default'] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero &amp;&amp; !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
  });
};

module.exports = exports['default'];

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
        options = arguments[arguments.length - 1];
    for (var i = 0; i &lt; arguments.length - 1; i++) {
      args.push(arguments[i]);
    }

    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data &amp;&amp; options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;

    instance.log.apply(instance, args);
  });
};

module.exports = exports['default'];

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('lookup', function (obj, field) {
    return obj &amp;&amp; obj[field];
  });
};

module.exports = exports['default'];

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(0);

exports['default'] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data &amp;&amp; options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }

      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data &amp;&amp; data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};

module.exports = exports['default'];

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj &amp;&amp; obj.__esModule ? obj : { 'default': obj };
}

var _decoratorsInline = __webpack_require__(22);

var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(0);

exports['default'] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function ret(context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }

    props.partials[options.args[0]] = options.fn;

    return ret;
  });
};

module.exports = exports['default'];

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _utils = __webpack_require__(0);

var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',

  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }

    return level;
  },

  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);

    if (typeof console !== 'undefined' &amp;&amp; logger.lookupLevel(logger.level) &lt;= level) {
      var method = logger.methodMap[level];
      if (!console[method]) {
        // eslint-disable-line no-console
        method = 'log';
      }

      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key &lt; _len; _key++) {
        message[_key - 1] = arguments[_key];
      }

      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports['default'] = logger;
module.exports = exports['default'];

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Build out our basic SafeString type


exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" &amp;&amp; typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj &amp;&amp; typeof Symbol === "function" &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) {
  return obj &amp;&amp; obj.__esModule ? obj : { 'default': obj };
}

// istanbul ignore next

function _interopRequireWildcard(obj) {
  if (obj &amp;&amp; obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
      }
    }newObj['default'] = obj;return newObj;
  }
}

var _utils = __webpack_require__(0);

var Utils = _interopRequireWildcard(_utils);

var _exception = __webpack_require__(2);

var _exception2 = _interopRequireDefault(_exception);

var _base = __webpack_require__(4);

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo &amp;&amp; compilerInfo[0] || 1,
      currentRevision = _base.COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision &lt; currentRevision) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + (typeof templateSpec === 'undefined' ? 'undefined' : _typeof(templateSpec)));
  }

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null &amp;&amp; env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i &lt; l; i++) {
          if (!lines[i] &amp;&amp; i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name) {
      if (!(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
      }
      return obj[name];
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i &lt; len; i++) {
        if (depths[i] &amp;&amp; depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value &amp;&amp; depth--) {
        value = value._parent;
      }
      return value;
    },
    merge: function merge(param, common) {
      var obj = param || common;

      if (param &amp;&amp; common &amp;&amp; param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length &lt;= 1 || arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial &amp;&amp; templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = container.merge(options.decorators, env.decorators);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams &amp;&amp; !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths &amp;&amp; !depths) {
      throw new _exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length &lt;= 1 || arguments[1] === undefined ? {} : arguments[1];

    var currentDepths = depths;
    if (depths &amp;&amp; context != depths[0] &amp;&amp; !(context === container.nullContext &amp;&amp; depths[0] === null)) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams &amp;&amp; [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call &amp;&amp; !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  // Use the current closure context to save the partial-block if this partial
  var currentPartialBlock = options.data &amp;&amp; options.data['partial-block'];
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;
  if (options.fn &amp;&amp; options.fn !== noop) {
    (function () {
      options.data = _base.createFrame(options.data);
      // Wrapper function to get access to currentPartialBlock from the closure
      var fn = options.fn;
      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
        var options = arguments.length &lt;= 1 || arguments[1] === undefined ? {} : arguments[1];

        // Restore the partial-block from the closure for the execution of the block
        // i.e. the part inside the block of the partial call.
        options.data = _base.createFrame(options.data);
        options.data['partial-block'] = currentPartialBlock;
        return fn(context, options);
      };
      if (fn.partials) {
        options.partials = Utils.extend({}, options.partials, fn.partials);
      }
    })();
  }

  if (partial === undefined &amp;&amp; partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths &amp;&amp; depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* global window */


exports.__esModule = true;

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
    return Handlebars;
  };
};

module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27)))

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" &amp;&amp; typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj &amp;&amp; typeof Symbol === "function" &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/* pako 1.0.4 nodeca/pako */(function(f){if(true){module.exports=f()}else if(typeof define==="function"&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.pako = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&amp;&amp;require;if(!u&amp;&amp;a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overriden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw &amp;&amp; (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip &amp;&amp; (opt.windowBits > 0) &amp;&amp; (opt.windowBits &lt; 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END &amp;&amp; status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 &amp;&amp; (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) &amp;&amp; status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":3,"./utils/strings":4,"./zlib/deflate":8,"./zlib/messages":13,"./zlib/zstream":15}],2:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw &amp;&amp; (opt.windowBits >= 0) &amp;&amp; (opt.windowBits &lt; 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) &amp;&amp; (opt.windowBits &lt; 16) &amp;&amp;
      !(options &amp;&amp; options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) &amp;&amp; (opt.windowBits &lt; 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits &amp; 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT &amp;&amp; dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR &amp;&amp; allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END &amp;&amp; status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 &amp;&amp; (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 &amp;&amp; strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) &amp;&amp; status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue &amp; convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":3,"./utils/strings":4,"./zlib/constants":6,"./zlib/gzheader":9,"./zlib/inflate":11,"./zlib/messages":13,"./zlib/zstream":15}],3:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &amp;&amp;
                (typeof Uint16Array !== 'undefined') &amp;&amp;
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray &amp;&amp; dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i &lt; len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i &lt; l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i &lt; l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i &lt; len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],4:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 &amp; 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q &lt; 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos &lt; str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c &amp; 0xfc00) === 0xd800 &amp;&amp; (m_pos + 1 &lt; str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 &amp; 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) &lt;&lt; 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c &lt; 0x80 ? 1 : c &lt; 0x800 ? 2 : c &lt; 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i &lt; buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c &amp; 0xfc00) === 0xd800 &amp;&amp; (m_pos + 1 &lt; str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 &amp; 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) &lt;&lt; 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c &lt; 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c &lt; 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c &amp; 0x3f);
    } else if (c &lt; 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 &amp; 0x3f);
      buf[i++] = 0x80 | (c &amp; 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 &amp; 0x3f);
      buf[i++] = 0x80 | (c >>> 6 &amp; 0x3f);
      buf[i++] = 0x80 | (c &amp; 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len &lt; 65537) {
    if ((buf.subarray &amp;&amp; STR_APPLY_UIA_OK) || (!buf.subarray &amp;&amp; STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i &lt; len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i &lt; len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i &lt; len;) {
    c = buf[i++];
    // quick process ascii
    if (c &lt; 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 &amp; 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &amp;= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 &amp;&amp; i &lt; len) {
      c = (c &lt;&lt; 6) | (buf[i++] &amp; 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c &lt; 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) &amp; 0x3ff);
      utf16buf[out++] = 0xdc00 | (c &amp; 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 &amp;&amp; (buf[pos] &amp; 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos &lt; 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":3}],5:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

function adler32(adler, buf, len, pos) {
  var s1 = (adler &amp; 0xffff) |0,
      s2 = ((adler >>> 16) &amp; 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 &lt;&lt; 16)) |0;
}


module.exports = adler32;

},{}],6:[function(require,module,exports){
'use strict';


module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],7:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.


// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n &lt; 256; n++) {
    c = n;
    for (var k = 0; k &lt; 8; k++) {
      c = ((c &amp; 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i &lt; end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) &amp; 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],8:[function(require,module,exports){
'use strict';

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) &lt;&lt; 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b &amp; 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) &amp; 0xff;
  s.pending_buf[s.pending++] = b &amp; 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes &lt;= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 &amp;&amp; MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart &lt;= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match &lt; s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp;
             _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp;
             _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp;
             _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp;
             scan &lt; strend);

    // Assert(scan &lt;= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match &amp; wmask]) > limit &amp;&amp; --chain_length !== 0);

  if (best_len &lt;= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead &lt; MIN_LOOKAHEAD
 * OUT assertions: strstart &lt;= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead &lt; MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) &lt;= 2) {
    //    if (more == 0 &amp;&amp; s->strstart == 0 &amp;&amp; s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 &amp;&amp; lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart &lt;= WSIZE+MAX_DIST-1 &amp;&amp; lookahead &lt;= MIN_LOOKAHEAD - 1 &amp;&amp;
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &amp;&amp;
     *   strstart + s->lookahead &lt;= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more &lt; 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[str + 1]) &amp; s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) &amp; s.hash_mask;

        s.prev[str &amp; s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert &lt; MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead &lt; MIN_LOOKAHEAD &amp;&amp; s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water &lt; s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water &lt; curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water &lt; (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart &lt;= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead &lt;= 1) {

      //Assert(s->strstart &lt; s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart &lt; s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 &amp;&amp; flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start &lt; 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead &lt; MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead &lt; MIN_LOOKAHEAD &amp;&amp; flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) &amp; s.hash_mask;
      hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those &lt;= prev_length.
     * At this point we have always match_length &lt; MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ &amp;&amp; ((s.strstart - hash_head) &lt;= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length &lt;= s.max_lazy_match/*max_insert_length*/ &amp;&amp; s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) &amp; s.hash_mask;
          hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + 1]) &amp; s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead &lt; MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart &lt; (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead &lt; MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead &lt; MIN_LOOKAHEAD &amp;&amp; flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) &amp; s.hash_mask;
      hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those &lt;= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ &amp;&amp; s.prev_length &lt; s.max_lazy_match &amp;&amp;
        s.strstart - hash_head &lt;= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length &lt;= 5 &amp;&amp;
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH &amp;&amp; s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH &amp;&amp; s.match_length &lt;= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart &lt;= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) &amp; s.hash_mask;
          hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart &lt; MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead &lt;= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead &lt;= MAX_MATCH &amp;&amp; flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH &amp;&amp; s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp; prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp;
                 prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp;
                 prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp;
                 prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp;
                 scan &lt; strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan &lt;= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels &lt;= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap &lt; 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits &lt; 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel &lt; 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits &lt; 8 || windowBits > 15 || level &lt; 0 || level > 9 ||
    strategy &lt; 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 &lt;&lt; s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 &lt;&lt; s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 &lt;&lt; (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush &lt; 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input &amp;&amp; strm.avail_in !== 0) ||
      (s.status === FINISH_STATE &amp;&amp; flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level &lt; 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time &amp; 0xff);
        put_byte(s, (s.gzhead.time >> 8) &amp; 0xff);
        put_byte(s, (s.gzhead.time >> 16) &amp; 0xff);
        put_byte(s, (s.gzhead.time >> 24) &amp; 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level &lt; 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os &amp; 0xff);
        if (s.gzhead.extra &amp;&amp; s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length &amp; 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) &amp; 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) &lt;&lt; 4)) &lt;&lt; 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level &lt; 2) {
        level_flags = 0;
      } else if (s.level &lt; 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags &lt;&lt; 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler &amp; 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex &lt; (s.gzhead.extra.length &amp; 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc &amp;&amp; s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] &amp; 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc &amp;&amp; s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc &amp;&amp; s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex &lt; s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) &amp; 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc &amp;&amp; s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc &amp;&amp; s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex &lt; s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) &amp; 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc &amp;&amp; s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 &lt;= s.pending_buf_size) {
        put_byte(s, strm.adler &amp; 0xff);
        put_byte(s, (strm.adler >> 8) &amp; 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 &amp;&amp; rank(flush) &lt;= rank(old_flush) &amp;&amp;
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE &amp;&amp; strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH &amp;&amp; s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH &amp;&amp; avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out &lt;= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap &lt;= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler &amp; 0xff);
    put_byte(s, (strm.adler >> 8) &amp; 0xff);
    put_byte(s, (strm.adler >> 16) &amp; 0xff);
    put_byte(s, (strm.adler >> 24) &amp; 0xff);
    put_byte(s, strm.total_in &amp; 0xff);
    put_byte(s, (strm.total_in >> 8) &amp; 0xff);
    put_byte(s, (strm.total_in >> 16) &amp; 0xff);
    put_byte(s, (strm.total_in >> 24) &amp; 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler &amp; 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &amp;&amp;
    status !== EXTRA_STATE &amp;&amp;
    status !== NAME_STATE &amp;&amp;
    status !== COMMENT_STATE &amp;&amp;
    status !== HCRC_STATE &amp;&amp;
    status !== BUSY_STATE &amp;&amp;
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 &amp;&amp; s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) &amp; s.hash_mask;

      s.prev[str &amp; s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":3,"./adler32":5,"./crc32":7,"./messages":13,"./trees":14}],9:[function(require,module,exports){
'use strict';


function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],10:[function(require,module,exports){
'use strict';

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits &lt; 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in &lt; last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out &lt; end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 &lt;&lt; state.lenbits) - 1;
  dmask = (1 &lt;&lt; state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits &lt; 15) {
      hold += input[_in++] &lt;&lt; bits;
      bits += 8;
      hold += input[_in++] &lt;&lt; bits;
      bits += 8;
    }

    here = lcode[hold &amp; lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) &amp; 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 &amp;&amp; here.val &lt; 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here &amp; 0xffff/*here.val*/;
      }
      else if (op &amp; 16) {                     /* length base */
        len = here &amp; 0xffff/*here.val*/;
        op &amp;= 15;                           /* number of extra bits */
        if (op) {
          if (bits &lt; op) {
            hold += input[_in++] &lt;&lt; bits;
            bits += 8;
          }
          len += hold &amp; ((1 &lt;&lt; op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits &lt; 15) {
          hold += input[_in++] &lt;&lt; bits;
          bits += 8;
          hold += input[_in++] &lt;&lt; bits;
          bits += 8;
        }
        here = dcode[hold &amp; dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) &amp; 0xff/*here.op*/;

          if (op &amp; 16) {                      /* distance base */
            dist = here &amp; 0xffff/*here.val*/;
            op &amp;= 15;                       /* number of extra bits */
            if (bits &lt; op) {
              hold += input[_in++] &lt;&lt; bits;
              bits += 8;
              if (bits &lt; op) {
                hold += input[_in++] &lt;&lt; bits;
                bits += 8;
              }
            }
            dist += hold &amp; ((1 &lt;&lt; op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len &lt;= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op &lt; len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext &lt; op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op &lt; len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext &lt; len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op &lt; len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op &amp; 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here &amp; 0xffff)/*here.val*/ + (hold &amp; ((1 &lt;&lt; op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op &amp; 64) === 0) {              /* 2nd level length code */
        here = lcode[(here &amp; 0xffff)/*here.val*/ + (hold &amp; ((1 &lt;&lt; op) - 1))];
        continue dolen;
      }
      else if (op &amp; 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in &lt; last &amp;&amp; _out &lt; end);

  /* return unused bytes (on entry, bits &lt; 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len &lt;&lt; 3;
  hold &amp;= (1 &lt;&lt; bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in &lt; last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out &lt; end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],11:[function(require,module,exports){
'use strict';


var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) &amp; 0xff) +
          ((q >>> 8) &amp; 0xff00) +
          ((q &amp; 0xff00) &lt;&lt; 8) +
          ((q &amp; 0xff) &lt;&lt; 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap &amp; 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits &lt; 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits &lt; 48) {
      windowBits &amp;= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits &amp;&amp; (windowBits &lt; 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null &amp;&amp; state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym &lt; 144) { state.lens[sym++] = 8; }
    while (sym &lt; 256) { state.lens[sym++] = 9; }
    while (sym &lt; 280) { state.lens[sym++] = 7; }
    while (sym &lt; 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym &lt; 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 &lt;&lt; state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave &lt; state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input &amp;&amp; strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits &lt; 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] &lt;&lt; bits;
        bits += 8;
      }
      //===//
      if ((state.wrap &amp; 2) &amp;&amp; hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold &amp; 0xff;
        hbuf[1] = (hold >>> 8) &amp; 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap &amp; 1) ||   /* check if zlib header allowed */
        (((hold &amp; 0xff)/*BITS(8)*/ &lt;&lt; 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold &amp; 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold &amp; 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 &lt;&lt; len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold &amp; 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits &lt; 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] &lt;&lt; bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags &amp; 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags &amp; 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) &amp; 1);
      }
      if (state.flags &amp; 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold &amp; 0xff;
        hbuf[1] = (hold >>> 8) &amp; 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits &lt; 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] &lt;&lt; bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags &amp; 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold &amp; 0xff;
        hbuf[1] = (hold >>> 8) &amp; 0xff;
        hbuf[2] = (hold >>> 16) &amp; 0xff;
        hbuf[3] = (hold >>> 24) &amp; 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits &lt; 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] &lt;&lt; bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold &amp; 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags &amp; 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold &amp; 0xff;
        hbuf[1] = (hold >>> 8) &amp; 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags &amp; 0x0400) {
        //=== NEEDBITS(16); */
        while (bits &lt; 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] &lt;&lt; bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags &amp; 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold &amp; 0xff;
          hbuf[1] = (hold >>> 8) &amp; 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags &amp; 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags &amp; 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags &amp; 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head &amp;&amp; len &amp;&amp;
              (state.length &lt; 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len &amp;&amp; copy &lt; have);

        if (state.flags &amp; 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags &amp; 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head &amp;&amp; len &amp;&amp;
              (state.length &lt; 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len &amp;&amp; copy &lt; have);
        if (state.flags &amp; 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags &amp; 0x0200) {
        //=== NEEDBITS(16); */
        while (bits &lt; 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] &lt;&lt; bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check &amp; 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) &amp; 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits &lt; 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] &lt;&lt; bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits &amp; 7;
        bits -= bits &amp; 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits &lt; 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] &lt;&lt; bits;
        bits += 8;
      }
      //===//
      state.last = (hold &amp; 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold &amp; 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits &amp; 7;
      bits -= bits &amp; 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits &lt; 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] &lt;&lt; bits;
        bits += 8;
      }
      //===//
      if ((hold &amp; 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold &amp; 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits &lt; 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] &lt;&lt; bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold &amp; 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold &amp; 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold &amp; 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have &lt; state.ncode) {
        //=== NEEDBITS(3);
        while (bits &lt; 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] &lt;&lt; bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold &amp; 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have &lt; 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables &amp; no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have &lt; state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold &amp; ((1 &lt;&lt; state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) &amp; 0xff;
          here_val = here &amp; 0xffff;

          if ((here_bits) &lt;= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] &lt;&lt; bits;
          bits += 8;
          //---//
        }
        if (here_val &lt; 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits &lt; n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] &lt;&lt; bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold &amp; 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits &lt; n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] &lt;&lt; bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold &amp; 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits &lt; n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] &lt;&lt; bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold &amp; 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables &amp; no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables &amp; no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 &amp;&amp; left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold &amp; ((1 &lt;&lt; state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) &amp; 0xff;
        here_val = here &amp; 0xffff;

        if (here_bits &lt;= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] &lt;&lt; bits;
        bits += 8;
        //---//
      }
      if (here_op &amp;&amp; (here_op &amp; 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold &amp; ((1 &lt;&lt; (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) &amp; 0xff;
          here_val = here &amp; 0xffff;

          if ((last_bits + here_bits) &lt;= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] &lt;&lt; bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 &amp;&amp; here.val &lt; 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op &amp; 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op &amp; 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op &amp; 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits &lt; n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] &lt;&lt; bits;
          bits += 8;
        }
        //===//
        state.length += hold &amp; ((1 &lt;&lt; state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold &amp; ((1 &lt;&lt; state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) &amp; 0xff;
        here_val = here &amp; 0xffff;

        if ((here_bits) &lt;= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] &lt;&lt; bits;
        bits += 8;
        //---//
      }
      if ((here_op &amp; 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold &amp; ((1 &lt;&lt; (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) &amp; 0xff;
          here_val = here &amp; 0xffff;

          if ((last_bits + here_bits) &lt;= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] &lt;&lt; bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op &amp; 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) &amp; 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits &lt; n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] &lt;&lt; bits;
          bits += 8;
        }
        //===//
        state.offset += hold &amp; ((1 &lt;&lt; state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits &lt; 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] &lt;&lt; bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap &amp;&amp; state.flags) {
        //=== NEEDBITS(32);
        while (bits &lt; 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] &lt;&lt; bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total &amp; 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave &lt;- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out &amp;&amp; state.mode &lt; BAD &amp;&amp;
                      (state.mode &lt; CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap &amp;&amp; _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 &amp;&amp; _out === 0) || flush === Z_FINISH) &amp;&amp; ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap &amp; 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 &amp;&amp; state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":3,"./adler32":5,"./crc32":7,"./inffast":10,"./inftrees":12}],12:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len &lt;= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym &lt; codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 &lt;&lt; 24) | (64 &lt;&lt; 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 &lt;&lt; 24) | (64 &lt;&lt; 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min &lt; max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root &lt; min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len &lt;= MAXBITS; len++) {
    left &lt;&lt;= 1;
    left -= count[len];
    if (left &lt; 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 &amp;&amp; (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len &lt; MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym &lt; codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 &lt;&lt; root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS &amp;&amp; used > ENOUGH_LENS) ||
    (type === DISTS &amp;&amp; used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] &lt; end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 &lt;&lt; (len - drop);
    fill = 1 &lt;&lt; curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits &lt;&lt; 24) | (here_op &lt;&lt; 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 &lt;&lt; (len - 1);
    while (huff &amp; incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &amp;= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root &amp;&amp; (huff &amp; mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 &lt;&lt; curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 &lt;&lt; curr;
      while (curr + drop &lt; max) {
        left -= count[curr + drop];
        if (left &lt;= 0) { break; }
        curr++;
        left &lt;&lt;= 1;
      }

      /* check for enough space */
      used += 1 &lt;&lt; curr;
      if ((type === LENS &amp;&amp; used > ENOUGH_LENS) ||
        (type === DISTS &amp;&amp; used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff &amp; mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root &lt;&lt; 24) | (curr &lt;&lt; 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) &lt;&lt; 24) | (64 &lt;&lt; 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":3}],13:[function(require,module,exports){
'use strict';

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],14:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree &amp;&amp; static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist &lt; 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) &amp; 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) &amp; 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) &amp; 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length &lt;= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value &lt;&lt; s.bi_valid) &amp; 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value &lt;&lt; s.bi_valid) &amp; 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 &lt;= len &lt;= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code &amp; 1;
    code >>>= 1;
    res &lt;&lt;= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf &amp; 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits &lt;= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h &lt; HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits &lt;= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) &lt;&lt; 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1&lt;&lt;MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n &lt;= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code &lt; LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n &lt; (1 &lt;&lt; extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code &lt; 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n &lt; (1 &lt;&lt; extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code &lt; D_CODES; code++) {
    base_dist[code] = dist &lt;&lt; 7;
    for (n = 0; n &lt; (1 &lt;&lt; (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits &lt;= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n &lt;= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n &lt;= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n &lt;= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n &lt;= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n &lt; D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n &lt; L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n &lt; D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n &lt; BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ &lt; tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ &amp;&amp; depth[n] &lt;= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k &lt;&lt; 1;  /* left son of k */
  while (j &lt;= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j &lt; s.heap_len &amp;&amp;
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j &lt;&lt;= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] &lt;&lt; 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code &lt; D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) &lt; s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx &lt; s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n &lt; elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len &lt; 2) {
    node = s.heap[++s.heap_len] = (max_code &lt; 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n &lt;= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count &lt; max_count &amp;&amp; curlen === nextlen) {
      continue;

    } else if (count &lt; min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count &lt;= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n &lt;= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count &lt; max_count &amp;&amp; curlen === nextlen) {
      continue;

    } else if (count &lt; min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 &amp;&amp; count &lt;= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count &lt;= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 &amp;&amp; dcodes >= 1 &amp;&amp; blcodes >= 4, "not enough codes");
  //Assert (lcodes &lt;= L_CODES &amp;&amp; dcodes &lt;= D_CODES &amp;&amp; blcodes &lt;= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank &lt; blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n &lt;= 31; n++, black_mask >>>= 1) {
    if ((black_mask &amp; 1) &amp;&amp; (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n &lt; LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK &lt;&lt; 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES &lt;&lt; 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb &lt;= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 &lt;= opt_lenb) &amp;&amp; (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES &lt;&lt; 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES &lt;&lt; 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) &amp; 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist &amp; 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc &amp; 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist &lt; (ush)MAX_DIST(s) &amp;&amp;
    //       (ush)lc &lt;= (ush)(MAX_MATCH-MIN_MATCH) &amp;&amp;
    //       (ush)d_code(dist) &lt; (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit &amp; 0x1fff) === 0 &amp;&amp; s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode &lt; D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches &lt; (s.last_lit>>1)/*int /2*/ &amp;&amp; out_length &lt; (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":3}],15:[function(require,module,exports){
'use strict';


function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],"/":[function(require,module,exports){
// Top level file is just a mixin of submodules &amp; constants
'use strict';

var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":1,"./lib/inflate":2,"./lib/utils/common":3,"./lib/zlib/constants":6}]},{},[])("/")
});

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Created by AHonyakov on 09.06.2017.
 */

/**
 * Объект конфига
 * @type {{name: string, caption: string, defaultUrl: string, version: string, authGoogle: boolean, mainPage: string}}
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
var config = exports.config = {
  name: 'test',
  caption: 'ИС Того сего',
  defaultUrl: 'https://gag.groupstp.ru:8809',
  version: 'not your busy',
  authGoogle: true,
  mainPage: 'main.html'
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var jQuery = __webpack_require__(1);

/*!
 * Bootstrap v3.3.7 (http://getbootstrap.com)
 * Copyright 2011-2017 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

/*!
 * Generated using the Bootstrap Customizer (http://bootstrap-3.ru/customize.php?id=d0951f8a6191619e7c8614d48225cee2)
 * Config saved to config.json and https://gist.github.com/d0951f8a6191619e7c8614d48225cee2
 */
if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery')
}
+function ($) {
  'use strict';
  var version = $.fn.jquery.split(' ')[0].split('.')
  if ((version[0] &lt; 2 &amp;&amp; version[1] &lt; 9) || (version[0] == 1 &amp;&amp; version[1] == 9 &amp;&amp; version[2] &lt; 1)) {
    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher')
  }
}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.3.7
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.3.7'

  Alert.TRANSITION_DURATION = 150

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector &amp;&amp; selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector === '#' ? [] : selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition &amp;&amp; $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.3.7
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }

  Button.VERSION  = '3.3.7'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state += 'Text'

    if (data.resetText == null) $el.data('resetText', $el[val]())

    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state])

      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d).prop(d, true)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d).prop(d, false)
      }
    }, this), 0)
  }

  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked')) changed = false
        $parent.find('.active').removeClass('active')
        this.$element.addClass('active')
      } else if ($input.prop('type') == 'checkbox') {
        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
        this.$element.toggleClass('active')
      }
      $input.prop('checked', this.$element.hasClass('active'))
      if (changed) $input.trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
      this.$element.toggleClass('active')
    }
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' &amp;&amp; option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  var old = $.fn.button

  $.fn.button             = Plugin
  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target).closest('.btn')
      Plugin.call($btn, 'toggle')
      if (!($(e.target).is('input[type="radio"], input[type="checkbox"]'))) {
        // Prevent double click on radios, and the double selections (so cancellation) on checkboxes
        e.preventDefault()
        // The target component still receive the focus
        if ($btn.is('input,button')) $btn.trigger('focus')
        else $btn.find('input:visible,button:visible').first().trigger('focus')
      }
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
    })

}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.3.7
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      = null
    this.sliding     = null
    this.interval    = null
    this.$active     = null
    this.$items      = null

    this.options.keyboard &amp;&amp; this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' &amp;&amp; !('ontouchstart' in document.documentElement) &amp;&amp; this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.7'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName)) return
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval &amp;&amp; clearInterval(this.interval)

    this.options.interval
      &amp;&amp; !this.paused
      &amp;&amp; (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active)
    var willWrap = (direction == 'prev' &amp;&amp; activeIndex === 0)
                || (direction == 'next' &amp;&amp; activeIndex == (this.$items.length - 1))
    if (willWrap &amp;&amp; !this.options.wrap) return active
    var delta = direction == 'prev' ? -1 : 1
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos &lt; 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length &amp;&amp; $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var that      = this

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling &amp;&amp; this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator &amp;&amp; $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition &amp;&amp; this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling &amp;&amp; this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' &amp;&amp; option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) &amp;&amp; href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.3.7
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.7'

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector &amp;&amp; /#[A-Za-z]/.test(selector) &amp;&amp; selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector &amp;&amp; $(selector)

    return $parent &amp;&amp; $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
    if (e &amp;&amp; e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      if (e &amp;&amp; e.type == 'click' &amp;&amp; /input|textarea/i.test(e.target.tagName) &amp;&amp; $.contains($parent[0], e.target)) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
    })
  }

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement &amp;&amp; !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $(document.createElement('div'))
          .addClass('dropdown-backdrop')
          .insertAfter($(this))
          .on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger($.Event('shown.bs.dropdown', relatedTarget))
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if (!isActive &amp;&amp; e.which != 27 || isActive &amp;&amp; e.which == 27) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('.dropdown-menu' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 &amp;&amp; index > 0)                 index--         // up
    if (e.which == 40 &amp;&amp; index &lt; $items.length - 1) index++         // down
    if (!~index)                                    index = 0

    $items.eq(index).trigger('focus')
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.3.7
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options             = options
    this.$body               = $(document.body)
    this.$element            = $(element)
    this.$dialog             = this.$element.find('.modal-dialog')
    this.$backdrop           = null
    this.isShown             = null
    this.originalBodyPad     = null
    this.scrollbarWidth      = 0
    this.ignoreBackdropClick = false

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.7'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')

    this.escape()
    this.resize()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
      })
    })

    this.backdrop(function () {
      var transition = $.support.transition &amp;&amp; that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      that.adjustDialog()

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element.addClass('in')

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()
    this.resize()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .off('click.dismiss.bs.modal')
      .off('mouseup.dismiss.bs.modal')

    this.$dialog.off('mousedown.dismiss.bs.modal')

    $.support.transition &amp;&amp; this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (document !== e.target &amp;&amp;
            this.$element[0] !== e.target &amp;&amp;
            !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown &amp;&amp; this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 &amp;&amp; this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop &amp;&amp; this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown &amp;&amp; this.options.backdrop) {
      var doAnimate = $.support.transition &amp;&amp; animate

      this.$backdrop = $(document.createElement('div'))
        .addClass('modal-backdrop ' + animate)
        .appendTo(this.$body)

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false
          return
        }
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus()
          : this.hide()
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown &amp;&amp; this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback &amp;&amp; callback()
      }
      $.support.transition &amp;&amp; this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  // these following methods are used to handle overflowing modals

  Modal.prototype.handleUpdate = function () {
    this.adjustDialog()
  }

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

    this.$element.css({
      paddingLeft:  !this.bodyIsOverflowing &amp;&amp; modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing &amp;&amp; !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth
    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect()
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
    }
    this.bodyIsOverflowing = document.body.clientWidth &lt; fullWindowWidth
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    this.originalBodyPad = document.body.style.paddingRight || ''
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad)
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' &amp;&amp; option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href &amp;&amp; href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) &amp;&amp; href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') &amp;&amp; $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.3.7
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       = null
    this.options    = null
    this.enabled    = null
    this.timeout    = null
    this.hoverState = null
    this.$element   = null
    this.inState    = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.7'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '&lt;div class="tooltip" role="tooltip">&lt;div class="tooltip-arrow">&lt;/div>&lt;div class="tooltip-inner">&lt;/div>&lt;/div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport &amp;&amp; $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
    this.inState   = { click: false, hover: false, focus: false }

    if (this.$element[0] instanceof document.constructor &amp;&amp; !this.options.selector) {
      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
    }

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay &amp;&amp; typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options &amp;&amp; $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
    }

    if (self.tip().hasClass('in') || self.hoverState == 'in') {
      self.hoverState = 'in'
      return
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.isInStateTrue = function () {
    for (var key in this.inState) {
      if (this.inState[key]) return true
    }

    return false
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
    }

    if (self.isInStateTrue()) return

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() &amp;&amp; this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
      this.$element.trigger('inserted.bs.' + this.type)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var viewportDim = this.getPosition(this.$viewport)

        placement = placement == 'bottom' &amp;&amp; pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :
                    placement == 'top'    &amp;&amp; pos.top    - actualHeight &lt; viewportDim.top    ? 'bottom' :
                    placement == 'right'  &amp;&amp; pos.right  + actualWidth  > viewportDim.width  ? 'left'   :
                    placement == 'left'   &amp;&amp; pos.left   - actualWidth  &lt; viewportDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition &amp;&amp; this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  += marginTop
    offset.left += marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' &amp;&amp; actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
    this.arrow()
      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isVertical ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = $(this.$tip)
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      if (that.$element) { // TODO: Check whether guarding this code with this `if` is really necessary.
        that.$element
          .removeAttr('aria-describedby')
          .trigger('hidden.bs.' + that.type)
      }
      callback &amp;&amp; callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition &amp;&amp; $tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var isSvg = window.SVGElement &amp;&amp; el instanceof window.SVGElement
    // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.
    // See https://github.com/twbs/bootstrap/issues/20280
    var elOffset  = isBody ? { top: 0, left: 0 } : (isSvg ? null : $element.offset())
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport &amp;&amp; this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset &lt; viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset &lt; viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    if (!this.$tip) {
      this.$tip = $(this.options.template)
      if (this.$tip.length != 1) {
        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
      }
    }
    return this.$tip
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    if (e) {
      self.inState.click = !self.inState.click
      if (self.isInStateTrue()) self.enter(self)
      else self.leave(self)
    } else {
      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
    }
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
      if (that.$tip) {
        that.$tip.detach()
      }
      that.$tip = null
      that.$arrow = null
      that.$viewport = null
      that.$element = null
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.tooltip')
      var options = typeof option == 'object' &amp;&amp; option

      if (!data &amp;&amp; /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.3.7
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.7'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '&lt;div class="popover" role="tooltip">&lt;div class="arrow">&lt;/div>&lt;h3 class="popover-title">&lt;/h3>&lt;div class="popover-content">&lt;/div>&lt;/div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.popover')
      var options = typeof option == 'object' &amp;&amp; option

      if (!data &amp;&amp; /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.3.7
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    // jscs:disable requireDollarBeforejQueryAssignment
    this.element = $(element)
    // jscs:enable requireDollarBeforejQueryAssignment
  }

  Tab.VERSION = '3.3.7'

  Tab.TRANSITION_DURATION = 150

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector &amp;&amp; selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })

    $previous.trigger(hideEvent)
    $this.trigger(showEvent)

    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      &amp;&amp; $.support.transition
      &amp;&amp; ($active.length &amp;&amp; $active.hasClass('fade') || !!container.find('> .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
          .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', false)

      element
        .addClass('active')
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu').length) {
        element
          .closest('li.dropdown')
            .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)
      }

      callback &amp;&amp; callback()
    }

    $active.length &amp;&amp; transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  var clickHandler = function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }

  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.3.7
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      = null
    this.unpin        = null
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.7'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null &amp;&amp; this.affixed == 'top') return scrollTop &lt; offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin &lt;= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight &lt;= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null &amp;&amp; scrollTop &lt;= offsetTop) return 'top'
    if (offsetBottom != null &amp;&amp; (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = Math.max($(document).height(), $(document.body).height())

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' &amp;&amp; option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.3.7
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

/* jshint latedef: false */

+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.7'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent &amp;&amp; this.$parent.children('.panel').children('.in, .collapsing')

    if (actives &amp;&amp; actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData &amp;&amp; activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives &amp;&amp; actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) &amp;&amp; href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' &amp;&amp; option)

      if (!data &amp;&amp; options.toggle &amp;&amp; /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()

    Plugin.call($target, option)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.7
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    this.$body          = $(document.body)
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0

    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
    this.refresh()
    this.process()
  }

  ScrollSpy.VERSION  = '3.3.7'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }

  ScrollSpy.prototype.refresh = function () {
    var that          = this
    var offsetMethod  = 'offset'
    var offsetBase    = 0

    this.offsets      = []
    this.targets      = []
    this.scrollHeight = this.getScrollHeight()

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }

    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) &amp;&amp; $(href)

        return ($href
          &amp;&amp; $href.length
          &amp;&amp; $href.is(':visible')
          &amp;&amp; [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        that.offsets.push(this[0])
        that.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) &amp;&amp; this.activate(i)
    }

    if (activeTarget &amp;&amp; scrollTop &lt; offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        &amp;&amp; scrollTop >= offsets[i]
        &amp;&amp; (offsets[i + 1] === undefined || scrollTop &lt; offsets[i + 1])
        &amp;&amp; this.activate(targets[i])
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    this.clear()

    var selector = this.selector +
      '[data-target="' + target + '"],' +
      this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }

  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' &amp;&amp; option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.scrollspy

  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.3.7
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);



/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Component = exports.Component = function () {
    function Component(options) {
        _classCallCheck(this, Component);

        this.box = options.box || null;
        // ссылка на родительский элемент
        this.parent = options.parent || null;
        //в случае пустот
        options.element = options.element || {};
        options.element.properties = options.element.properties || {};
        // собятия элемента, объект с именем события и именем обработчика события
        this.events = options.element.events || null;
        // объект с именем обработчика события и кодом этого обработчика
        this.code = this.prepareCode(options.code) || {};
        // данные компонента
        this.content = options.content || [];
        //идентификатор
        this.id = options.element.id;
        //массив деток, нужен для каскадного обновления
        this.children = [];
        //записываемся в дети родителю
        this.recInChildren();
        //тип и имя объекта для которго строится компонент
        this.object = options.element.properties.object || "";
        this.name = options.element.properties.name || "";
    }

    /**
     * Записывает объект в дети текущего объекта
     * @param child - объект
     */


    _createClass(Component, [{
        key: "addChildren",
        value: function addChildren(child) {
            this.children.push(child);
        }

        /**
         * Функция записывает объект в дети к родителю
         */

    }, {
        key: "recInChildren",
        value: function recInChildren() {
            if (this.parent !== null) {
                this.parent.addChildren(this);
            }
        }

        /**
         * Выделение записей и внешних ключей из content
         * @param contentArr - массив контента
         * @returns {{}}
         */

    }, {
        key: "prepareData",
        value: function prepareData(contentArr) {
            var _this = this;

            var content = {};
            contentArr.forEach(function (item) {
                item.forId.forEach(function (id) {
                    if (id === _this.id) {
                        content.records = item.records || [];
                        content.fk = item.fk || {};
                    }
                });
            });
            return content;
        }
    }, {
        key: "eventHandler",
        value: function eventHandler(event) {

            var type = event.type;
            var handlerName = this.events[type];
            if (!handlerName) return;

            var handler = this.code[handlerName];
            if (!handler) return;

            // в качестве параметра передаем сам элемент
            handler.apply(this, [this]);
        }
    }, {
        key: "addHandlers",
        value: function addHandlers() {
            for (var eventName in this.events) {
                this.box.addEventListener(eventName, this.eventHandler.bind(this));
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.box.innerHTML = '';
            delete stpui[this.id];
            if (w2ui[this.id] !== undefined) {
                w2ui[this.id].destroy();
            }
        }

        /**
         * Преобразует код из строки
         * @param oldCode
         * @returns {{}}
         * @private
         */

    }, {
        key: "prepareCode",
        value: function prepareCode(oldCode) {
            var newCode = {};
            for (var funcName in oldCode) {
                var func = new Function('return ' + oldCode[funcName]);
                newCode[funcName] = func();
            }
            return newCode;
        }

        /**
         * Активирует событие на элементе
         */

    }, {
        key: "trigger",
        value: function trigger(eventName, data) {
            var customEvent = new CustomEvent(eventName, { detail: data });
            this.box.dispatchEvent(customEvent);
        }

        /**
         * Помещает объект в ДОМ
         */

    }, {
        key: "render",
        value: function render() {}
    }, {
        key: "reload",
        value: function reload() {
            console.log('reload ' + this.id);
        }

        /**
         * Скрыть элемент со страницы
         */

    }, {
        key: "hide",
        value: function hide() {
            this.box.hidden = true;
        }

        /**
         * Отобразить скрытый элемент на странице
         */

    }, {
        key: "show",
        value: function show() {
            this.box.hidden = false;
        }

        /**
         *  Сделать элемент доступным для редактирования
         */

    }, {
        key: "enable",
        value: function enable() {}

        /**
         *  Сделать элемент недоступным для редактирования
         */

    }, {
        key: "disable",
        value: function disable() {}

        /**
         * Обновить отображение объекта, нужно для в2уи в процессе скрытия/отображения
         */

    }, {
        key: "refresh",
        value: function refresh() {}

        /**
         * Делает ассоциативный массив
         * @param array - массив
         * @param key - ключ
         * @returns {{}}
         * @private
         */

    }, {
        key: "makeAsos",
        value: function makeAsos(array, key) {
            var res = {};
            for (var i in array) {
                res[array[i][key]] = array[i];
            }
            return res;
        }

        /**
         * Из формата, пришедшего с сервера, добирвает нужные поля объекта
         * @param attributes
         */

    }, {
        key: "getAttributes",
        value: function getAttributes(attributes) {}

        /**
         * Записывает объект в глобальную переменную
         * @param id
         */

    }, {
        key: "saveInWindow",
        value: function saveInWindow() {
            var id = arguments.length > 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : this.id;

            if (window.stpui === undefined) {
                window.stpui = {};
            }
            window.stpui[id] = this;
        }

        /**
         * Функция для совместимости с мобильным приложением
         * @returns {Component}
         */

    }, {
        key: "getProperties",
        value: function getProperties() {
            return this;
        }
    }]);

    return Component;
}();

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(jQuery) {/**
 * Created by AHonyakov on 02.06.2017.
 */


//подключаем стили - можно создать несколько точек входа для каждого файла стилей

__webpack_require__(11);

__webpack_require__(8);

var _index = __webpack_require__(33);

var _index2 = _interopRequireDefault(_index);

var _index3 = __webpack_require__(36);

var _index4 = _interopRequireDefault(_index3);

var _config = __webpack_require__(29);

var _index5 = __webpack_require__(3);

var tools = _interopRequireWildcard(_index5);

__webpack_require__(43);

function _interopRequireWildcard(obj) { if (obj &amp;&amp; obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

//еще немного скриптов
__webpack_require__(30);
//подключаем меню, причем сразу же

//подключаем менеджер страниц

//подключаем конфиг

//подключаем тулзы

//подключаем библиотеку w2ui и экспортируем переменные из нее
var w2lib = __webpack_require__(44);
//подключаем стили

//импортированные переменные делаем доступными всюду, в том числе jQuery;
window.w2popup = w2lib.w2popup;
window.w2alert = w2lib.w2alert;
window.w2ui = w2lib.w2ui;
window.w2utils = w2lib.w2utils;
window.w2confirm = w2lib.w2confirm;
window.jQuery = jQuery;

//проверка токена
var token = new tools.tokenAuth(_config.config.name).checkToken();
if (token === undefined) {
    document.location.href = 'index.html';
}
var ruLocale = __webpack_require__(45);
w2utils.locale(ruLocale);
//строим меню
var info = JSON.parse(localStorage[_config.config.name + '_ObjInfo']);
var menu = new _index2.default({
    name: _config.config.caption,
    place: 'topMenu',
    objInfo: info
});
var containerDiv = document.getElementById('container');
//строим менеджер страниц
var builder = new _index4.default({ box: containerDiv, onHome: buildMain });
console.log('builder', builder);
buildMain(builder);
//подписка на клик, роутер системы
menu.on('menuItemSelected', function (event) {
    var detail = event.detail;
    /*if (detail.obj === 'main') {
     buildMain(builder);
     }*/
    if (detail.obj === 'ref' || detail.obj === 'doc' || detail.obj === 'st') {
        var objectID = detail.obj + '&amp;' + detail.name;
        var page = builder.showPage(objectID, detail.caption);
        console.log('boxForElement', page);
        var locker = new tools.Freezer({
            place: page.generatedBox,
            message: 'Загрузка'
        });
        var mainQuery = new tools.AjaxSender({
            url: 'http://localhost:1234/get' /*'server.json'*/
            , msg: "obj=" + detail.obj + '&amp;name=' + detail.name /*''*/
            , before: function () {
                locker.lock();
            }.bind(undefined)
        });
        mainQuery.sendQuery().then(function (response) {
            locker.unlock();
            var layoutLib = __webpack_require__(9);
            var layout = new layoutLib.Layout({
                box: page.generatedBox,
                element: response.elements[0],
                content: response.content,
                code: response.code,
                parent: page
            });
        }, function (error) {
            locker.unlock();
            w2alert(error);
        });
    }
    /*кнопка выход*/
    if (detail.obj === 'exit') {
        new tools.tokenAuth(_config.config.name).exit('index.html');
    }
});

function buildMain(builder) {
    var place = builder.showPage('main', 'Главная страница').generatedBox;
    place.innerHTML = 'Главная страница!';
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {
//подключаем шаблон

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
//подключаем стили


var _menu = __webpack_require__(34);

var _menu2 = _interopRequireDefault(_menu);

__webpack_require__(35);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var menuTopFixed = function () {
    function menuTopFixed(options) {
        _classCallCheck(this, menuTopFixed);

        //идентификатор узла
        this._place = options.place;
        //бренд
        this._name = options.name;
        //пользователь
        this._user = options.objInfo.description + (options.objInfo.login !== undefined ? ' (' + options.objInfo.login + ')' : "");
        //возможные перемещения
        this.objInfo = options.objInfo;
        this._permissions = options.objInfo.permissions;
        //строим шаблон и размещаем его
        document.getElementById(this._place).innerHTML = (0, _menu2.default)({
            name: this._name,
            user: this._user,
            routes: this._permissions
        });
        //навешиваем обработчики событий
        document.getElementById(this._place).addEventListener('click', this._onMenuItemClick.bind(this));
    }

    /**
     * Обработчик событий, доступный извне
     * @param eventName - имя события
     * @param handler - функция-обработчик
     */


    _createClass(menuTopFixed, [{
        key: 'on',
        value: function on(eventName, handler) {
            document.getElementById(this._place).addEventListener(eventName, handler);
        }

        /**
         * Вызывает событие на элементе
         * @param eventName - имя события
         * @param data - что передать
         * @private
         */

    }, {
        key: '_trigger',
        value: function _trigger(eventName, data) {
            var myEvent = new CustomEvent(eventName, { detail: data });
            document.getElementById(this._place).dispatchEvent(myEvent);
        }

        /**
         * Выделяет пункт в меню
         * @param elem - выделяемый элемент
         * @private
         */

    }, {
        key: '_setSelection',
        value: function _setSelection(elem) {
            //развыделяем остальное
            var actives = $('#' + this._place + ' .active');
            for (var i = 0; i &lt; actives.length; i++) {
                actives[i].className = '';
            }
            //выделяем нужное
            elem.className = 'active';
        }
    }, {
        key: '_onMenuItemClick',
        value: function _onMenuItemClick(event) {
            //определяем ближайший элемент с доступной обработкой клика
            var elem = $(event.target).closest('[data-cl=true]');
            if (elem.length === 0) return;
            elem = elem[0];
            var dataset = elem.dataset;
            //при необходимости выделяем
            /*if (dataset.sel === 'true') {
                this._setSelection(elem)
            }*/
            //генерируем событие
            this._trigger('menuItemSelected', dataset);
        }
    }]);

    return menuTopFixed;
}();

exports.default = menuTopFixed;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var Handlebars = __webpack_require__(7);
module.exports = (Handlebars['default'] || Handlebars).template({"1":function(container,depth0,helpers,partials,data,blockParams) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = blockParams[0][0]) != null ? stack1.objects : stack1),{"name":"if","hash":{},"fn":container.program(2, data, 0, blockParams),"inverse":container.program(5, data, 0, blockParams),"data":data,"blockParams":blockParams})) != null ? stack1 : "");
},"2":function(container,depth0,helpers,partials,data,blockParams) {
    var stack1;

  return "                        &lt;li class=\"dropdown\" style=\"cursor: pointer\">\r\n                            &lt;a class=\"dropdown-toggle\" data-toggle=\"dropdown\">"
    + container.escapeExpression(container.lambda(((stack1 = blockParams[1][0]) != null ? stack1.display : stack1), depth0))
    + "\r\n                                &lt;b class=\"caret\">&lt;/b>\r\n                            &lt;/a>\r\n                            &lt;ul class=\"dropdown-menu\">\r\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = blockParams[1][0]) != null ? stack1.objects : stack1),{"name":"each","hash":{},"fn":container.program(3, data, 2, blockParams),"inverse":container.noop,"data":data,"blockParams":blockParams})) != null ? stack1 : "")
    + "                            &lt;/ul>\r\n                        &lt;/li>\r\n";
},"3":function(container,depth0,helpers,partials,data,blockParams) {
    var stack1, alias1=container.lambda, alias2=container.escapeExpression;

  return "                                    &lt;li id=\"topMenu_"
    + alias2(alias1(blockParams[2][1], depth0))
    + "_"
    + alias2(alias1(blockParams[0][1], depth0))
    + "\" style=\"cursor: pointer\" data-obj=\""
    + alias2(alias1(blockParams[2][1], depth0))
    + "\"\r\n                                        data-name=\""
    + alias2(alias1(blockParams[0][1], depth0))
    + "\" data-caption=\""
    + alias2(alias1(((stack1 = blockParams[0][0]) != null ? stack1.display : stack1), depth0))
    + "\" data-sel=true data-cl=true>&lt;a>"
    + alias2(alias1(((stack1 = blockParams[0][0]) != null ? stack1.display : stack1), depth0))
    + "&lt;/a>&lt;/li>\r\n";
},"5":function(container,depth0,helpers,partials,data,blockParams) {
    var stack1, alias1=container.lambda, alias2=container.escapeExpression;

  return "                        &lt;li id=\"topMenu_"
    + alias2(alias1(blockParams[1][1], depth0))
    + "\" style=\"cursor: pointer\" data-obj=\""
    + alias2(alias1(blockParams[1][1], depth0))
    + " \"data-sel=true data-cl=true>&lt;a>"
    + alias2(alias1(((stack1 = blockParams[1][0]) != null ? stack1.display : stack1), depth0))
    + "&lt;/a>\r\n                        &lt;/li>\r\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data,blockParams) {
    var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

  return "&lt;!-- Fixed navbar -->\r\n&lt;div class=\"navbar navbar-default navbar-fixed-top\" role=\"navigation\">\r\n    &lt;div class=\"container\">\r\n        &lt;div class=\"navbar-header\">\r\n            &lt;button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\">\r\n                &lt;span class=\"sr-only\">Toggle navigation&lt;/span>\r\n                &lt;span class=\"icon-bar\">&lt;/span>\r\n                &lt;span class=\"icon-bar\">&lt;/span>\r\n                &lt;span class=\"icon-bar\">&lt;/span>\r\n            &lt;/button>\r\n            &lt;a class=\"navbar-brand\" style=\"cursor: pointer\" data-obj=\"main\" data-sel=false data-cl=true>"
    + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data,"blockParams":blockParams}) : helper)))
    + "&lt;/a>\r\n        &lt;/div>\r\n        &lt;div class=\"navbar-collapse collapse\">\r\n            &lt;ul class=\"nav navbar-nav\">\r\n"
    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.routes : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 2, blockParams),"inverse":container.noop,"data":data,"blockParams":blockParams})) != null ? stack1 : "")
    + "            &lt;/ul>\r\n            &lt;ul class=\"nav navbar-nav navbar-right\">\r\n                &lt;li data-obj='user' data-sel=false data-cl=true>\r\n                    &lt;a>\r\n                        &lt;span class=\"glyphicon glyphicon-user\" style=\"color: #43a047\">&lt;/span> "
    + alias4(((helper = (helper = helpers.user || (depth0 != null ? depth0.user : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"user","hash":{},"data":data,"blockParams":blockParams}) : helper)))
    + "\r\n                    &lt;/a>\r\n                &lt;/li>\r\n                &lt;li style=\"cursor: pointer\" data-obj='exit' data-sel=false data-cl=true>\r\n                    &lt;a>Выход\r\n                        &lt;span class=\"glyphicon glyphicon-log-out\"\r\n                              style=\"color: #43a047;\">&lt;/span>\r\n                    &lt;/a>\r\n                &lt;/li>\r\n\r\n            &lt;/ul>\r\n        &lt;/div>&lt;!--/.nav-collapse -->\r\n    &lt;/div>\r\n&lt;/div>";
},"useData":true,"useBlockParams":true});

/***/ }),
/* 35 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _component = __webpack_require__(31);

var componentLib = _interopRequireWildcard(_component);

var _index = __webpack_require__(3);

var tools = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj &amp;&amp; obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call &amp;&amp; (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" &amp;&amp; superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Created by AHonyakov on 21.07.2017.
 * Данный класс представляет собой реализацию скелета одностраничного приложения
 */
var contentBuilder = function (_componentLib$Compone) {
    _inherits(contentBuilder, _componentLib$Compone);

    function contentBuilder(param) {
        _classCallCheck(this, contentBuilder);

        var _this = _possibleConstructorReturn(this, (contentBuilder.__proto__ || Object.getPrototypeOf(contentBuilder)).call(this, param));

        _this.pageContainer = '';
        //какая страница открыта на данный момент
        _this.current = -1;
        _this.pages = []; //массив страниц
        _this.onHome = param.onHome || null; //что делать при нажатии кнопки домой
        _this.render();
        console.log(_this);
        return _this;
    }

    /**
     * Размещает на странице тулбар и контейнер для страниц
     */


    _createClass(contentBuilder, [{
        key: 'render',
        value: function render() {
            var pageNavigator = document.createElement('div');
            pageNavigator.id = 'pageNavigator';
            pageNavigator.style.marginBottom = '5px';
            this.box.appendChild(pageNavigator);
            var pageContainer = document.createElement('div');
            pageContainer.id = 'pageContainer';
            this.box.appendChild(pageContainer);
            this.pageContainer = pageContainer;
            this.buildNavigatorToolbar(pageNavigator);
        }

        /**
         * Функция выполняет построение тулбара
         * @param place
         */

    }, {
        key: 'buildNavigatorToolbar',
        value: function buildNavigatorToolbar(place) {
            $(place).w2toolbar({
                name: 'navigatorToolbar',
                items: [{ type: 'button', id: 'buttonNavigatorBack', tooltip: 'Back', icon: 'fa fa-arrow-left', disabled: true }, { type: 'button', id: 'buttonNavigatorStr', tooltip: 'Up', icon: 'fa fa-arrow-right', disabled: true }, { type: 'button', id: 'buttonNavigatorHome', tooltip: 'Home', icon: 'fa fa-home', disabled: true }, {
                    type: 'button',
                    id: 'buttonNavigatorReload',
                    tooltip: 'Reload',
                    icon: 'fa fa-refresh',
                    disabled: false
                }, { type: 'break' }, { type: 'html', id: 'navigatorLabel', html: '&lt;b>&lt;h3>Главная страница&lt;/h3>&lt;/b>' }, { type: 'spacer' }],
                onClick: function (event) {
                    if (event.item.id === 'buttonNavigatorBack') {
                        this.current--;
                        this.pages[this.current + 1].hide();
                        this.pages[this.current].show();
                        w2ui.navigatorToolbar.set('navigatorLabel', { html: '&lt;b>&lt;h3>' + this.pages[this.current].caption + '&lt;/h3>&lt;/b>' });
                        if (this.current === 0) {
                            w2ui.navigatorToolbar.set('buttonNavigatorBack', { disabled: true });
                            w2ui.navigatorToolbar.render();
                        }
                        w2ui.navigatorToolbar.set('buttonNavigatorStr', { disabled: false });
                        w2ui.navigatorToolbar.set('buttonNavigatorHome', { disabled: false });
                        w2ui.navigatorToolbar.render();
                        this.refresh();
                    }
                    if (event.item.id === 'buttonNavigatorStr') {
                        this.current++;
                        this.pages[this.current - 1].hide();
                        this.pages[this.current].show();
                        w2ui.navigatorToolbar.set('navigatorLabel', { html: '&lt;b>&lt;h3>' + this.pages[this.current].caption + '&lt;/h3>&lt;/b>' });
                        if (this.current === this.pages.length - 1) {
                            w2ui.navigatorToolbar.set('buttonNavigatorStr', { disabled: true });
                            w2ui.navigatorToolbar.render();
                        }
                        w2ui.navigatorToolbar.set('buttonNavigatorBack', { disabled: false });
                        w2ui.navigatorToolbar.set('buttonNavigatorHome', { disabled: false });
                        w2ui.navigatorToolbar.render();
                        this.refresh();
                    }
                    if (event.item.id === 'buttonNavigatorHome') {
                        if (this.onHome !== null) {
                            this.onHome(this);
                            w2ui.navigatorToolbar.set('buttonNavigatorHome', { disabled: true });
                        }
                    }
                    if (event.item.id === 'buttonNavigatorReload') {
                        this.pages[this.current].reload();
                    }
                }.bind(this)
            });
        }

        /**
         * Выполняет обновление текущей страницы
         */

    }, {
        key: 'refresh',
        value: function refresh() {
            if (this.pages[this.current] !== undefined) this.pages[this.current].refresh();
        }

        /**
         * Показывает страниу
         * @param id
         * @param caption
         * @returns
         */

    }, {
        key: 'showPage',
        value: function showPage(id, caption) {
            //меняем подпись вверху
            w2ui.navigatorToolbar.set('navigatorLabel', { html: '&lt;b>&lt;h3>' + caption + '&lt;/h3>&lt;/b>' });
            w2ui.navigatorToolbar.refresh();
            //подгоняем стили
            this.pageContainer.style.height = document.documentElement.clientHeight - 115 + 'px';
            this.pageContainer.style.marginBottom = '15px';
            var uniq = true;
            this.current++;
            if (this.current > 0) {
                //скрываем предыдущую
                this.pages[this.current - 1].hide();
                w2ui.navigatorToolbar.set('buttonNavigatorBack', { disabled: false });
                w2ui.navigatorToolbar.set('buttonNavigatorHome', { disabled: false });
                w2ui.navigatorToolbar.render();
            }
            if (this.pages.length >= 0) {
                //убираем повторы
                for (var i in this.pages) {
                    if (this.pages[i].id === id) {
                        if (i &lt;= this.current - 1) uniq = false;
                        //удаляем страницу
                        this.pages[i].destroy();
                        //удаляем ее из массива
                        this.pages.splice(i, 1);
                        break;
                    }
                }
            }
            if (!uniq) --this.current;
            var page = new Page(id, caption, this.pageContainer);
            this.pages.splice(this.current, 0, page);
            return page;
        }
    }]);

    return contentBuilder;
}(componentLib.Component);
/**
 *
 */


exports.default = contentBuilder;

var Page = function () {
    function Page(id, caption, box) {
        _classCallCheck(this, Page);

        this.id = id;
        this.caption = caption;
        this.box = box;
        this.generatedBox = '';
        this.children = [];
        this.render();
        console.log(this);
    }

    _createClass(Page, [{
        key: 'addChildren',
        value: function addChildren(child) {
            this.children.push(child);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.generatedBox.parentNode.removeChild(this.generatedBox);
        }
    }, {
        key: 'clear',
        value: function clear() {
            this.generatedBox.innerHTML = 'Перезагрузка';
            for (var i in this.children) {
                this.children[i].destroy();
            }
        }
    }, {
        key: 'reload',
        value: function reload() {
            var _this2 = this;

            var object = this.children[0].object;
            var name = this.children[0].name;
            this.clear();
            var locker = new tools.Freezer({
                place: this.generatedBox,
                message: 'Загрузка'
            });
            var mainQuery = new tools.AjaxSender({
                url: 'http://localhost:1234/get' /*'server.json'*/
                , msg: "obj=" + object + '&amp;name=' + name /*''*/
                , before: function () {
                    locker.lock();
                }.bind(this)
            });
            mainQuery.sendQuery().then(function (response) {
                locker.unlock();
                var layoutLib = __webpack_require__(9);
                var layout = new layoutLib.Layout({
                    box: _this2.generatedBox,
                    element: response.elements[0],
                    content: response.content,
                    code: response.code,
                    parent: _this2
                });
            }, function (error) {
                locker.unlock();
                w2alert(error);
            });
        }
    }, {
        key: 'refresh',
        value: function refresh() {
            for (var i in this.children) {
                this.children[i].refresh();
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var boxForElement = document.createElement('div');
            boxForElement.id = 'boxForLayout' + this.id;
            boxForElement.style.height = '100%';
            this.box.appendChild(boxForElement);
            this.generatedBox = boxForElement;
        }
    }, {
        key: 'show',
        value: function show() {
            document.getElementById('boxForLayout' + this.id).style.display = '';
        }
    }, {
        key: 'hide',
        value: function hide() {
            document.getElementById('boxForLayout' + this.id).style.display = 'none';
        }
    }]);

    return Page;
}();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by AHonyakov on 17.07.2017.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _index = __webpack_require__(3);

var tools = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj &amp;&amp; obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var twoBe = function () {
    function twoBe() {
        _classCallCheck(this, twoBe);
    }

    _createClass(twoBe, null, [{
        key: 'cacheData',
        value: function cacheData(data, key) {
            localStorage[key] = JSON.stringify(data);
        }
    }, {
        key: 'getDefaultParams',
        value: function getDefaultParams() {
            return { url: 'http://localhost:1234' };
        }
    }, {
        key: 'getById',
        value: function getById(id) {
            return window.stpui[id];
        }
    }, {
        key: 'buildView',
        value: function buildView(data, key) {
            if (data.needToCache) {
                this.cacheData(data, key);
            }
            if (data.elements.length !== 1) {
                w2alert('Сервер вернул некорректные данные!');
                return;
            }
            if (data.elements[0].type === 'popup') {
                var popupLib = __webpack_require__(38);
                if (window.stpui !== undefined &amp;&amp; window.stpui.popup === undefined) {
                    new popupLib.Popup();
                }
                window.stpui.popup.showNewModal(data);
            }
        }
    }, {
        key: 'getCache',
        value: function getCache(key) {
            if (localStorage[key] !== undefined) {
                return JSON.parse(localStorage[key]);
            } else {
                return null;
            }
        }
    }, {
        key: 'showMessage',
        value: function showMessage(type, msg) {
            w2alert(msg);
        }
    }, {
        key: 'sendRequest',
        value: function sendRequest(url, action, object, name, beforeSend, success, error) {
            var request = new tools.AjaxSender({
                url: url,
                msg: action + object + name,
                before: function before() {
                    beforeSend();
                }
            });
            request.sendQuery().then(function (response) {
                success(response);
            }, function (errorResponse) {
                error(errorResponse);
            });
        }
    }, {
        key: 'createRequest',
        value: function createRequest() {
            return new Request();
        }
    }, {
        key: 'showConfirm',
        value: function showConfirm(msg, callback) {
            w2confirm(msg).yes(function () {
                callback();
            });
        }
    }]);

    return twoBe;
}();

exports.default = twoBe;

var Request = function () {
    function Request() {
        _classCallCheck(this, Request);

        this.url = '';
        this.param = [];
        this.before = '';
        this.success = '';
        this.error = '';
        this.queryString = '';
        this.cacheKey = null;
    }

    _createClass(Request, [{
        key: 'addUrl',
        value: function addUrl(url) {
            this.url = url;
            return this;
        }
    }, {
        key: 'addParam',
        value: function addParam(key, value) {
            this.param.push(key + '=' + value);
            return this;
        }
    }, {
        key: 'addBefore',
        value: function addBefore(func) {
            this.before = func;
            return this;
        }
    }, {
        key: 'addSuccess',
        value: function addSuccess(func) {
            this.success = func;
            return this;
        }
    }, {
        key: 'addError',
        value: function addError(func) {
            this.error = func;
            return this;
        }
    }, {
        key: 'addCacheKey',
        value: function addCacheKey(key) {
            this.cacheKey = key;
            return this;
        }
    }, {
        key: 'addQueryString',
        value: function addQueryString(string) {
            this.queryString = string;
            return this;
        }
    }, {
        key: 'send',
        value: function send() {
            var _this = this;

            /*if (this.cacheKey !== null &amp;&amp; localStorage[this.cacheKey] !== undefined) {
             this.success(twoBe.getCache(this.cacheKey));
             return;
             }*/
            var request = new tools.AjaxSender({
                url: this.url,
                msg: this.param.join('&amp;') + (this.queryString.length === 0 ? '' : '&amp;' + this.queryString),
                before: function () {
                    this.before();
                }.bind(this)
            });
            request.sendQuery().then(function (response) {
                _this.success(response);
            }, function (errorResponse) {
                _this.error(errorResponse);
            });
        }
    }]);

    return Request;
}();

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(jQuery, $) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Created by AHonyakov on 25.07.2017.
 */
var Popup = exports.Popup = function () {
    function Popup() {
        _classCallCheck(this, Popup);

        this.dimension = -1;
        this.modals = [];
        if (window.stpui === undefined) {
            window.stpui = {};
        }
        window.stpui.popup = this;
    }

    _createClass(Popup, [{
        key: 'showNewModal',
        value: function showNewModal(data) {
            var _this = this;

            var popupProperties = this.getParams(data);
            this.getPlace(popupProperties).then(function (place) {
                var layoutLib = __webpack_require__(9);
                var layuout = new layoutLib.Layout({
                    box: place,
                    element: popupProperties.body,
                    content: data.content,
                    code: data.code
                });
                _this.modals[_this.dimension].object = layuout;
            });
        }
    }, {
        key: 'prepareCode',
        value: function prepareCode(oldCode) {
            var newCode = {};
            for (var funcName in oldCode) {
                var func = new Function('return ' + oldCode[funcName]);
                newCode[funcName] = func();
            }
            return newCode;
        }
    }, {
        key: 'close',
        value: function close() {
            var self = this;
            if (self.dimension === 0) {
                w2popup.close();
            } else {
                //заголовок
                document.getElementById('popupHeader').innerHTML = self.modals[self.dimension].header;
                //удаляем
                document.getElementById('popup' + self.dimension).parentNode.removeChild(document.getElementById('popup' + self.dimension));
                document.getElementById('popupBtn' + self.dimension).parentNode.removeChild(document.getElementById('popupBtn' + self.dimension));
                if (w2popup.get().maximized) {
                    w2popup.min();
                }
                self.dimension--;
                //изменяем размер
                w2popup.resize(self.modals[self.dimension].width, self.modals[self.dimension].height, function () {
                    if (self.modals[self.dimension].maximized) {
                        w2popup.max();
                    }
                    self.modals[self.dimension].object.refresh();
                    //покаываем
                    document.getElementById('popup' + self.dimension).style.display = '';
                    document.getElementById('popupBtn' + self.dimension).style.display = '';
                    self.modals.pop();
                });
            }
            delete stpui.popup;
        }
    }, {
        key: 'lock',
        value: function lock() {
            var msg = arguments.length > 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : '';
            var spinner = arguments.length > 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : true;

            w2popup.lock(msg, spinner);
        }
    }, {
        key: 'unlock',
        value: function unlock() {
            w2popup.unlock();
        }
    }, {
        key: 'getPlace',
        value: function getPlace(properties) {
            var self = this;
            return new Promise(function (resolve, reject) {
                //определяем статус всплывающего окна
                if (self.dimension &lt; 0) {
                    //это первое модальное окно
                    //формируем панель с кнопками
                    var buttonsHtml = "";
                    for (var i in properties.footer) {
                        buttonsHtml += '&lt;button class="w2ui-btn" id=' + properties.footer[i].id + '0' + '  style="margin-left: 5px">' + properties.footer[i].properties.caption + '&lt;/button>';
                    }
                    buttonsHtml += '&lt;button class="w2ui-btn" id=' + 'close' + '0' + '  style="margin-left: 5px">' + 'Закрыть' + '&lt;/button>';
                    buttonsHtml = '&lt;div id="popupBtn">&lt;div id="popupBtn0">' + buttonsHtml + '&lt;/div>&lt;/div>';
                    //формируем контейнер для панели
                    var bodyHtml = '&lt;div id="popupDiv" style="position: absolute; left: 5px; top: 5px; right: 5px; bottom: 5px;">&lt;div id="popup0" style="position: absolute; left: 5px; top: 5px; right: 5px; bottom: 5px;">&lt;/div>&lt;/div>';
                    //конфигурируем окно
                    w2popup.open({
                        title: '&lt;div id="popupHeader">' + properties.header + '&lt;/div>',
                        height: properties.height,
                        width: properties.width,
                        body: bodyHtml,
                        showMax: true,
                        buttons: buttonsHtml,
                        modal: true,
                        onOpen: function onOpen(event) {
                            event.onComplete = function () {
                                //w2popup.resize(properties.width, properties.height, function () {
                                self.dimension++;
                                self.modals.push({
                                    header: properties.header,
                                    width: w2popup.get().width,
                                    height: w2popup.get().height
                                });
                                // });
                                //навешиваем обработчики на кнопки

                                var _loop = function _loop(_i) {
                                    document.getElementById(properties.footer[_i].id + '0').onclick = function () {
                                        var button = {
                                            getProperties: function getProperties() {
                                                return { param: properties.footer[_i].properties.param || null };
                                            }
                                        };
                                        properties.code[properties.footer[_i].events.click](button);
                                    };
                                };

                                for (var _i in properties.footer) {
                                    _loop(_i);
                                }
                                //добавляем кнопку отмену
                                document.getElementById('close0').onclick = function () {
                                    self.close();
                                };
                                var closeBtn = jQuery('div.w2ui-popup-close')[0];
                                $(closeBtn).unbind('click');
                                closeBtn.onclick = null;
                                closeBtn.onclick = function () {
                                    self.close();
                                };
                                resolve(document.getElementById('popup0'));
                            };
                        },
                        onClose: function onClose(event) {},
                        onToggle: function onToggle(event) {
                            event.onComplete = function () {
                                self.lock('', true);
                                function func() {
                                    self.unlock();
                                }

                                setTimeout(func, 500);
                            };
                        }
                    });
                } else {
                    //вложенное окно
                    self.modals[self.dimension].maximized = w2popup.get().maximized;
                    if (w2popup.get().maximized) {
                        w2popup.min();
                    }
                    //скрываем имеющееся тело и кнопки
                    document.getElementById('popup' + self.dimension).style.display = 'none';
                    document.getElementById('popupBtn' + self.dimension).style.display = 'none';
                    self.dimension++;
                    //формируем тело
                    var bodyObj = document.createElement('div');
                    bodyObj.id = 'popup' + self.dimension;
                    bodyObj.style.height = '100%';
                    document.getElementById('popupDiv').appendChild(bodyObj);
                    var buttonsHtml = "";
                    for (var i in properties.footer) {
                        buttonsHtml += '&lt;button class="w2ui-btn" id=' + properties.footer[i].id + self.dimension + '  style="margin-left: 5px">' + properties.footer[i].properties.caption + '&lt;/button>';
                    }
                    buttonsHtml += '&lt;button class="w2ui-btn" id=' + 'close' + self.dimension + ' style="margin-left: 5px">' + 'Назад' + '&lt;/button>';
                    var buttonsObj = document.createElement('div');
                    buttonsObj.id = 'popupBtn' + self.dimension;
                    buttonsObj.innerHTML = buttonsHtml;
                    document.getElementById('popupBtn').appendChild(buttonsObj);
                    //навешиваем обработчики на кнопки
                    for (var i in properties.footer) {
                        document.getElementById(properties.footer[i].id + self.dimension).onclick = function () {
                            var button = {
                                getProperties: function getProperties() {
                                    return { param: properties.footer[i].properties.param || null };
                                }
                            };
                            properties.code[properties.footer[i].events.click](button);
                        }.bind(self);
                    }
                    //меняем размеры
                    var w = 0;
                    var h = 0;
                    w = properties.width;
                    h = properties.height;
                    w2popup.resize(w, h, function () {
                        self.modals.push({
                            header: properties.header,
                            width: w2popup.get().width,
                            height: w2popup.get().height
                        });
                        document.getElementById('popupHeader').innerHTML = properties.header;
                        //кнопка закрыть откатывает на один шаг назад
                        document.getElementById('close' + self.dimension).onclick = function () {
                            self.close();
                        };
                        resolve(document.getElementById('popup' + self.dimension));
                    });
                }
            });
        }
    }, {
        key: 'getParams',
        value: function getParams(data) {
            console.log(data);
            var popupData = data.elements[0];
            var result = {
                code: this.prepareCode(data.code)
            };
            for (var i in popupData.elements) {
                if (popupData.elements[i].type === 'header') {
                    result.header = popupData.elements[i].properties.caption;
                }
                if (popupData.elements[i].type === 'footer') {
                    result.footer = popupData.elements[i].elements;
                }
                if (popupData.elements[i].type === 'body') {
                    result.body = popupData.elements[i].elements[0];
                }
            }
            result.width = popupData.properties.width;
            result.height = popupData.properties.height;
            return result;
        }
    }]);

    return Popup;
}();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(1)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(3).then((function(require) {
	data = __webpack_require__(51);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i &lt; l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(0).then((function(require) {
	data = __webpack_require__(52);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i &lt; l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(2).then((function(require) {
	data = __webpack_require__(53);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i &lt; l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var cbs = [], 
	data;
module.exports = function(cb) {
	if(cbs) cbs.push(cb);
	else cb(data);
}
__webpack_require__.e/* require.ensure */(1).then((function(require) {
	data = __webpack_require__(54);
	var callbacks = cbs;
	cbs = null;
	for(var i = 0, l = callbacks.length; i &lt; l; i++) {
		callbacks[i](data);
	}
}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

/***/ }),
/* 43 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var jQuery = __webpack_require__(1);

/* w2ui 1.5.rc1 (nightly) (c) http://w2ui.com, vitmalina@gmail.com */
var w2ui = w2ui || {};
var w2obj = w2obj || {}; // expose object to be able to overwrite default functions

/************************************************
 *  Library: Web 2.0 UI for jQuery
 *  - Following objects are defines
 *        - w2ui             - object that will contain all widgets
 *        - w2obj            - object with widget prototypes
 *        - w2utils          - basic utilities
 *        - $().w2render     - common render
 *        - $().w2destroy    - common destroy
 *        - $().w2marker     - marker plugin
 *        - $().w2tag        - tag plugin
 *        - $().w2overlay    - overlay plugin
 *        - $().w2menu       - menu plugin
 *        - w2utils.event    - generic event object
 *  - Dependencies: jQuery
 *
 * == NICE TO HAVE ==
 *   - overlay should be displayed where more space (on top or on bottom)
 *   - write and article how to replace certain framework functions
 *   - add maxHeight for the w2menu
 *   - add time zone
 *   - TEST On IOS
 *   - $().w2marker() -- only unmarks first instance
 *   - subitems for w2menus()
 *   - add w2utils.lang wrap for all captions in all buttons.
 *   - $().w2date(), $().w2dateTime()
 *
 ************************************************/

var w2utils = (function ($) {
    var tmp = {}; // for some temp variables
    var obj = {
        version: '1.5.RC1',
        settings: {
            "locale": "en-us",
            "dateFormat": "m/d/yyyy",
            "timeFormat": "hh:mi pm",
            "datetimeFormat": "m/d/yyyy|hh:mi pm",
            "currencyPrefix": "$",
            "currencySuffix": "",
            "currencyPrecision": 2,
            "groupSymbol": ",",
            "decimalSymbol": ".",
            "shortmonths": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "fullmonths": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "shortdays": ["M", "T", "W", "T", "F", "S", "S"],
            "fulldays": ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
            "weekStarts": "M",        // can be "M" for Monday or "S" for Sunday
            "dataType": 'HTTPJSON', // can be HTTP, HTTPJSON, RESTFULL, RESTFULLJSON, JSON (case sensitive)
            "phrases": {},         // empty object for english phrases
            "dateStartYear": 1950,       // start year for date-picker
            "dateEndYear": 2020        // end year for date picker
        },
        isBin: isBin,
        isInt: isInt,
        isFloat: isFloat,
        isMoney: isMoney,
        isHex: isHex,
        isAlphaNumeric: isAlphaNumeric,
        isEmail: isEmail,
        isDate: isDate,
        isTime: isTime,
        isDateTime: isDateTime,
        age: age,
        interval: interval,
        date: date,
        formatSize: formatSize,
        formatNumber: formatNumber,
        formatDate: formatDate,
        formatTime: formatTime,
        formatDateTime: formatDateTime,
        stripTags: stripTags,
        encodeTags: encodeTags,
        decodeTags: decodeTags,
        escapeId: escapeId,
        base64encode: base64encode,
        base64decode: base64decode,
        md5: md5,
        transition: transition,
        lock: lock,
        unlock: unlock,
        message: message,
        lang: lang,
        locale: locale,
        getSize: getSize,
        getStrWidth: getStrWidth,
        scrollBarSize: scrollBarSize,
        checkName: checkName,
        checkUniqueId: checkUniqueId,
        parseRoute: parseRoute,
        cssPrefix: cssPrefix,
        getCursorPosition: getCursorPosition,
        setCursorPosition: setCursorPosition,
        testLocalStorage: testLocalStorage,
        hasLocalStorage: testLocalStorage(),
        // some internal variables
        isIOS: ((navigator.userAgent.toLowerCase().indexOf('iphone') != -1 ||
        navigator.userAgent.toLowerCase().indexOf('ipod') != -1 ||
        navigator.userAgent.toLowerCase().indexOf('ipad') != -1)
            ? true : false),
        isIE: ((navigator.userAgent.toLowerCase().indexOf('msie') != -1 ||
        navigator.userAgent.toLowerCase().indexOf('trident') != -1 )
            ? true : false)
    };
    return obj;

    function isBin(val) {
        var re = /^[0-1]+$/;
        return re.test(val);
    }

    function isInt(val) {
        var re = /^[-+]?[0-9]+$/;
        return re.test(val);
    }

    function isFloat(val) {
        if (typeof val == 'string') val = val.replace(/\s+/g, '').replace(w2utils.settings.groupSymbol, '').replace(w2utils.settings.decimalSymbol, '.');
        return (typeof val === 'number' || (typeof val === 'string' &amp;&amp; val !== '')) &amp;&amp; !isNaN(Number(val));
    }

    function isMoney(val) {
        var se = w2utils.settings;
        var re = new RegExp('^' + (se.currencyPrefix ? '\\' + se.currencyPrefix + '?' : '') +
            '[-+]?' + (se.currencyPrefix ? '\\' + se.currencyPrefix + '?' : '') +
            '[0-9]*[\\' + se.decimalSymbol + ']?[0-9]+' + (se.currencySuffix ? '\\' + se.currencySuffix + '?' : '') + '$', 'i');
        if (typeof val === 'string') {
            val = val.replace(new RegExp(se.groupSymbol, 'g'), '');
        }
        if (typeof val === 'object' || val === '') return false;
        return re.test(val);
    }

    function isHex(val) {
        var re = /^[a-fA-F0-9]+$/;
        return re.test(val);
    }

    function isAlphaNumeric(val) {
        var re = /^[a-zA-Z0-9_-]+$/;
        return re.test(val);
    }

    function isEmail(val) {
        var email = /^[a-zA-Z0-9._%-+]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/;
        return email.test(val);
    }

    function isDate(val, format, retDate) {
        if (!val) return false;

        var dt = 'Invalid Date';
        var month, day, year;

        if (format == null) format = w2utils.settings.dateFormat;

        if (typeof val.getUTCFullYear === 'function') { // date object
            year = val.getUTCFullYear();
            month = val.getUTCMonth() + 1;
            day = val.getUTCDate();
        } else if (parseInt(val) == val &amp;&amp; parseInt(val) > 0) {
            val = new Date(parseInt(val));
            year = val.getUTCFullYear();
            month = val.getUTCMonth() + 1;
            day = val.getUTCDate();
        } else {
            val = String(val);
            // convert month formats
            if (new RegExp('mon', 'ig').test(format)) {
                format = format.replace(/month/ig, 'm').replace(/mon/ig, 'm').replace(/dd/ig, 'd').replace(/[, ]/ig, '/').replace(/\/\//g, '/').toLowerCase();
                val = val.replace(/[, ]/ig, '/').replace(/\/\//g, '/').toLowerCase();
                for (var m = 0, len = w2utils.settings.fullmonths.length; m &lt; len; m++) {
                    var t = w2utils.settings.fullmonths[m];
                    val = val.replace(new RegExp(t, 'ig'), (parseInt(m) + 1)).replace(new RegExp(t.substr(0, 3), 'ig'), (parseInt(m) + 1));
                }
            }
            // format date
            var tmp = val.replace(/-/g, '/').replace(/\./g, '/').toLowerCase().split('/');
            var tmp2 = format.replace(/-/g, '/').replace(/\./g, '/').toLowerCase();
            if (tmp2 === 'mm/dd/yyyy') {
                month = tmp[0];
                day = tmp[1];
                year = tmp[2];
            }
            if (tmp2 === 'm/d/yyyy') {
                month = tmp[0];
                day = tmp[1];
                year = tmp[2];
            }
            if (tmp2 === 'dd/mm/yyyy') {
                month = tmp[1];
                day = tmp[0];
                year = tmp[2];
            }
            if (tmp2 === 'd/m/yyyy') {
                month = tmp[1];
                day = tmp[0];
                year = tmp[2];
            }
            if (tmp2 === 'yyyy/dd/mm') {
                month = tmp[2];
                day = tmp[1];
                year = tmp[0];
            }
            if (tmp2 === 'yyyy/d/m') {
                month = tmp[2];
                day = tmp[1];
                year = tmp[0];
            }
            if (tmp2 === 'yyyy/mm/dd') {
                month = tmp[1];
                day = tmp[2];
                year = tmp[0];
            }
            if (tmp2 === 'yyyy/m/d') {
                month = tmp[1];
                day = tmp[2];
                year = tmp[0];
            }
            if (tmp2 === 'mm/dd/yy') {
                month = tmp[0];
                day = tmp[1];
                year = tmp[2];
            }
            if (tmp2 === 'm/d/yy') {
                month = tmp[0];
                day = tmp[1];
                year = parseInt(tmp[2]) + 1900;
            }
            if (tmp2 === 'dd/mm/yy') {
                month = tmp[1];
                day = tmp[0];
                year = parseInt(tmp[2]) + 1900;
            }
            if (tmp2 === 'd/m/yy') {
                month = tmp[1];
                day = tmp[0];
                year = parseInt(tmp[2]) + 1900;
            }
            if (tmp2 === 'yy/dd/mm') {
                month = tmp[2];
                day = tmp[1];
                year = parseInt(tmp[0]) + 1900;
            }
            if (tmp2 === 'yy/d/m') {
                month = tmp[2];
                day = tmp[1];
                year = parseInt(tmp[0]) + 1900;
            }
            if (tmp2 === 'yy/mm/dd') {
                month = tmp[1];
                day = tmp[2];
                year = parseInt(tmp[0]) + 1900;
            }
            if (tmp2 === 'yy/m/d') {
                month = tmp[1];
                day = tmp[2];
                year = parseInt(tmp[0]) + 1900;
            }
        }
        if (!isInt(year)) return false;
        if (!isInt(month)) return false;
        if (!isInt(day)) return false;
        year = +year;
        month = +month;
        day = +day;
        dt = new Date(year, month - 1, day);
        // do checks
        if (month == null) return false;
        if (String(dt) == 'Invalid Date') return false;
        if ((dt.getMonth() + 1 !== month) || (dt.getDate() !== day) || (dt.getFullYear() !== year)) return false;
        if (retDate === true) return dt; else return true;
    }

    function isTime(val, retTime) {
        // Both formats 10:20pm and 22:20
        if (val == null) return false;
        var max, am, pm;
        // -- process american format
        val = String(val);
        val = val.toUpperCase();
        am = val.indexOf('AM') >= 0;
        pm = val.indexOf('PM') >= 0;
        var ampm = (pm || am);
        if (ampm) max = 12; else max = 24;
        val = val.replace('AM', '').replace('PM', '');
        val = $.trim(val);
        // ---
        var tmp = val.split(':');
        var h = parseInt(tmp[0] || 0), m = parseInt(tmp[1] || 0), s = parseInt(tmp[2] || 0);
        // accept edge case: 3PM is a good timestamp, but 3 (without AM or PM) is NOT:
        if ((!ampm || tmp.length !== 1) &amp;&amp; tmp.length !== 2 &amp;&amp; tmp.length !== 3) {
            return false;
        }
        if (tmp[0] === '' || h &lt; 0 || h > max || !this.isInt(tmp[0]) || tmp[0].length > 2) {
            return false;
        }
        if (tmp.length > 1 &amp;&amp; (tmp[1] === '' || m &lt; 0 || m > 59 || !this.isInt(tmp[1]) || tmp[1].length !== 2)) {
            return false;
        }
        if (tmp.length > 2 &amp;&amp; (tmp[2] === '' || s &lt; 0 || s > 59 || !this.isInt(tmp[2]) || tmp[2].length !== 2)) {
            return false;
        }
        // check the edge cases: 12:01AM is ok, as is 12:01PM, but 24:01 is NOT ok while 24:00 is (midnight; equivalent to 00:00).
        // meanwhile, there is 00:00 which is ok, but 0AM nor 0PM are okay, while 0:01AM and 0:00AM are.
        if (!ampm &amp;&amp; max === h &amp;&amp; (m !== 0 || s !== 0)) {
            return false;
        }
        if (ampm &amp;&amp; tmp.length === 1 &amp;&amp; h === 0) {
            return false;
        }

        if (retTime === true) {
            if (pm &amp;&amp; h !== 12) h += 12;   // 12:00pm - is noon
            if (am &amp;&amp; h === 12) h += 12;   // 12:00am - is midnight
            return {
                hours: h,
                minutes: m,
                seconds: s
            };
        }
        return true;
    }

    function isDateTime(val, format, retDate) {
        if (format == null) format = w2utils.settings.datetimeFormat;
        var formats = format.split('|');
        if (typeof val.getUTCFullYear === 'function') { // date object
            if (retDate !== true) return true;
            return val;
        } else if (parseInt(val) == val &amp;&amp; parseInt(val) > 0) {
            val = new Date(parseInt(val));
            if (retDate !== true) return true;
            return val;
        } else {
            var tmp = String(val).indexOf(' ');
            var values = [val.substr(0, tmp), val.substr(tmp).trim()];
            formats[0] = formats[0].trim();
            if (formats[1]) formats[1] = formats[1].trim();
            // check
            var tmp1 = w2utils.isDate(values[0], formats[0], true);
            var tmp2 = w2utils.isTime(values[1], true);
            if (tmp1 !== false &amp;&amp; tmp2 !== false) {
                if (retDate !== true) return true;
                tmp1.setHours(tmp2.hours);
                tmp1.setMinutes(tmp2.minutes);
                tmp1.setSeconds(tmp2.seconds);
                return tmp1;
            } else {
                return false;
            }
        }
    }

    function age(dateStr) {
        var d1;
        if (dateStr === '' || dateStr == null) return '';
        if (typeof dateStr.getUTCFullYear === 'function') { // date object
            d1 = dateStr;
        } else if (parseInt(dateStr) == dateStr &amp;&amp; parseInt(dateStr) > 0) {
            d1 = new Date(parseInt(dateStr));
        } else {
            d1 = new Date(dateStr);
        }
        if (String(d1) == 'Invalid Date') return '';

        var d2 = new Date();
        var sec = (d2.getTime() - d1.getTime()) / 1000;
        var amount = '';
        var type = '';
        if (sec &lt; 0) {
            amount = 0;
            type = 'sec';
        } else if (sec &lt; 60) {
            amount = Math.floor(sec);
            type = 'sec';
            if (sec &lt; 0) {
                amount = 0;
                type = 'sec';
            }
        } else if (sec &lt; 60 * 60) {
            amount = Math.floor(sec / 60);
            type = 'min';
        } else if (sec &lt; 24 * 60 * 60) {
            amount = Math.floor(sec / 60 / 60);
            type = 'hour';
        } else if (sec &lt; 30 * 24 * 60 * 60) {
            amount = Math.floor(sec / 24 / 60 / 60);
            type = 'day';
        } else if (sec &lt; 365 * 24 * 60 * 60) {
            amount = Math.floor(sec / 30 / 24 / 60 / 60 * 10) / 10;
            type = 'month';
        } else if (sec &lt; 365 * 4 * 24 * 60 * 60) {
            amount = Math.floor(sec / 365 / 24 / 60 / 60 * 10) / 10;
            type = 'year';
        } else if (sec >= 365 * 4 * 24 * 60 * 60) {
            // factor in leap year shift (only older then 4 years)
            amount = Math.floor(sec / 365.25 / 24 / 60 / 60 * 10) / 10;
            type = 'year';
        }
        return amount + ' ' + type + (amount > 1 ? 's' : '');
    }

    function interval(value) {
        var ret = '';
        if (value &lt; 1000) {
            ret = "&lt; 1 sec";
        } else if (value &lt; 60000) {
            ret = Math.floor(value / 1000) + " secs";
        } else if (value &lt; 3600000) {
            ret = Math.floor(value / 60000) + " mins";
        } else if (value &lt; 86400000) {
            ret = Math.floor(value / 3600000 * 10) / 10 + " hours";
        } else if (value &lt; 2628000000) {
            ret = Math.floor(value / 86400000 * 10) / 10 + " days";
        } else if (value &lt; 3.1536e+10) {
            ret = Math.floor(value / 2628000000 * 10) / 10 + " months";
        } else {
            ret = Math.floor(value / 3.1536e+9) / 10 + " years";
        }
        return ret;
    }

    function date(dateStr) {
        if (dateStr === '' || dateStr == null || (typeof dateStr == 'object' &amp;&amp; !dateStr.getMonth)) return '';
        var d1 = new Date(dateStr);
        if (w2utils.isInt(dateStr)) d1 = new Date(Number(dateStr)); // for unix timestamps
        if (String(d1) == 'Invalid Date') return '';

        var months = w2utils.settings.shortmonths;
        var d2 = new Date(); // today
        var d3 = new Date();
        d3.setTime(d3.getTime() - 86400000); // yesterday

        var dd1 = months[d1.getMonth()] + ' ' + d1.getDate() + ', ' + d1.getFullYear();
        var dd2 = months[d2.getMonth()] + ' ' + d2.getDate() + ', ' + d2.getFullYear();
        var dd3 = months[d3.getMonth()] + ' ' + d3.getDate() + ', ' + d3.getFullYear();

        var time = (d1.getHours() - (d1.getHours() > 12 ? 12 : 0)) + ':' + (d1.getMinutes() &lt; 10 ? '0' : '') + d1.getMinutes() + ' ' + (d1.getHours() >= 12 ? 'pm' : 'am');
        var time2 = (d1.getHours() - (d1.getHours() > 12 ? 12 : 0)) + ':' + (d1.getMinutes() &lt; 10 ? '0' : '') + d1.getMinutes() + ':' + (d1.getSeconds() &lt; 10 ? '0' : '') + d1.getSeconds() + ' ' + (d1.getHours() >= 12 ? 'pm' : 'am');
        var dsp = dd1;
        if (dd1 === dd2) dsp = time;
        if (dd1 === dd3) dsp = w2utils.lang('Yesterday');

        return '&lt;span title="' + dd1 + ' ' + time2 + '">' + dsp + '&lt;/span>';
    }

    function formatSize(sizeStr) {
        if (!w2utils.isFloat(sizeStr) || sizeStr === '') return '';
        sizeStr = parseFloat(sizeStr);
        if (sizeStr === 0) return 0;
        var sizes = ['Bt', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB'];
        var i = parseInt(Math.floor(Math.log(sizeStr) / Math.log(1024)));
        return (Math.floor(sizeStr / Math.pow(1024, i) * 10) / 10).toFixed(i === 0 ? 0 : 1) + ' ' + (sizes[i] || '??');
    }

    function formatNumber(val, fraction, useGrouping) {
        if (val == null || val === '' || typeof val == 'object') return '';
        var options = {
            minimumFractionDigits: fraction,
            maximumFractionDigits: fraction,
            useGrouping: useGrouping
        };
        if (fraction == null || fraction &lt; 0) {
            options.minimumFractionDigits = 0;
            options.maximumFractionDigits = 20;
        }
        return parseFloat(val).toLocaleString(w2utils.settings.locale, options);
    }

    function formatDate(dateStr, format) { // IMPORTANT dateStr HAS TO BE valid JavaScript Date String
        if (!format) format = this.settings.dateFormat;
        if (dateStr === '' || dateStr == null || (typeof dateStr == 'object' &amp;&amp; !dateStr.getMonth)) return '';

        var dt = new Date(dateStr);
        if (w2utils.isInt(dateStr)) dt = new Date(Number(dateStr)); // for unix timestamps
        if (String(dt) == 'Invalid Date') return '';

        var year = dt.getFullYear();
        var month = dt.getMonth();
        var date = dt.getDate();
        return format.toLowerCase()
            .replace('month', w2utils.settings.fullmonths[month])
            .replace('mon', w2utils.settings.shortmonths[month])
            .replace(/yyyy/g, year)
            .replace(/yyy/g, year)
            .replace(/yy/g, year > 2000 ? 100 + parseInt(String(year).substr(2)) : String(year).substr(2))
            .replace(/(^|[^a-z$])y/g, '$1' + year)            // only y's that are not preceded by a letter
            .replace(/mm/g, (month + 1 &lt; 10 ? '0' : '') + (month + 1))
            .replace(/dd/g, (date &lt; 10 ? '0' : '') + date)
            .replace(/th/g, (date == 1 ? 'st' : 'th'))
            .replace(/th/g, (date == 2 ? 'nd' : 'th'))
            .replace(/th/g, (date == 3 ? 'rd' : 'th'))
            .replace(/(^|[^a-z$])m/g, '$1' + (month + 1))     // only y's that are not preceded by a letter
            .replace(/(^|[^a-z$])d/g, '$1' + date);           // only y's that are not preceded by a letter
    }

    function formatTime(dateStr, format) { // IMPORTANT dateStr HAS TO BE valid JavaScript Date String
        var months = w2utils.settings.shortmonths;
        var fullMonths = w2utils.settings.fullmonths;
        if (!format) format = this.settings.timeFormat;
        if (dateStr === '' || dateStr == null || (typeof dateStr == 'object' &amp;&amp; !dateStr.getMonth)) return '';

        var dt = new Date(dateStr);
        if (w2utils.isInt(dateStr)) dt = new Date(Number(dateStr)); // for unix timestamps
        if (w2utils.isTime(dateStr)) {
            var tmp = w2utils.isTime(dateStr, true);
            dt = new Date();
            dt.setHours(tmp.hours);
            dt.setMinutes(tmp.minutes);
        }
        if (String(dt) == 'Invalid Date') return '';

        var type = 'am';
        var hour = dt.getHours();
        var h24 = dt.getHours();
        var min = dt.getMinutes();
        var sec = dt.getSeconds();
        if (min &lt; 10) min = '0' + min;
        if (sec &lt; 10) sec = '0' + sec;
        if (format.indexOf('am') !== -1 || format.indexOf('pm') !== -1) {
            if (hour >= 12) type = 'pm';
            if (hour > 12) hour = hour - 12;
        }
        return format.toLowerCase()
            .replace('am', type)
            .replace('pm', type)
            .replace('hhh', (hour &lt; 10 ? '0' + hour : hour))
            .replace('hh24', (h24 &lt; 10 ? '0' + h24 : h24))
            .replace('h24', h24)
            .replace('hh', hour)
            .replace('mm', min)
            .replace('mi', min)
            .replace('ss', sec)
            .replace(/(^|[^a-z$])h/g, '$1' + hour)    // only y's that are not preceded by a letter
            .replace(/(^|[^a-z$])m/g, '$1' + min)     // only y's that are not preceded by a letter
            .replace(/(^|[^a-z$])s/g, '$1' + sec);    // only y's that are not preceded by a letter
    }

    function formatDateTime(dateStr, format) {
        var fmt;
        if (dateStr === '' || dateStr == null || (typeof dateStr == 'object' &amp;&amp; !dateStr.getMonth)) return '';
        if (typeof format !== 'string') {
            fmt = [this.settings.dateFormat, this.settings.timeFormat];
        } else {
            fmt = format.split('|');
            fmt[0] = fmt[0].trim();
            fmt[1] = fmt[1].trim();
        }
        // older formats support
        if (fmt[1] == 'h12') fmt[1] = 'h:m pm';
        if (fmt[1] == 'h24') fmt[1] = 'h24:m';
        return this.formatDate(dateStr, fmt[0]) + ' ' + this.formatTime(dateStr, fmt[1]);
    }

    function stripTags(html) {
        if (html == null) return html;
        switch (typeof html) {
            case 'number':
                break;
            case 'string':
                html = String(html).replace(/(&lt;([^>]+)>)/ig, "");
                break;
            case 'object':
                // does not modify original object, but creates a copy
                if (Array.isArray(html)) {
                    html = $.extend(true, [], html);
                    for (var i = 0; i &lt; html.length; i++) html[i] = this.stripTags(html[i]);
                } else {
                    html = $.extend(true, {}, html);
                    for (var i in html) html[i] = this.stripTags(html[i]);
                }
                break;
        }
        return html;
    }

    function encodeTags(html) {
        if (html == null) return html;
        switch (typeof html) {
            case 'number':
                break;
            case 'string':
                html = String(html).replace(/&amp;/g, "&amp;amp;").replace(/>/g, "&amp;gt;").replace(/&lt;/g, "&amp;lt;").replace(/"/g, "&amp;quot;");
                break;
            case 'object':
                // does not modify original object, but creates a copy
                if (Array.isArray(html)) {
                    html = $.extend(true, [], html);
                    for (var i = 0; i &lt; html.length; i++) html[i] = this.encodeTags(html[i]);
                } else {
                    html = $.extend(true, {}, html);
                    for (var i in html) html[i] = this.encodeTags(html[i]);
                }
                break;
        }
        return html;
    }

    function decodeTags(html) {
        if (html == null) return html;
        switch (typeof html) {
            case 'number':
                break;
            case 'string':
                html = String(html).replace(/&amp;gt;/g, ">").replace(/&amp;lt;/g, "&lt;").replace(/&amp;quot;/g, '"').replace(/&amp;amp;/g, "&amp;");
                break;
            case 'object':
                // does not modify original object, but creates a copy
                if (Array.isArray(html)) {
                    html = $.extend(true, [], html);
                    for (var i = 0; i &lt; html.length; i++) html[i] = this.decodeTags(html[i]);
                } else {
                    html = $.extend(true, {}, html);
                    for (var i in html) html[i] = this.decodeTags(html[i]);
                }
                break;
        }
        return html;
    }

    function escapeId(id) {
        if (id === '' || id == null) return '';
        return String(id).replace(/([;&amp;,\.\+\*\~'`:"\!\^#$%@\[\]\(\)=&lt;>\|\/? {}\\])/g, '\\$1');
    }

    function base64encode(input) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
        var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        input = utf8_encode(input);

        while (i &lt; input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 >> 4);
            enc3 = ((chr2 &amp; 15) &lt;&lt; 2) | (chr3 >> 6);
            enc4 = chr3 &amp; 63;
            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }
            output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
        }

        function utf8_encode(string) {
            string = String(string).replace(/\r\n/g, "\n");
            var utftext = "";

            for (var n = 0; n &lt; string.length; n++) {
                var c = string.charCodeAt(n);
                if (c &lt; 128) {
                    utftext += String.fromCharCode(c);
                }
                else if ((c > 127) &amp;&amp; (c &lt; 2048)) {
                    utftext += String.fromCharCode((c >> 6) | 192);
                    utftext += String.fromCharCode((c &amp; 63) | 128);
                }
                else {
                    utftext += String.fromCharCode((c >> 12) | 224);
                    utftext += String.fromCharCode(((c >> 6) &amp; 63) | 128);
                    utftext += String.fromCharCode((c &amp; 63) | 128);
                }
            }
            return utftext;
        }

        return output;
    }

    function base64decode(input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while (i &lt; input.length) {
            enc1 = keyStr.indexOf(input.charAt(i++));
            enc2 = keyStr.indexOf(input.charAt(i++));
            enc3 = keyStr.indexOf(input.charAt(i++));
            enc4 = keyStr.indexOf(input.charAt(i++));
            chr1 = (enc1 &lt;&lt; 2) | (enc2 >> 4);
            chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 >> 2);
            chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 !== 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 !== 64) {
                output = output + String.fromCharCode(chr3);
            }
        }
        output = utf8_decode(output);

        function utf8_decode(utftext) {
            var string = "";
            var i = 0;
            var c = 0, c2, c3;

            while (i &lt; utftext.length) {
                c = utftext.charCodeAt(i);
                if (c &lt; 128) {
                    string += String.fromCharCode(c);
                    i++;
                }
                else if ((c > 191) &amp;&amp; (c &lt; 224)) {
                    c2 = utftext.charCodeAt(i + 1);
                    string += String.fromCharCode(((c &amp; 31) &lt;&lt; 6) | (c2 &amp; 63));
                    i += 2;
                }
                else {
                    c2 = utftext.charCodeAt(i + 1);
                    c3 = utftext.charCodeAt(i + 2);
                    string += String.fromCharCode(((c &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63));
                    i += 3;
                }
            }

            return string;
        }

        return output;
    }

    function md5(input) {
        /*
         * Based on http://pajhome.org.uk/crypt/md5
         */

        var hexcase = 0;
        var b64pad = "";

        function __pj_crypt_hex_md5(s) {
            return __pj_crypt_rstr2hex(__pj_crypt_rstr_md5(__pj_crypt_str2rstr_utf8(s)));
        }

        function __pj_crypt_b64_md5(s) {
            return __pj_crypt_rstr2b64(__pj_crypt_rstr_md5(__pj_crypt_str2rstr_utf8(s)));
        }

        function __pj_crypt_any_md5(s, e) {
            return __pj_crypt_rstr2any(__pj_crypt_rstr_md5(__pj_crypt_str2rstr_utf8(s)), e);
        }

        function __pj_crypt_hex_hmac_md5(k, d) {
            return __pj_crypt_rstr2hex(__pj_crypt_rstr_hmac_md5(__pj_crypt_str2rstr_utf8(k), __pj_crypt_str2rstr_utf8(d)));
        }

        function __pj_crypt_b64_hmac_md5(k, d) {
            return __pj_crypt_rstr2b64(__pj_crypt_rstr_hmac_md5(__pj_crypt_str2rstr_utf8(k), __pj_crypt_str2rstr_utf8(d)));
        }

        function __pj_crypt_any_hmac_md5(k, d, e) {
            return __pj_crypt_rstr2any(__pj_crypt_rstr_hmac_md5(__pj_crypt_str2rstr_utf8(k), __pj_crypt_str2rstr_utf8(d)), e);
        }

        /*
         * Calculate the MD5 of a raw string
         */
        function __pj_crypt_rstr_md5(s) {
            return __pj_crypt_binl2rstr(__pj_crypt_binl_md5(__pj_crypt_rstr2binl(s), s.length * 8));
        }

        /*
         * Calculate the HMAC-MD5, of a key and some data (raw strings)
         */
        function __pj_crypt_rstr_hmac_md5(key, data) {
            var bkey = __pj_crypt_rstr2binl(key);
            if (bkey.length > 16)
                bkey = __pj_crypt_binl_md5(bkey, key.length * 8);

            var ipad = Array(16), opad = Array(16);
            for (var i = 0; i &lt; 16; i++) {
                ipad[i] = bkey[i] ^ 0x36363636;
                opad[i] = bkey[i] ^ 0x5C5C5C5C;
            }

            var hash = __pj_crypt_binl_md5(ipad.concat(__pj_crypt_rstr2binl(data)), 512 + data.length * 8);
            return __pj_crypt_binl2rstr(__pj_crypt_binl_md5(opad.concat(hash), 512 + 128));
        }

        /*
         * Convert a raw string to a hex string
         */
        function __pj_crypt_rstr2hex(input) {
            try {
                hexcase
            } catch (e) {
                hexcase = 0;
            }
            var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
            var output = "";
            var x;
            for (var i = 0; i &lt; input.length; i++) {
                x = input.charCodeAt(i);
                output += hex_tab.charAt((x >>> 4) &amp; 0x0F)
                    + hex_tab.charAt(x &amp; 0x0F);
            }
            return output;
        }

        /*
         * Convert a raw string to a base-64 string
         */
        function __pj_crypt_rstr2b64(input) {
            try {
                b64pad
            } catch (e) {
                b64pad = '';
            }
            var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var output = "";
            var len = input.length;
            for (var i = 0; i &lt; len; i += 3) {
                var triplet = (input.charCodeAt(i) &lt;&lt; 16)
                    | (i + 1 &lt; len ? input.charCodeAt(i + 1) &lt;&lt; 8 : 0)
                    | (i + 2 &lt; len ? input.charCodeAt(i + 2) : 0);
                for (var j = 0; j &lt; 4; j++) {
                    if (i * 8 + j * 6 > input.length * 8)
                        output += b64pad;
                    else
                        output += tab.charAt((triplet >>> 6 * (3 - j)) &amp; 0x3F);
                }
            }
            return output;
        }

        /*
         * Convert a raw string to an arbitrary string encoding
         */
        function __pj_crypt_rstr2any(input, encoding) {
            var divisor = encoding.length;
            var i, j, q, x, quotient;

            /* Convert to an array of 16-bit big-endian values, forming the dividend */
            var dividend = Array(Math.ceil(input.length / 2));
            for (i = 0; i &lt; dividend.length; i++) {
                dividend[i] = (input.charCodeAt(i * 2) &lt;&lt; 8) | input.charCodeAt(i * 2 + 1);
            }

            /*
             * Repeatedly perform a long division. The binary array forms the dividend,
             * the length of the encoding is the divisor. Once computed, the quotient
             * forms the dividend for the next step. All remainders are stored for later
             * use.
             */
            var full_length = Math.ceil(input.length * 8 /
                (Math.log(encoding.length) / Math.log(2)));
            var remainders = Array(full_length);
            for (j = 0; j &lt; full_length; j++) {
                quotient = Array();
                x = 0;
                for (i = 0; i &lt; dividend.length; i++) {
                    x = (x &lt;&lt; 16) + dividend[i];
                    q = Math.floor(x / divisor);
                    x -= q * divisor;
                    if (quotient.length > 0 || q > 0)
                        quotient[quotient.length] = q;
                }
                remainders[j] = x;
                dividend = quotient;
            }

            /* Convert the remainders to the output string */
            var output = "";
            for (i = remainders.length - 1; i >= 0; i--)
                output += encoding.charAt(remainders[i]);

            return output;
        }

        /*
         * Encode a string as utf-8.
         * For efficiency, this assumes the input is valid utf-16.
         */
        function __pj_crypt_str2rstr_utf8(input) {
            var output = "";
            var i = -1;
            var x, y;

            while (++i &lt; input.length) {
                /* Decode utf-16 surrogate pairs */
                x = input.charCodeAt(i);
                y = i + 1 &lt; input.length ? input.charCodeAt(i + 1) : 0;
                if (0xD800 &lt;= x &amp;&amp; x &lt;= 0xDBFF &amp;&amp; 0xDC00 &lt;= y &amp;&amp; y &lt;= 0xDFFF) {
                    x = 0x10000 + ((x &amp; 0x03FF) &lt;&lt; 10) + (y &amp; 0x03FF);
                    i++;
                }

                /* Encode output as utf-8 */
                if (x &lt;= 0x7F)
                    output += String.fromCharCode(x);
                else if (x &lt;= 0x7FF)
                    output += String.fromCharCode(0xC0 | ((x >>> 6) &amp; 0x1F),
                        0x80 | (x &amp; 0x3F));
                else if (x &lt;= 0xFFFF)
                    output += String.fromCharCode(0xE0 | ((x >>> 12) &amp; 0x0F),
                        0x80 | ((x >>> 6) &amp; 0x3F),
                        0x80 | (x &amp; 0x3F));
                else if (x &lt;= 0x1FFFFF)
                    output += String.fromCharCode(0xF0 | ((x >>> 18) &amp; 0x07),
                        0x80 | ((x >>> 12) &amp; 0x3F),
                        0x80 | ((x >>> 6) &amp; 0x3F),
                        0x80 | (x &amp; 0x3F));
            }
            return output;
        }

        /*
         * Encode a string as utf-16
         */
        function __pj_crypt_str2rstr_utf16le(input) {
            var output = "";
            for (var i = 0; i &lt; input.length; i++)
                output += String.fromCharCode(input.charCodeAt(i) &amp; 0xFF,
                    (input.charCodeAt(i) >>> 8) &amp; 0xFF);
            return output;
        }

        function __pj_crypt_str2rstr_utf16be(input) {
            var output = "";
            for (var i = 0; i &lt; input.length; i++)
                output += String.fromCharCode((input.charCodeAt(i) >>> 8) &amp; 0xFF,
                    input.charCodeAt(i) &amp; 0xFF);
            return output;
        }

        /*
         * Convert a raw string to an array of little-endian words
         * Characters >255 have their high-byte silently ignored.
         */
        function __pj_crypt_rstr2binl(input) {
            var output = Array(input.length >> 2);
            for (var i = 0; i &lt; output.length; i++)
                output[i] = 0;
            for (var i = 0; i &lt; input.length * 8; i += 8)
                output[i >> 5] |= (input.charCodeAt(i / 8) &amp; 0xFF) &lt;&lt; (i % 32);
            return output;
        }

        /*
         * Convert an array of little-endian words to a string
         */
        function __pj_crypt_binl2rstr(input) {
            var output = "";
            for (var i = 0; i &lt; input.length * 32; i += 8)
                output += String.fromCharCode((input[i >> 5] >>> (i % 32)) &amp; 0xFF);
            return output;
        }

        /*
         * Calculate the MD5 of an array of little-endian words, and a bit length.
         */
        function __pj_crypt_binl_md5(x, len) {
            /* append padding */
            x[len >> 5] |= 0x80 &lt;&lt; ((len) % 32);
            x[(((len + 64) >>> 9) &lt;&lt; 4) + 14] = len;

            var a = 1732584193;
            var b = -271733879;
            var c = -1732584194;
            var d = 271733878;

            for (var i = 0; i &lt; x.length; i += 16) {
                var olda = a;
                var oldb = b;
                var oldc = c;
                var oldd = d;

                a = __pj_crypt_md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
                d = __pj_crypt_md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
                c = __pj_crypt_md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
                b = __pj_crypt_md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
                a = __pj_crypt_md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
                d = __pj_crypt_md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
                c = __pj_crypt_md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
                b = __pj_crypt_md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
                a = __pj_crypt_md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
                d = __pj_crypt_md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
                c = __pj_crypt_md5_ff(c, d, a, b, x[i + 10], 17, -42063);
                b = __pj_crypt_md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
                a = __pj_crypt_md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
                d = __pj_crypt_md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
                c = __pj_crypt_md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
                b = __pj_crypt_md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);

                a = __pj_crypt_md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
                d = __pj_crypt_md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
                c = __pj_crypt_md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
                b = __pj_crypt_md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
                a = __pj_crypt_md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
                d = __pj_crypt_md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
                c = __pj_crypt_md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
                b = __pj_crypt_md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
                a = __pj_crypt_md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
                d = __pj_crypt_md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
                c = __pj_crypt_md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
                b = __pj_crypt_md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
                a = __pj_crypt_md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
                d = __pj_crypt_md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
                c = __pj_crypt_md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
                b = __pj_crypt_md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

                a = __pj_crypt_md5_hh(a, b, c, d, x[i + 5], 4, -378558);
                d = __pj_crypt_md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
                c = __pj_crypt_md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
                b = __pj_crypt_md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
                a = __pj_crypt_md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
                d = __pj_crypt_md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
                c = __pj_crypt_md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
                b = __pj_crypt_md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
                a = __pj_crypt_md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
                d = __pj_crypt_md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
                c = __pj_crypt_md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
                b = __pj_crypt_md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
                a = __pj_crypt_md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
                d = __pj_crypt_md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
                c = __pj_crypt_md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
                b = __pj_crypt_md5_hh(b, c, d, a, x[i + 2], 23, -995338651);

                a = __pj_crypt_md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
                d = __pj_crypt_md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
                c = __pj_crypt_md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
                b = __pj_crypt_md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
                a = __pj_crypt_md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
                d = __pj_crypt_md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
                c = __pj_crypt_md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
                b = __pj_crypt_md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
                a = __pj_crypt_md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
                d = __pj_crypt_md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
                c = __pj_crypt_md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
                b = __pj_crypt_md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
                a = __pj_crypt_md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
                d = __pj_crypt_md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
                c = __pj_crypt_md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
                b = __pj_crypt_md5_ii(b, c, d, a, x[i + 9], 21, -343485551);

                a = __pj_crypt_safe_add(a, olda);
                b = __pj_crypt_safe_add(b, oldb);
                c = __pj_crypt_safe_add(c, oldc);
                d = __pj_crypt_safe_add(d, oldd);
            }
            return Array(a, b, c, d);
        }

        /*
         * These functions implement the four basic operations the algorithm uses.
         */
        function __pj_crypt_md5_cmn(q, a, b, x, s, t) {
            return __pj_crypt_safe_add(__pj_crypt_bit_rol(__pj_crypt_safe_add(__pj_crypt_safe_add(a, q), __pj_crypt_safe_add(x, t)), s), b);
        }

        function __pj_crypt_md5_ff(a, b, c, d, x, s, t) {
            return __pj_crypt_md5_cmn((b &amp; c) | ((~b) &amp; d), a, b, x, s, t);
        }

        function __pj_crypt_md5_gg(a, b, c, d, x, s, t) {
            return __pj_crypt_md5_cmn((b &amp; d) | (c &amp; (~d)), a, b, x, s, t);
        }

        function __pj_crypt_md5_hh(a, b, c, d, x, s, t) {
            return __pj_crypt_md5_cmn(b ^ c ^ d, a, b, x, s, t);
        }

        function __pj_crypt_md5_ii(a, b, c, d, x, s, t) {
            return __pj_crypt_md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
        }

        /*
         * Add integers, wrapping at 2^32. This uses 16-bit operations internally
         * to work around bugs in some JS interpreters.
         */
        function __pj_crypt_safe_add(x, y) {
            var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
        }

        /*
         * Bitwise rotate a 32-bit number to the left.
         */
        function __pj_crypt_bit_rol(num, cnt) {
            return (num &lt;&lt; cnt) | (num >>> (32 - cnt));
        }

        return __pj_crypt_hex_md5(input);

    }

    function transition(div_old, div_new, type, callBack) {
        var width = $(div_old).width();
        var height = $(div_old).height();
        var time = 0.5;

        if (!div_old || !div_new) {
            console.log('ERROR: Cannot do transition when one of the divs is null');
            return;
        }

        div_old.parentNode.style.cssText += 'perspective: 900px; overflow: hidden;';
        div_old.style.cssText += '; position: absolute; z-index: 1019; backface-visibility: hidden';
        div_new.style.cssText += '; position: absolute; z-index: 1020; backface-visibility: hidden';

        switch (type) {
            case 'slide-left':
                // init divs
                div_old.style.cssText += 'overflow: hidden; transform: translate3d(0, 0, 0)';
                div_new.style.cssText += 'overflow: hidden; transform: translate3d(' + width + 'px, 0, 0)';
                $(div_new).show();
                // -- need a timing function because otherwise not working
                window.setTimeout(function () {
                    div_new.style.cssText += 'transition: ' + time + 's; transform: translate3d(0, 0, 0)';
                    div_old.style.cssText += 'transition: ' + time + 's; transform: translate3d(-' + width + 'px, 0, 0)';
                }, 1);
                break;

            case 'slide-right':
                // init divs
                div_old.style.cssText += 'overflow: hidden; transform: translate3d(0, 0, 0)';
                div_new.style.cssText += 'overflow: hidden; transform: translate3d(-' + width + 'px, 0, 0)';
                $(div_new).show();
                // -- need a timing function because otherwise not working
                window.setTimeout(function () {
                    div_new.style.cssText += 'transition: ' + time + 's; transform: translate3d(0px, 0, 0)';
                    div_old.style.cssText += 'transition: ' + time + 's; transform: translate3d(' + width + 'px, 0, 0)';
                }, 1);
                break;

            case 'slide-down':
                // init divs
                div_old.style.cssText += 'overflow: hidden; z-index: 1; transform: translate3d(0, 0, 0)';
                div_new.style.cssText += 'overflow: hidden; z-index: 0; transform: translate3d(0, 0, 0)';
                $(div_new).show();
                // -- need a timing function because otherwise not working
                window.setTimeout(function () {
                    div_new.style.cssText += 'transition: ' + time + 's; transform: translate3d(0, 0, 0)';
                    div_old.style.cssText += 'transition: ' + time + 's; transform: translate3d(0, ' + height + 'px, 0)';
                }, 1);
                break;

            case 'slide-up':
                // init divs
                div_old.style.cssText += 'overflow: hidden; transform: translate3d(0, 0, 0)';
                div_new.style.cssText += 'overflow: hidden; transform: translate3d(0, ' + height + 'px, 0)';
                $(div_new).show();
                // -- need a timing function because otherwise not working
                window.setTimeout(function () {
                    div_new.style.cssText += 'transition: ' + time + 's; transform: translate3d(0, 0, 0)';
                    div_old.style.cssText += 'transition: ' + time + 's; transform: translate3d(0, 0, 0)';
                }, 1);
                break;

            case 'flip-left':
                // init divs
                div_old.style.cssText += 'overflow: hidden; transform: rotateY(0deg)';
                div_new.style.cssText += 'overflow: hidden; transform: rotateY(-180deg)';
                $(div_new).show();
                // -- need a timing function because otherwise not working
                window.setTimeout(function () {
                    div_new.style.cssText += 'transition: ' + time + 's; transform: rotateY(0deg)';
                    div_old.style.cssText += 'transition: ' + time + 's; transform: rotateY(180deg)';
                }, 1);
                break;

            case 'flip-right':
                // init divs
                div_old.style.cssText += 'overflow: hidden; transform: rotateY(0deg)';
                div_new.style.cssText += 'overflow: hidden; transform: rotateY(180deg)';
                $(div_new).show();
                // -- need a timing function because otherwise not working
                window.setTimeout(function () {
                    div_new.style.cssText += 'transition: ' + time + 's; transform: rotateY(0deg)';
                    div_old.style.cssText += 'transition: ' + time + 's; transform: rotateY(-180deg)';
                }, 1);
                break;

            case 'flip-down':
                // init divs
                div_old.style.cssText += 'overflow: hidden; transform: rotateX(0deg)';
                div_new.style.cssText += 'overflow: hidden; transform: rotateX(180deg)';
                $(div_new).show();
                // -- need a timing function because otherwise not working
                window.setTimeout(function () {
                    div_new.style.cssText += 'transition: ' + time + 's; transform: rotateX(0deg)';
                    div_old.style.cssText += 'transition: ' + time + 's; transform: rotateX(-180deg)';
                }, 1);
                break;

            case 'flip-up':
                // init divs
                div_old.style.cssText += 'overflow: hidden; transform: rotateX(0deg)';
                div_new.style.cssText += 'overflow: hidden; transform: rotateX(-180deg)';
                $(div_new).show();
                // -- need a timing function because otherwise not working
                window.setTimeout(function () {
                    div_new.style.cssText += 'transition: ' + time + 's; transform: rotateX(0deg)';
                    div_old.style.cssText += 'transition: ' + time + 's; transform: rotateX(180deg)';
                }, 1);
                break;

            case 'pop-in':
                // init divs
                div_old.style.cssText += 'overflow: hidden; transform: translate3d(0, 0, 0)';
                div_new.style.cssText += 'overflow: hidden; transform: translate3d(0, 0, 0); transform: scale(.8); opacity: 0;';
                $(div_new).show();
                // -- need a timing function because otherwise not working
                window.setTimeout(function () {
                    div_new.style.cssText += 'transition: ' + time + 's; transform: scale(1); opacity: 1;';
                    div_old.style.cssText += 'transition: ' + time + 's;';
                }, 1);
                break;

            case 'pop-out':
                // init divs
                div_old.style.cssText += 'overflow: hidden; transform: translate3d(0, 0, 0); transform: scale(1); opacity: 1;';
                div_new.style.cssText += 'overflow: hidden; transform: translate3d(0, 0, 0); opacity: 0;';
                $(div_new).show();
                // -- need a timing function because otherwise not working
                window.setTimeout(function () {
                    div_new.style.cssText += 'transition: ' + time + 's; opacity: 1;';
                    div_old.style.cssText += 'transition: ' + time + 's; transform: scale(1.7); opacity: 0;';
                }, 1);
                break;

            default:
                // init divs
                div_old.style.cssText += 'overflow: hidden; transform: translate3d(0, 0, 0)';
                div_new.style.cssText += 'overflow: hidden; translate3d(0, 0, 0); opacity: 0;';
                $(div_new).show();
                // -- need a timing function because otherwise not working
                window.setTimeout(function () {
                    div_new.style.cssText += 'transition: ' + time + 's; opacity: 1;';
                    div_old.style.cssText += 'transition: ' + time + 's';
                }, 1);
                break;
        }

        setTimeout(function () {
            if (type === 'slide-down') {
                $(div_old).css('z-index', '1019');
                $(div_new).css('z-index', '1020');
            }
            if (div_new) {
                $(div_new).css({'opacity': '1'}).css(w2utils.cssPrefix({
                    'transition': '',
                    'transform': ''
                }));
            }
            if (div_old) {
                $(div_old).css({'opacity': '1'}).css(w2utils.cssPrefix({
                    'transition': '',
                    'transform': ''
                }));
            }
            if (typeof callBack === 'function') callBack();
        }, time * 1000);
    }

    function lock(box, msg, spinner) {
        var options = {};
        if (typeof msg === 'object') {
            options = msg;
        } else {
            options.msg = msg;
            options.spinner = spinner;
        }
        if (!options.msg &amp;&amp; options.msg !== 0) options.msg = '';
        w2utils.unlock(box);
        $(box).prepend(
            '&lt;div class="w2ui-lock">&lt;/div>' +
            '&lt;div class="w2ui-lock-msg">&lt;/div>'
        );
        var $lock = $(box).find('.w2ui-lock');
        var mess = $(box).find('.w2ui-lock-msg');
        if (!options.msg) mess.css({'background-color': 'transparent', 'border': '0px'});
        if (options.spinner === true) options.msg = '&lt;div class="w2ui-spinner" ' + (!options.msg ? 'style="width: 35px; height: 35px"' : '') + '>&lt;/div>' + options.msg;
        if (options.opacity != null) $lock.css('opacity', options.opacity);
        if (typeof $lock.fadeIn == 'function') {
            $lock.fadeIn(200);
            mess.html(options.msg).fadeIn(200);
        } else {
            $lock.show();
            mess.html(options.msg).show(0);
        }
    }

    function unlock(box, speed) {
        if (isInt(speed)) {
            $(box).find('.w2ui-lock').fadeOut(speed);
            setTimeout(function () {
                $(box).find('.w2ui-lock').remove();
                $(box).find('.w2ui-lock-msg').remove();
            }, speed);
        } else {
            $(box).find('.w2ui-lock').remove();
            $(box).find('.w2ui-lock-msg').remove();
        }
    }

    /**
     *  Used in w2popup, w2grid, w2form, w2layout
     *  should be called with .call(...) method
     */

    function message(where, options) {
        var obj = this, closeTimer, edata;
        // var where.path    = 'w2popup';
        // var where.title   = '.w2ui-popup-title';
        // var where.body    = '.w2ui-box';
        $().w2tag(); // hide all tags
        if (!options) options = {width: 200, height: 100};
        if (options.on == null) $.extend(options, w2utils.event);
        if (options.width == null) options.width = 200;
        if (options.height == null) options.height = 100;
        var pWidth = parseInt($(where.box).width());
        var pHeight = parseInt($(where.box).height());
        var titleHeight = parseInt($(where.box).find(where.title).css('height') || 0);
        if (options.width > pWidth) options.width = pWidth - 10;
        if (options.height > pHeight - titleHeight) options.height = pHeight - 10 - titleHeight;
        options.originalWidth = options.width;
        options.originalHeight = options.height;
        if (parseInt(options.width) &lt; 0) options.width = pWidth + options.width;
        if (parseInt(options.width) &lt; 10) options.width = 10;
        if (parseInt(options.height) &lt; 0) options.height = pHeight + options.height - titleHeight;
        if (parseInt(options.height) &lt; 10) options.height = 10;
        if (options.hideOnClick == null) options.hideOnClick = false;
        var poptions = $(where.box).data('options') || {};
        if (options.width == null || options.width > poptions.width - 10) {
            options.width = poptions.width - 10;
        }
        if (options.height == null || options.height > poptions.height - titleHeight - 5) {
            options.height = poptions.height - titleHeight - 5; // need margin from bottom only
        }
        // negative value means margin
        if (options.originalHeight &lt; 0) options.height = pHeight + options.originalHeight - titleHeight;
        if (options.originalWidth &lt; 0) options.width = pWidth + options.originalWidth * 2; // x 2 because there is left and right margin
        var head = $(where.box).find(where.title);

        // if some messages are closing, insta close them
        var $tmp = $(where.box).find('.w2ui-message.w2ui-closing');
        if ($(where.box).find('.w2ui-message.w2ui-closing').length > 0) {
            clearTimeout(closeTimer);
            closeCB($tmp, $tmp.data('options') || {});
        }
        var msgCount = $(where.box).find('.w2ui-message').length;
        // remove message
        if ($.trim(options.html) === '' &amp;&amp; $.trim(options.body) === '' &amp;&amp; $.trim(options.buttons) === '') {
            if (msgCount === 0) return; // no messages at all
            var $msg = $(where.box).find('#w2ui-message' + (msgCount - 1));
            var options = $msg.data('options') || {};
            // before event
            edata = options.trigger({phase: 'before', type: 'close', target: 'self'});
            if (edata.isCancelled === true) return;
            // default behavior
            $msg.css(w2utils.cssPrefix({
                'transition': '0.15s',
                'transform': 'translateY(-' + options.height + 'px)'
            })).addClass('w2ui-closing');
            if (msgCount == 1) {
                if (this.unlock) {
                    if (where.param) this.unlock(where.param, 150); else this.unlock(150);
                }
            } else {
                $(where.box).find('#w2ui-message' + (msgCount - 2)).css('z-index', 1500);
            }
            closeTimer = setTimeout(function () {
                closeCB($msg, options)
            }, 150);

        } else {

            if ($.trim(options.body) !== '' || $.trim(options.buttons) !== '') {
                options.html = '&lt;div class="w2ui-message-body">' + (options.body || '') + '&lt;/div>' +
                    '&lt;div class="w2ui-message-buttons">' + (options.buttons || '') + '&lt;/div>';
            }
            // hide previous messages
            $(where.box).find('.w2ui-message').css('z-index', 1390);
            head.data('old-z-index', head.css('z-index'));
            head.css('z-index', 1501);
            // add message
            $(where.box).find(where.body)
                .before('&lt;div id="w2ui-message' + msgCount + '" onmousedown="event.stopPropagation();" ' +
                    '   class="w2ui-message" style="display: none; z-index: 1500; ' +
                    (head.length === 0 ? 'top: 0px;' : 'top: ' + w2utils.getSize(head, 'height') + 'px;') +
                    (options.width != null ? 'width: ' + options.width + 'px; left: ' + ((pWidth - options.width) / 2) + 'px;' : 'left: 10px; right: 10px;') +
                    (options.height != null ? 'height: ' + options.height + 'px;' : 'bottom: 6px;') +
                    w2utils.cssPrefix('transition', '.3s', true) + '"' +
                    (options.hideOnClick === true
                        ? where.param
                            ? 'onclick="' + where.path + '.message(\'' + where.param + '\');"'
                            : 'onclick="' + where.path + '.message();"'
                        : '') + '>' +
                    '&lt;/div>');
            $(where.box).find('#w2ui-message' + msgCount)
                .data('options', options)
                .data('prev_focus', $(':focus'));
            var display = $(where.box).find('#w2ui-message' + msgCount).css('display');
            $(where.box).find('#w2ui-message' + msgCount).css(w2utils.cssPrefix({
                'transform': (display == 'none' ? 'translateY(-' + options.height + 'px)' : 'translateY(0px)')
            }));
            if (display == 'none') {
                $(where.box).find('#w2ui-message' + msgCount).show().html(options.html);
                options.box = $(where.box).find('#w2ui-message' + msgCount);
                // before event
                edata = options.trigger({phase: 'before', type: 'open', target: 'self'});
                if (edata.isCancelled === true) {
                    head.css('z-index', head.data('old-z-index'));
                    $(where.box).find('#w2ui-message' + msgCount).remove();
                    return;
                }
                // timer needs to animation
                setTimeout(function () {
                    $(where.box).find('#w2ui-message' + msgCount).css(w2utils.cssPrefix({
                        'transform': (display == 'none' ? 'translateY(0px)' : 'translateY(-' + options.height + 'px)')
                    }));
                }, 1);
                // timer for lock
                if (msgCount === 0 &amp;&amp; this.lock) {
                    if (where.param) this.lock(where.param); else this.lock();
                }
                setTimeout(function () {
                    // has to be on top of lock
                    $(where.box).find('#w2ui-message' + msgCount).css(w2utils.cssPrefix({'transition': '0s'}));
                    // event after
                    options.trigger($.extend(edata, {phase: 'after'}));
                }, 350);
            }
        }

        function closeCB($msg, options) {
            if (edata == null) {
                // before event
                edata = options.trigger({phase: 'before', type: 'open', target: 'self'});
                if (edata.isCancelled === true) {
                    head.css('z-index', head.data('old-z-index'));
                    $(where.box).find('#w2ui-message' + msgCount).remove();
                    return;
                }
            }
            var $focus = $msg.data('prev_focus');
            $msg.remove();
            if ($focus &amp;&amp; $focus.length > 0) {
                $focus.focus();
            } else {
                if (obj &amp;&amp; obj.focus) obj.focus();
            }
            head.css('z-index', head.data('old-z-index'));
            // event after
            options.trigger($.extend(edata, {phase: 'after'}));
        }
    }

    function getSize(el, type) {
        var $el = $(el);
        var bwidth = {
            left: parseInt($el.css('border-left-width')) || 0,
            right: parseInt($el.css('border-right-width')) || 0,
            top: parseInt($el.css('border-top-width')) || 0,
            bottom: parseInt($el.css('border-bottom-width')) || 0
        };
        var mwidth = {
            left: parseInt($el.css('margin-left')) || 0,
            right: parseInt($el.css('margin-right')) || 0,
            top: parseInt($el.css('margin-top')) || 0,
            bottom: parseInt($el.css('margin-bottom')) || 0
        };
        var pwidth = {
            left: parseInt($el.css('padding-left')) || 0,
            right: parseInt($el.css('padding-right')) || 0,
            top: parseInt($el.css('padding-top')) || 0,
            bottom: parseInt($el.css('padding-bottom')) || 0
        };
        switch (type) {
            case 'top'      :
                return bwidth.top + mwidth.top + pwidth.top;
            case 'bottom'   :
                return bwidth.bottom + mwidth.bottom + pwidth.bottom;
            case 'left'     :
                return bwidth.left + mwidth.left + pwidth.left;
            case 'right'    :
                return bwidth.right + mwidth.right + pwidth.right;
            case 'width'    :
                return bwidth.left + bwidth.right + mwidth.left + mwidth.right + pwidth.left + pwidth.right + parseInt($el.width());
            case 'height'   :
                return bwidth.top + bwidth.bottom + mwidth.top + mwidth.bottom + pwidth.top + pwidth.bottom + parseInt($el.height());
            case '+width'   :
                return bwidth.left + bwidth.right + mwidth.left + mwidth.right + pwidth.left + pwidth.right;
            case '+height'  :
                return bwidth.top + bwidth.bottom + mwidth.top + mwidth.bottom + pwidth.top + pwidth.bottom;
        }
        return 0;
    }

    function getStrWidth(str, styles) {
        var w, html = '&lt;div id="_tmp_width" style="position: absolute; top: -900px;' + (styles || '') + '">' +
            encodeTags(str) +
            '&lt;/div>';
        $('body').append(html);
        w = $('#_tmp_width').width();
        $('#_tmp_width').remove();
        return w;
    }

    function lang(phrase) {
        var translation = this.settings.phrases[phrase];
        if (translation == null) return phrase; else return translation;
    }

    function locale(locale) {
        if (!locale) locale = 'en-us';

        // if the locale is an object, not a string, than we assume it's a
        if (typeof locale !== "string") {
            w2utils.settings = $.extend(true, w2utils.settings, locale);
            return;
        }

        if (locale.length === 5) locale = 'locale/' + locale + '.json';

        // clear phrases from language before
        w2utils.settings.phrases = {};

        // load from the file
        $.ajax({
            url: locale,
            type: "GET",
            dataType: "JSON",
            async: false,
            success: function (data, status, xhr) {
                w2utils.settings = $.extend(true, w2utils.settings, data);
            },
            error: function (xhr, status, msg) {
                console.log('ERROR: Cannot load locale ' + locale);
            }
        });
    }

    function scrollBarSize() {
        if (tmp.scrollBarSize) return tmp.scrollBarSize;
        var html =
            '&lt;div id="_scrollbar_width" style="position: absolute; top: -300px; width: 100px; height: 100px; overflow-y: scroll;">' +
            '    &lt;div style="height: 120px">1&lt;/div>' +
            '&lt;/div>';
        $('body').append(html);
        tmp.scrollBarSize = 100 - $('#_scrollbar_width > div').width();
        $('#_scrollbar_width').remove();
        if (String(navigator.userAgent).indexOf('MSIE') >= 0) tmp.scrollBarSize = tmp.scrollBarSize / 2; // need this for IE9+
        return tmp.scrollBarSize;
    }

    function checkName(params, component) { // was w2checkNameParam
        if (!params || params.name == null) {
            console.log('ERROR: The parameter "name" is required but not supplied in $().' + component + '().');
            return false;
        }
        if (w2ui[params.name] != null) {
            console.log('ERROR: The parameter "name" is not unique. There are other objects already created with the same name (obj: ' + params.name + ').');
            return false;
        }
        if (!w2utils.isAlphaNumeric(params.name)) {
            console.log('ERROR: The parameter "name" has to be alpha-numeric (a-z, 0-9, dash and underscore). ');
            return false;
        }
        return true;
    }

    function checkUniqueId(id, items, itemsDecription, objName) { // was w2checkUniqueId
        if (!$.isArray(items)) items = [items];
        for (var i = 0; i &lt; items.length; i++) {
            if (items[i].id === id) {
                console.log('ERROR: The parameter "id=' + id + '" is not unique within the current ' + itemsDecription + '. (obj: ' + objName + ')');
                return false;
            }
        }
        return true;
    }

    function parseRoute(route) {
        var keys = [];
        var path = route
            .replace(/\/\(/g, '(?:/')
            .replace(/\+/g, '__plus__')
            .replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?/g, function (_, slash, format, key, capture, optional) {
                keys.push({name: key, optional: !!optional});
                slash = slash || '';
                return '' + (optional ? '' : slash) + '(?:' + (optional ? slash : '') + (format || '') + (capture || (format &amp;&amp; '([^/.]+?)' || '([^/]+?)')) + ')' + (optional || '');
            })
            .replace(/([\/.])/g, '\\$1')
            .replace(/__plus__/g, '(.+)')
            .replace(/\*/g, '(.*)');
        return {
            path: new RegExp('^' + path + '$', 'i'),
            keys: keys
        };
    }

    function cssPrefix(field, value, returnString) {
        var css = {};
        var newCSS = {};
        var ret = '';
        if (!$.isPlainObject(field)) {
            css[field] = value;
        } else {
            css = field;
            if (value === true) returnString = true;
        }
        for (var c in css) {
            newCSS[c] = css[c];
            newCSS['-webkit-' + c] = css[c];
            newCSS['-moz-' + c] = css[c].replace('-webkit-', '-moz-');
            newCSS['-ms-' + c] = css[c].replace('-webkit-', '-ms-');
            newCSS['-o-' + c] = css[c].replace('-webkit-', '-o-');
        }
        if (returnString === true) {
            for (var c in newCSS) {
                ret += c + ': ' + newCSS[c] + '; ';
            }
        } else {
            ret = newCSS;
        }
        return ret;
    }

    function getCursorPosition(input) {
        if (input == null) return null;
        var caretOffset = 0;
        var doc = input.ownerDocument || input.document;
        var win = doc.defaultView || doc.parentWindow;
        var sel;
        if (input.tagName &amp;&amp; input.tagName.toUpperCase() == 'INPUT' &amp;&amp; input.selectionStart) {
            // standards browser
            caretOffset = input.selectionStart;
        } else {
            if (win.getSelection) {
                sel = win.getSelection();
                if (sel.rangeCount > 0) {
                    var range = sel.getRangeAt(0);
                    var preCaretRange = range.cloneRange();
                    preCaretRange.selectNodeContents(input);
                    preCaretRange.setEnd(range.endContainer, range.endOffset);
                    caretOffset = preCaretRange.toString().length;
                }
            } else if ((sel = doc.selection) &amp;&amp; sel.type != "Control") {
                var textRange = sel.createRange();
                var preCaretTextRange = doc.body.createTextRange();
                preCaretTextRange.moveToElementText(input);
                preCaretTextRange.setEndPoint("EndToEnd", textRange);
                caretOffset = preCaretTextRange.text.length;
            }
        }
        return caretOffset;
    }

    function setCursorPosition(input, pos, posEnd) {
        var range = document.createRange();
        var el, sel = window.getSelection();
        if (input == null) return;
        for (var i = 0; i &lt; input.childNodes.length; i++) {
            var tmp = $(input.childNodes[i]).text();
            if (input.childNodes[i].tagName) {
                tmp = $(input.childNodes[i]).html();
                tmp = tmp.replace(/&amp;lt;/g, '&lt;')
                    .replace(/&amp;gt;/g, '>')
                    .replace(/&amp;amp;/g, '&amp;')
                    .replace(/&amp;quot;/g, '"')
                    .replace(/&amp;nbsp;/g, ' ');
            }
            if (pos &lt;= tmp.length) {
                el = input.childNodes[i];
                if (el.childNodes &amp;&amp; el.childNodes.length > 0) el = el.childNodes[0];
                if (el.childNodes &amp;&amp; el.childNodes.length > 0) el = el.childNodes[0];
                break;
            } else {
                pos -= tmp.length;
            }
        }
        if (el == null) return;
        if (pos > el.length) pos = el.length;
        range.setStart(el, pos);
        if (posEnd) {
            range.setEnd(el, posEnd);
        } else {
            range.collapse(true);
        }
        sel.removeAllRanges();
        sel.addRange(range);
    }

    function testLocalStorage() {
        // test if localStorage is available, see issue #1282
        // original code: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/storage/localstorage.js
        var str = 'w2ui_test';
        try {
            localStorage.setItem(str, str);
            localStorage.removeItem(str);
            return true;
        } catch (e) {
            return false;
        }
    }

})(jQuery);

/***********************************************************
 *  Formatters object
 *  --- Primariy used in grid
 *
 *********************************************************/

w2utils.formatters = {

    'number': function (value, params) {
        if (parseInt(params) > 20) params = 20;
        if (parseInt(params) &lt; 0) params = 0;
        if (value == null || value === '') return '';
        return w2utils.formatNumber(parseFloat(value), params, true);
    },

    'float': function (value, params) {
        return w2utils.formatters['number'](value, params);
    },

    'int': function (value, params) {
        return w2utils.formatters['number'](value, 0);
    },

    'money': function (value, params) {
        if (value == null || value === '') return '';
        var data = w2utils.formatNumber(Number(value), w2utils.settings.currencyPrecision || 2);
        return (w2utils.settings.currencyPrefix || '') + data + (w2utils.settings.currencySuffix || '');
    },

    'currency': function (value, params) {
        return w2utils.formatters['money'](value, params);
    },

    'percent': function (value, params) {
        if (value == null || value === '') return '';
        return w2utils.formatNumber(value, params || 1) + '%';
    },

    'size': function (value, params) {
        if (value == null || value === '') return '';
        return w2utils.formatSize(parseInt(value));
    },

    'date': function (value, params) {
        if (params === '') params = w2utils.settings.dateFormat;
        if (value == null || value === 0 || value === '') return '';
        var dt = w2utils.isDateTime(value, params, true);
        if (dt === false) dt = w2utils.isDate(value, params, true);
        return '&lt;span title="' + dt + '">' + w2utils.formatDate(dt, params) + '&lt;/span>';
    },

    'datetime': function (value, params) {
        if (params === '') params = w2utils.settings.datetimeFormat;
        if (value == null || value === 0 || value === '') return '';
        var dt = w2utils.isDateTime(value, params, true);
        if (dt === false) dt = w2utils.isDate(value, params, true);
        return '&lt;span title="' + dt + '">' + w2utils.formatDateTime(dt, params) + '&lt;/span>';
    },

    'time': function (value, params) {
        if (params === '') params = w2utils.settings.timeFormat;
        if (params === 'h12') params = 'hh:mi pm';
        if (params === 'h24') params = 'h24:mi';
        if (value == null || value === 0 || value === '') return '';
        var dt = w2utils.isDateTime(value, params, true);
        if (dt === false) dt = w2utils.isDate(value, params, true);
        return '&lt;span title="' + dt + '">' + w2utils.formatTime(value, params) + '&lt;/span>';
    },

    'timestamp': function (value, params) {
        if (params === '') params = w2utils.settings.datetimeFormat;
        if (value == null || value === 0 || value === '') return '';
        var dt = w2utils.isDateTime(value, params, true);
        if (dt === false) dt = w2utils.isDate(value, params, true);
        return dt.toString ? dt.toString() : '';
    },

    'gmt': function (value, params) {
        if (params === '') params = w2utils.settings.datetimeFormat;
        if (value == null || value === 0 || value === '') return '';
        var dt = w2utils.isDateTime(value, params, true);
        if (dt === false) dt = w2utils.isDate(value, params, true);
        return dt.toUTCString ? dt.toUTCString() : '';
    },

    'age': function (value, params) {
        if (value == null || value === 0 || value === '') return '';
        var dt = w2utils.isDateTime(value, null, true);
        if (dt === false) dt = w2utils.isDate(value, null, true);
        return '&lt;span title="' + dt + '">' + w2utils.age(value) + (params ? (' ' + params) : '') + '&lt;/span>';
    },

    'interval': function (value, params) {
        if (value == null || value === 0 || value === '') return '';
        return w2utils.interval(value) + (params ? (' ' + params) : '');
    },

    'toggle': function (value, params) {
        return (value ? 'Yes' : '');
    },

    'password': function (value, params) {
        var ret = "";
        for (var i = 0; i &lt; value.length; i++) {
            ret += "*";
        }
        return ret;
    }
};

/***********************************************************
 *  Generic Event Object
 *  --- This object is reused across all other
 *  --- widgets in w2ui.
 *
 *********************************************************/

w2utils.event = {

    on: function (edata, handler) {
        var $ = jQuery;
        var scope;
        // allow 'eventName.scope' syntax
        if (typeof edata == 'string' &amp;&amp; edata.indexOf('.') != -1) {
            var tmp = edata.split('.');
            edata = tmp[0];
            scope = tmp[1];
        }
        // allow 'eventName:after' syntax
        if (typeof edata == 'string' &amp;&amp; edata.indexOf(':') != -1) {
            var tmp = edata.split(':');
            if (['complete', 'done'].indexOf(edata[1]) != -1) edata[1] = 'after';
            edata = {
                type: tmp[0],
                execute: tmp[1]
            };
        }
        if (!$.isPlainObject(edata)) edata = {type: edata, scope: scope};
        edata = $.extend({type: null, execute: 'before', target: null, onComplete: null}, edata);
        // errors
        if (!edata.type) {
            console.log('ERROR: You must specify event type when calling .on() method of ' + this.name);
            return;
        }
        if (!handler) {
            console.log('ERROR: You must specify event handler function when calling .on() method of ' + this.name);
            return;
        }
        if (!$.isArray(this.handlers)) this.handlers = [];
        console.log('add', edata);
        this.handlers.push({edata: edata, handler: handler});
    },

    off: function (edata, handler) {
        var $ = jQuery;
        var scope;
        // allow 'eventName.scope' syntax
        if (typeof edata == 'string' &amp;&amp; edata.indexOf('.') != -1) {
            var tmp = edata.split('.');
            edata = tmp[0];
            scope = tmp[1];
        }
        // allow 'eventName:after' syntax
        if (typeof edata == 'string' &amp;&amp; edata.indexOf(':') != -1) {
            var tmp = edata.split(':');
            if (['complete', 'done'].indexOf(edata[1]) != -1) edata[1] = 'after';
            edata = {
                type: tmp[0],
                execute: tmp[1]
            }
        }
        if (!$.isPlainObject(edata)) edata = {type: edata};
        edata = $.extend({}, {type: null, execute: 'before', target: null, onComplete: null}, edata);
        // errors
        if (!edata.type &amp;&amp; !scope) {
            console.log('ERROR: You must specify event type when calling .off() method of ' + this.name);
            return;
        }
        if (!handler) {
            handler = null;
        }
        // remove handlers
        var newHandlers = [];
        for (var h = 0, len = this.handlers.length; h &lt; len; h++) {
            var t = this.handlers[h];
            if ((t.edata.type === edata.type || edata.type === '*' || (t.edata.scope != null &amp;&amp; edata.type == '')) &amp;&amp;
                (t.edata.target === edata.target || edata.target == null) &amp;&amp;
                (t.edata.execute === edata.execute || edata.execute == null) &amp;&amp;
                (t.handler === handler || handler == null || (scope != null &amp;&amp; t.edata.scope == scope))) {
                // match
            } else {
                newHandlers.push(t);
            }
        }
        this.handlers = newHandlers;
    },

    trigger: function (edata) {
        var $ = jQuery;
        var edata = $.extend({type: null, phase: 'before', target: null, doneHandlers: []}, edata, {
            isStopped: false,
            isCancelled: false,
            done: function (handler) {
                this.doneHandlers.push(handler);
            },
            preventDefault: function () {
                this.isCancelled = true;
            },
            stopPropagation: function () {
                this.isStopped = true;
            }
        });
        if (edata.phase === 'before') edata.onComplete = null;
        var args, fun, tmp;
        if (edata.target == null) edata.target = null;
        if (!$.isArray(this.handlers)) this.handlers = [];
        // process events in REVERSE order
        for (var h = this.handlers.length - 1; h >= 0; h--) {
            var item = this.handlers[h];
            if ((item.edata.type === edata.type || item.edata.type === '*') &amp;&amp;
                (item.edata.target === edata.target || item.edata.target == null) &amp;&amp;
                (item.edata.execute === edata.phase || item.edata.execute === '*' || item.edata.phase === '*')) {
                edata = $.extend({}, item.edata, edata);
                // check handler arguments
                args = [];
                tmp = new RegExp(/\((.*?)\)/).exec(item.handler);
                if (tmp) args = tmp[1].split(/\s*,\s*/);
                if (args.length === 2) {
                    item.handler.call(this, edata.target, edata); // old way for back compatibility
                } else {
                    item.handler.call(this, edata); // new way
                }
                if (edata.isStopped === true || edata.stop === true) return edata; // back compatibility edata.stop === true
            }
        }
        // main object events
        var funName = 'on' + edata.type.substr(0, 1).toUpperCase() + edata.type.substr(1);
        if (edata.phase === 'before' &amp;&amp; typeof this[funName] === 'function') {
            fun = this[funName];
            // check handler arguments
            args = [];
            tmp = new RegExp(/\((.*?)\)/).exec(fun);
            if (tmp) args = tmp[1].split(/\s*,\s*/);
            if (args.length === 2) {
                fun.call(this, edata.target, edata); // old way for back compatibility
            } else {
                fun.call(this, edata); // new way
            }
            if (edata.isStopped === true || edata.stop === true) return edata; // back compatibility edata.stop === true
        }
        // item object events
        if (edata.object != null &amp;&amp; edata.phase === 'before' &amp;&amp;
            typeof edata.object[funName] === 'function') {
            fun = edata.object[funName];
            // check handler arguments
            args = [];
            tmp = new RegExp(/\((.*?)\)/).exec(fun);
            if (tmp) args = tmp[1].split(/\s*,\s*/);
            if (args.length === 2) {
                fun.call(this, edata.target, edata); // old way for back compatibility
            } else {
                fun.call(this, edata); // new way
            }
            if (edata.isStopped === true || edata.stop === true) return edata;
        }
        // execute onComplete
        if (edata.phase === 'after') {
            if (typeof edata.onComplete === 'function') edata.onComplete.call(this, edata);
            for (var i = 0; i &lt; edata.doneHandlers.length; i++) {
                if (typeof edata.doneHandlers[i] == 'function') {
                    edata.doneHandlers[i].call(this, edata);
                }
            }
        }
        return edata;
    }
};

/***********************************************************
 *  Commonly used plugins
 *  --- used primarily in grid and form
 *
 *********************************************************/

(function ($) {

    $.fn.w2render = function (name) {
        if ($(this).length > 0) {
            if (typeof name === 'string' &amp;&amp; w2ui[name]) w2ui[name].render($(this)[0]);
            if (typeof name === 'object') name.render($(this)[0]);
        }
    };

    $.fn.w2destroy = function (name) {
        if (!name &amp;&amp; this.length > 0) name = this.attr('name');
        if (typeof name === 'string' &amp;&amp; w2ui[name]) w2ui[name].destroy();
        if (typeof name === 'object') name.destroy();
    };

    $.fn.w2marker = function () {
        var str = Array.prototype.slice.call(arguments, 0);
        if (Array.isArray(str[0])) str = str[0];
        if (str.length === 0 || !str[0]) { // remove marker
            return $(this).each(clearMarkedText);
        } else { // add marker
            return $(this).each(function (index, el) {
                clearMarkedText(index, el);
                for (var s = 0; s &lt; str.length; s++) {
                    var tmp = str[s];
                    if (typeof tmp !== 'string') tmp = String(tmp);
                    // escape regex special chars
                    tmp = tmp.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&amp;").replace(/&amp;/g, '&amp;amp;').replace(/&lt;/g, '&amp;gt;').replace(/>/g, '&amp;lt;');
                    var regex = new RegExp(tmp + '(?!([^&lt;]+)?>)', "gi"); // only outside tags
                    el.innerHTML = el.innerHTML.replace(regex, replaceValue);
                }
                function replaceValue(matched) { // mark new
                    return '&lt;span class="w2ui-marker">' + matched + '&lt;/span>';
                }
            });
        }

        function clearMarkedText(index, el) {
            while (el.innerHTML.indexOf('&lt;span class="w2ui-marker">') != -1) {
                el.innerHTML = el.innerHTML.replace(/\&lt;span class=\"w2ui\-marker\"\>((.|\n|\r)*)\&lt;\/span\>/ig, '$1'); // unmark
            }
        }
    };

    // -- w2tag - there can be multiple on screen at a time

    $.fn.w2tag = function (text, options) {
        // only one argument
        if (arguments.length == 1 &amp;&amp; typeof text == 'object') {
            options = text;
            if (options.html != null) text = options.html;
        }
        // default options
        options = $.extend({
            id: null,     // id for the tag, otherwise input id is used
            html: text,     // or html
            position: 'right|top',  // can be left, right, top, bottom
            align: 'none',   // can be none, left, right (only works for potision: top | bottom)
            left: 0,        // delta for left coordinate
            top: 0,        // delta for top coordinate
            style: '',       // adition style for the tag
            css: {},       // add css for input when tag is shown
            className: '',       // add class bubble
            inputClass: '',       // add class for input when tag is shown
            onShow: null,     // callBack when shown
            onHide: null,     // callBack when hidden
            hideOnKeyPress: true,     // hide tag if key pressed
            hideOnBlur: false,    // hide tag on blur
            hideOnClick: false     // hide tag on document click
        }, options);
        if (options.name != null &amp;&amp; options.id == null) options.id = options.name;

        // for backward compatibility
        if (options['class'] !== '' &amp;&amp; options.inputClass === '') options.inputClass = options['class'];

        // remove all tags
        if ($(this).length === 0) {
            $('.w2ui-tag').each(function (index, el) {
                var opt = $(el).data('options');
                if (opt == null) opt = {};
                $($(el).data('taged-el'))
                    .removeClass(opt.inputClass)
                    .removeData('w2tag')
                    .removeData('checkIfMoved');
                clearInterval($(el).data('timer'));
                $(el).remove();
            });
            return;
        }
        return $(this).each(function (index, el) {
            // show or hide tag
            var origID = (options.id ? options.id : el.id);
            var tagID = w2utils.escapeId(origID);
            var $tags = $('#w2ui-tag-' + tagID);
            if (text === '' || text == null) {
                // remmove element
                $tags.css('opacity', 0);
                clearInterval($tags.data('timer'));
                $tags.remove();
                return;
            } else if ($tags.length !== 0) {
                // if already present
                options = $.extend($tags.data('options'), options);
                $tags.data('options', options);
                $tags.find('.w2ui-tag-body')
                    .attr('style', options.style)
                    .addClass(options.className)
                    .html(options.html);
                checkIfMoved(true);
            } else {
                var originalCSS = '';
                if ($(el).length > 0) originalCSS = $(el)[0].style.cssText;
                // insert
                $('body').append(
                    '&lt;div onclick="event.stopPropagation()" style="display:none;" id="w2ui-tag-' + origID + '" ' +
                    '       class="w2ui-tag ' + ($(el).parents('.w2ui-popup, .w2ui-overlay-popup, .w2ui-message').length > 0 ? 'w2ui-tag-popup' : '') + '">' +
                    '   &lt;div style="margin: -2px 0px 0px -2px; white-space: nowrap;">' +
                    '      &lt;div class="w2ui-tag-body ' + options.className + '" style="' + (options.style || '') + '">' + text + '&lt;/div>' +
                    '   &lt;/div>' +
                    '&lt;/div>');
                $tags = $('#w2ui-tag-' + tagID);
                $(el).data('w2tag', $tags.get(0)).data('checkIfMoved', checkIfMoved);
            }

            // need time out to allow tag to be rendered
            setTimeout(function () {
                $tags.css('display', 'block');
                if (!$(el).offset()) return;
                var pos = checkIfMoved(true);
                if (pos == null) return;
                $tags.css({
                    opacity: '1',
                    left: pos.left + 'px',
                    top: pos.top + 'px'
                })
                    .data('options', options)
                    .data('taged-el', el)
                    .data('position', pos.left + 'x' + pos.top)
                    .data('timer', setTimeout(checkIfMoved, 100))
                    .find('.w2ui-tag-body').addClass(pos['posClass']);

                $(el).css(options.css)
                    .off('.w2tag')
                    .addClass(options.inputClass);

                if (options.hideOnKeyPress) {
                    $(el).on('keypress.w2tag', hideTag);
                }
                if (options.hideOnBlur) {
                    $(el).on('blur.w2tag', hideTag);
                }
                if (options.hideOnClick) {
                    $(document).on('click.w2tag', hideTag)
                }
                if (typeof options.onShow === 'function') options.onShow();
            }, 1);

            // bind event to hide it
            function hideTag() {
                $tags = $('#w2ui-tag-' + tagID);
                if ($tags.length &lt;= 0) return;
                clearInterval($tags.data('timer'));
                $tags.remove();
                $(document).off('.w2tag');
                $(el).off('.w2tag', hideTag)
                    .removeClass(options.inputClass)
                    .removeData('w2tag')
                    .removeData('checkIfMoved');
                if ($(el).length > 0) $(el)[0].style.cssText = originalCSS;
                if (typeof options.onHide === 'function') options.onHide();
            }

            function checkIfMoved(checkOnly, instant) {
                // monitor if destroyed
                var offset = $(el).offset();
                if ($(el).length === 0 || (offset.left === 0 &amp;&amp; offset.top === 0) || $tags.find('.w2ui-tag-body').length === 0) {
                    clearInterval($tags.data('timer'));
                    hideTag();
                    return;
                }
                if (!instant) setTimeout(checkIfMoved, 100);
                // monitor if moved
                var posClass = 'w2ui-tag-right';
                var posLeft = parseInt(offset.left + el.offsetWidth + (options.left ? options.left : 0));
                var posTop = parseInt(offset.top + (options.top ? options.top : 0));
                var tagBody = $tags.find('.w2ui-tag-body');
                var width = tagBody[0].offsetWidth;
                var height = tagBody[0].offsetHeight;
                if (typeof options.position == 'string' &amp;&amp; options.position.indexOf('|') != -1) {
                    options.position = options.position.split('|');
                }
                if (options.position == 'top') {
                    posClass = 'w2ui-tag-top';
                    posLeft = parseInt(offset.left + (options.left ? options.left : 0)) - 14;
                    posTop = parseInt(offset.top + (options.top ? options.top : 0)) - height - 10;
                }
                else if (options.position == 'bottom') {
                    posClass = 'w2ui-tag-bottom';
                    posLeft = parseInt(offset.left + (options.left ? options.left : 0)) - 14;
                    posTop = parseInt(offset.top + el.offsetHeight + (options.top ? options.top : 0)) + 10;
                }
                else if (options.position == 'left') {
                    posClass = 'w2ui-tag-left';
                    posLeft = parseInt(offset.left + (options.left ? options.left : 0)) - width - 20;
                    posTop = parseInt(offset.top + (options.top ? options.top : 0));
                }
                else if (Array.isArray(options.position)) {
                    // try to fit the tag on screen in the order defined in the array
                    var maxWidth = window.innerWidth;
                    var maxHeight = window.innerHeight
                    for (var i = 0; i &lt; options.position.length; i++) {
                        var pos = options.position[i];
                        if (pos == 'right') {
                            posClass = 'w2ui-tag-right';
                            posLeft = parseInt(offset.left + el.offsetWidth + (options.left ? options.left : 0));
                            posTop = parseInt(offset.top + (options.top ? options.top : 0));
                            if (posLeft + width &lt;= maxWidth) break;
                        }
                        else if (pos == 'left') {
                            posClass = 'w2ui-tag-left';
                            posLeft = parseInt(offset.left + (options.left ? options.left : 0)) - width - 20;
                            posTop = parseInt(offset.top + (options.top ? options.top : 0));
                            if (posLeft >= 0) break;
                        }
                        else if (pos == 'top') {
                            posClass = 'w2ui-tag-top';
                            posLeft = parseInt(offset.left + (options.left ? options.left : 0)) - 14;
                            posTop = parseInt(offset.top + (options.top ? options.top : 0)) - height - 10;
                            if (posLeft + width &lt;= maxWidth &amp;&amp; posTop >= 0) break;
                        }
                        else if (pos == 'bottom') {
                            posClass = 'w2ui-tag-bottom';
                            posLeft = parseInt(offset.left + (options.left ? options.left : 0)) - 14;
                            posTop = parseInt(offset.top + el.offsetHeight + (options.top ? options.top : 0)) + 10;
                            if (posLeft + width &lt;= maxWidth &amp;&amp; posTop + height &lt;= maxHeight) break;
                        }
                    }
                    if (tagBody.data('posClass') !== posClass) {
                        tagBody.removeClass('w2ui-tag-right w2ui-tag-left w2ui-tag-top w2ui-tag-bottom')
                            .addClass(posClass)
                            .data('posClass', posClass);
                    }
                }
                if ($tags.data('position') !== posLeft + 'x' + posTop &amp;&amp; checkOnly !== true) {
                    $tags.css(w2utils.cssPrefix({'transition': (instant ? '0s' : '.2s')})).css({
                        left: posLeft + 'px',
                        top: posTop + 'px'
                    }).data('position', posLeft + 'x' + posTop);
                }
                return {left: posLeft, top: posTop, posClass: posClass};
            }
        });
    };

    // w2overlay - appears under the element, there can be only one at a time

    $.fn.w2overlay = function (html, options) {
        var obj = this;
        var name = '';
        var defaults = {
            name: null,              // it not null, then allows multiple concurrent overlays
            html: '',                // html text to display
            align: 'none',            // can be none, left, right, both
            left: 0,                 // offset left
            top: 0,                 // offset top
            tipLeft: 30,                // tip offset left
            noTip: false,             // if true - no tip will be displayed
            selectable: false,
            width: 0,                 // fixed width
            height: 0,                 // fixed height
            maxWidth: null,              // max width if any
            maxHeight: null,              // max height if any
            contextMenu: false,             // if true, it will be opened at mouse position
            pageX: null,
            pageY: null,
            originalEvent: null,
            style: '',                // additional style for main div
            'class': '',                // additional class name for main div
            overlayStyle: '',
            onShow: null,              // event on show
            onHide: null,              // event on hide
            openAbove: false,             // show above control
            tmp: {}
        };
        if (arguments.length == 1) {
            if (typeof html == 'object') {
                options = html;
            } else {
                options = {html: html};
            }
        }
        if (arguments.length == 2) options.html = html;
        if (!$.isPlainObject(options)) options = {};
        options = $.extend({}, defaults, options);
        if (options.name) name = '-' + options.name;
        // hide
        var tmp_hide;
        if (this.length === 0 || options.html === '' || options.html == null) {
            if ($('#w2ui-overlay' + name).length > 0) {
                tmp_hide = $('#w2ui-overlay' + name)[0].hide;
                if (typeof tmp_hide === 'function') tmp_hide();
            } else {
                $('#w2ui-overlay' + name).remove();
            }
            return $(this);
        }
        // hide previous if any
        if ($('#w2ui-overlay' + name).length > 0) {
            tmp_hide = $('#w2ui-overlay' + name)[0].hide;
            $(document).off('.w2overlayHide');
            if (typeof tmp_hide === 'function') tmp_hide();
        }
        if (obj.length > 0 &amp;&amp; (obj[0].tagName == null || obj[0].tagName.toUpperCase() == 'BODY')) options.contextMenu = true;
        if (options.contextMenu &amp;&amp; options.originalEvent) {
            options.pageX = options.originalEvent.pageX;
            options.pageY = options.originalEvent.pageY;
        }
        if (options.contextMenu &amp;&amp; (options.pageX == null || options.pageY == null)) {
            console.log('ERROR: to display menu at mouse location, pass options.pageX and options.pageY.');
        }
        // append
        $('body').append(
            '&lt;div id="w2ui-overlay' + name + '" style="display: none; left: 0px; top: 0px; ' + options.overlayStyle + '"' +
            '        class="w2ui-reset w2ui-overlay ' + ($(this).parents('.w2ui-popup, .w2ui-overlay-popup, .w2ui-message').length > 0 ? 'w2ui-overlay-popup' : '') + '">' +
            '    &lt;style>&lt;/style>' +
            '    &lt;div style="min-width: 100%; ' + options.style + '" class="' + options['class'] + '">&lt;/div>' +
            '&lt;/div>'
        );
        // init
        var div1 = $('#w2ui-overlay' + name);
        var div2 = div1.find(' > div');
        div2.html(options.html);
        // pick bg color of first div
        var bc = div2.css('background-color');
        if (bc != null &amp;&amp; bc !== 'rgba(0, 0, 0, 0)' &amp;&amp; bc !== 'transparent') div1.css({
            'background-color': bc,
            'border-color': bc
        });

        var offset = $(obj).offset() || {};
        div1.data('element', obj.length > 0 ? obj[0] : null)
            .data('options', options)
            .data('position', offset.left + 'x' + offset.top)
            .fadeIn('fast')
            .on('click', function (event) {
                // if there is label for input, it will produce 2 click events
                if (event.target.tagName.toUpperCase() == 'LABEL') event.stopPropagation();
            })
            .on('mousedown', function (event) {
                $('#w2ui-overlay' + name).data('keepOpen', true);
                if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(event.target.tagName.toUpperCase()) == -1 &amp;&amp; !options.selectable) {
                    event.preventDefault();
                }
            });
        div1[0].hide = hide;
        div1[0].resize = resize;

        // need time to display
        setTimeout(function () {
            resize();
            $(document).off('.w2overlayHide').on('click.w2overlayHide', hide);
            if (typeof options.onShow === 'function') options.onShow();
        }, 10);

        monitor();
        return $(this);

        // monitor position
        function monitor() {
            var tmp = $('#w2ui-overlay' + name);
            if (tmp.data('element') !== obj[0]) return; // it if it different overlay
            if (tmp.length === 0) return;
            var offset = $(obj).offset() || {};
            var pos = offset.left + 'x' + offset.top;
            if (tmp.data('position') !== pos) {
                hide();
            } else {
                setTimeout(monitor, 250);
            }
        }

        // click anywhere else hides the drop down
        function hide(event) {
            if (event &amp;&amp; event.button !== 0) return; // only for left click button
            var div1 = $('#w2ui-overlay' + name);
            if (div1.data('keepOpen') === true) {
                div1.removeData('keepOpen');
                return;
            }
            var result;
            if (typeof options.onHide === 'function') result = options.onHide();
            if (result === false) return;
            div1.remove();
            $(document).off('click', hide);
            clearInterval(div1.data('timer'));
        }

        function resize() {
            var div1 = $('#w2ui-overlay' + name);
            var div2 = div1.find(' > div');
            var menu = $('#w2ui-overlay' + name + ' div.menu');
            menu.css('overflow-y', 'hidden');
            // if goes over the screen, limit height and width
            if (div1.length > 0) {
                div2.height('auto').width('auto');
                // width/height
                var overflowX = false;
                var overflowY = false;
                var h = div2.height();
                var w = div2.width();
                if (options.width &amp;&amp; options.width &lt; w) w = options.width;
                if (w &lt; 30) w = 30;
                // if content of specific height
                if (options.tmp.contentHeight) {
                    h = parseInt(options.tmp.contentHeight);
                    div2.height(h);
                    setTimeout(function () {
                        var $div = div2.find('div.menu');
                        if (h > $div.height()) {
                            div2.find('div.menu').css('overflow-y', 'hidden');
                        }
                    }, 1);
                    setTimeout(function () {
                        var $div = div2.find('div.menu');
                        if ($div.css('overflow-y') != 'auto') $div.css('overflow-y', 'auto');
                    }, 10);
                }
                if (options.tmp.contentWidth &amp;&amp; options.align != 'both') {
                    w = parseInt(options.tmp.contentWidth);
                    div2.width(w);
                    setTimeout(function () {
                        if (w > div2.find('div.menu > table').width()) {
                            div2.find('div.menu > table').css('overflow-x', 'hidden');
                        }
                    }, 1);
                    setTimeout(function () {
                        div2.find('div.menu > table').css('overflow-x', 'auto');
                    }, 10);
                }
                // adjust position
                var boxLeft = options.left;
                var boxWidth = options.width;
                var tipLeft = options.tipLeft;
                // alignment
                switch (options.align) {
                    case 'both':
                        boxLeft = 17;
                        if (options.width === 0) options.width = w2utils.getSize($(obj), 'width');
                        if (options.maxWidth &amp;&amp; options.width > options.maxWidth) options.width = options.maxWidth;
                        break;
                    case 'left':
                        boxLeft = 17;
                        break;
                    case 'right':
                        boxLeft = w2utils.getSize($(obj), 'width') - w + 10;
                        tipLeft = w - 40;
                        break;
                }
                if (w === 30 &amp;&amp; !boxWidth) boxWidth = 30; else boxWidth = (options.width ? options.width : 'auto');
                var tmp = (w - 17) / 2;
                if (boxWidth != 'auto') tmp = (boxWidth - 17) / 2;
                if (tmp &lt; 25) {
                    boxLeft = 25 - tmp;
                    tipLeft = Math.floor(tmp);
                }
                // Y coord
                var X, Y, offsetTop;
                if (options.contextMenu) { // context menu
                    X = options.pageX + 8;
                    Y = options.pageY - 0;
                    offsetTop = options.pageY;
                } else {
                    var offset = obj.offset() || {};
                    X = ((offset.left > 25 ? offset.left : 25) + boxLeft);
                    Y = (offset.top + w2utils.getSize(obj, 'height') + options.top + 7);
                    offsetTop = offset.top;
                }
                div1.css({
                    left: X + 'px',
                    top: Y + 'px',
                    'min-width': boxWidth,
                    'min-height': (options.height ? options.height : 'auto')
                });
                // $(window).height() - has a problem in FF20
                var offset = div2.offset() || {};
                var maxHeight = window.innerHeight + $(document).scrollTop() - offset.top - 7;
                var maxWidth = window.innerWidth + $(document).scrollLeft() - offset.left - 7;
                if (options.contextMenu) { // context menu
                    maxHeight = window.innerHeight + $(document).scrollTop() - options.pageY - 15;
                    maxWidth = window.innerWidth + $(document).scrollLeft() - options.pageX;
                }

                if ((maxHeight > -50 &amp;&amp; maxHeight &lt; 210) || options.openAbove === true) {
                    var tipOffset;
                    // show on top
                    if (options.contextMenu) { // context menu
                        maxHeight = options.pageY - 7;
                        tipOffset = 5;
                    } else {
                        maxHeight = offset.top - $(document).scrollTop() - 7;
                        tipOffset = 24;
                    }
                    if (options.maxHeight &amp;&amp; maxHeight > options.maxHeight) maxHeight = options.maxHeight;
                    if (h > maxHeight) {
                        overflowY = true;
                        div2.height(maxHeight).width(w).css({'overflow-y': 'auto'});
                        h = maxHeight;
                    }
                    div1.addClass('bottom-arrow');
                    div1.css('top', (offsetTop - h - tipOffset + options.top) + 'px');
                    div1.find('>style').html(
                        '#w2ui-overlay' + name + ':before { margin-left: ' + parseInt(tipLeft) + 'px; }' +
                        '#w2ui-overlay' + name + ':after { margin-left: ' + parseInt(tipLeft) + 'px; }'
                    );
                } else {
                    // show under
                    if (options.maxHeight &amp;&amp; maxHeight > options.maxHeight) maxHeight = options.maxHeight;
                    if (h > maxHeight) {
                        overflowY = true;
                        div2.height(maxHeight).width(w).css({'overflow-y': 'auto'});
                    }
                    div1.addClass('top-arrow');
                    div1.find('>style').html(
                        '#w2ui-overlay' + name + ':before { margin-left: ' + parseInt(tipLeft) + 'px; }' +
                        '#w2ui-overlay' + name + ':after { margin-left: ' + parseInt(tipLeft) + 'px; }'
                    );
                }
                // check width
                w = div2.width();
                maxWidth = window.innerWidth + $(document).scrollLeft() - offset.left - 7;
                if (options.maxWidth &amp;&amp; maxWidth > options.maxWidth) maxWidth = options.maxWidth;
                if (w > maxWidth &amp;&amp; options.align !== 'both') {
                    options.align = 'right';
                    setTimeout(function () {
                        resize();
                    }, 1);
                }
                // don't show tip
                if (options.contextMenu || options.noTip) { // context menu
                    div1.find('>style').html(
                        '#w2ui-overlay' + name + ':before { display: none; }' +
                        '#w2ui-overlay' + name + ':after { display: none; }'
                    );
                }
                // check scroll bar (needed to avoid horizontal scrollbar)
                if (overflowY &amp;&amp; options.align != 'both') div2.width(w + w2utils.scrollBarSize() + 2);
            }
            menu.css('overflow-y', 'auto');
        }
    };

    $.fn.w2menu = function (menu, options) {
        /*
         ITEM STRUCTURE
         item : {
         id       : null,
         text     : '',
         style    : '',
         img      : '',
         icon     : '',
         count    : '',
         tooltip  : '',
         hidden   : false,
         checked  : null,
         disabled : false
         ...
         }
         */
        // if items is a function
        if (options &amp;&amp; typeof options.items == 'function') {
            options.items = options.items();
        }
        var defaults = {
            type: 'normal',    // can be normal, radio, check
            index: null,        // current selected
            items: [],
            render: null,
            msgNoItems: 'No items',
            onSelect: null,
            tmp: {}
        };
        var obj = this;
        var name = '';
        if (menu === 'refresh') {
            // if not show - call blur
            if ($('#w2ui-overlay' + name).length > 0) {
                options = $.extend($.fn.w2menuOptions, options);
                var scrTop = $('#w2ui-overlay' + name + ' div.menu').scrollTop();
                $('#w2ui-overlay' + name + ' div.menu').html(getMenuHTML());
                $('#w2ui-overlay' + name + ' div.menu').scrollTop(scrTop);
                mresize();
            } else {
                $(this).w2menu(options);
            }
        } else if (menu === 'refresh-index') {
            var $menu = $('#w2ui-overlay' + name + ' div.menu');
            var cur = $menu.find('tr[index=' + options.index + ']');
            var scrTop = $menu.scrollTop();
            $menu.find('tr.w2ui-selected').removeClass('w2ui-selected'); // clear all
            cur.addClass('w2ui-selected'); // select current
            // scroll into view
            if (cur.length > 0) {
                var top = cur[0].offsetTop - 5; // 5 is margin top
                var height = $menu.height();
                $menu.scrollTop(scrTop);
                if (top &lt; scrTop || top + cur.height() > scrTop + height) {
                    $menu.animate({'scrollTop': top - (height - cur.height() * 2) / 2}, 200, 'linear');
                }
            }
            mresize();
        } else {
            if (arguments.length === 1) options = menu; else options.items = menu;
            if (typeof options !== 'object') options = {};
            options = $.extend({}, defaults, options);
            $.fn.w2menuOptions = options;
            if (options.name) name = '-' + options.name;
            if (typeof options.select === 'function' &amp;&amp; typeof options.onSelect !== 'function') options.onSelect = options.select;
            if (typeof options.onRender === 'function' &amp;&amp; typeof options.render !== 'function') options.render = options.onRender;
            // since only one overlay can exist at a time
            $.fn.w2menuClick = function (event, index) {
                var keepOpen = false;
                if (['radio', 'check'].indexOf(options.type) != -1) {
                    if (event.shiftKey || event.metaKey || event.ctrlKey) keepOpen = true;
                }
                if (typeof options.onSelect === 'function') {
                    // need time so that menu first hides
                    setTimeout(function () {
                        options.onSelect({
                            index: index,
                            item: options.items[index],
                            keepOpen: keepOpen,
                            originalEvent: event
                        });
                    }, 10);
                }
                // do not uncomment (or enum search type is not working in grid)
                // setTimeout(function () { $(document).click(); }, 50);
                // -- hide
                var div = $('#w2ui-overlay' + name);
                div.removeData('keepOpen');
                if (typeof div[0].hide === 'function' &amp;&amp; !keepOpen) {
                    div[0].hide();
                }
            };
            $.fn.w2menuDown = function (event, index) {
                var $el = $(event.target).parents('tr');
                var tmp = $el.find('.w2ui-icon');
                if ((options.type == 'check') || (options.type == 'radio')) {
                    var item = options.items[index];
                    item.checked = !item.checked;
                    if (item.checked) {
                        if (options.type == 'radio') {
                            tmp.parents('table').find('.w2ui-icon')
                                .removeClass('w2ui-icon-check')
                                .addClass('w2ui-icon-empty');
                        }
                        tmp.removeClass('w2ui-icon-empty').addClass('w2ui-icon-check');
                    } else if (options.type == 'check') {
                        tmp.removeClass('w2ui-icon-check').addClass('w2ui-icon-empty');
                    }
                }
                // highlight record
                $el.parent().find('tr').removeClass('w2ui-selected');
                $el.addClass('w2ui-selected');
            };
            var html = '';
            if (options.search) {
                html +=
                    '&lt;div style="position: absolute; top: 0px; height: 40px; left: 0px; right: 0px; border-bottom: 1px solid silver; background-color: #ECECEC; padding: 8px 5px;">' +
                    '    &lt;div class="w2ui-icon icon-search" style="position: absolute; margin-top: 4px; margin-left: 6px; width: 11px; background-position: left !important;">&lt;/div>' +
                    '    &lt;input id="menu-search" type="text" style="width: 100%; outline: none; padding-left: 20px;" onclick="event.stopPropagation();"/>' +
                    '&lt;/div>';
                options.style += ';background-color: #ECECEC';
                options.index = 0;
                for (var i = 0; i &lt; options.items.length; i++) options.items[i].hidden = false;
            }
            html += '&lt;div class="menu" style="position: absolute; top: ' + (options.search ? 40 : 0) + 'px; bottom: 0px; width: 100%;">' +
                getMenuHTML() +
                '&lt;/div>';
            var ret = $(this).w2overlay(html, options);
            setTimeout(function () {
                $('#w2ui-overlay' + name + ' #menu-search')
                    .on('keyup', change)
                    .on('keydown', function (event) {
                        // cancel tab key
                        if (event.keyCode === 9) {
                            event.stopPropagation();
                            event.preventDefault();
                        }
                    });
                if (options.search) {
                    if (['text', 'password'].indexOf($(obj)[0].type) != -1 || $(obj)[0].tagName.toUpperCase() == 'TEXTAREA') return;
                    $('#w2ui-overlay' + name + ' #menu-search').focus();
                }
                mresize();
            }, 200);
            mresize();
            return ret;
        }
        return;

        function mresize() {
            setTimeout(function () {
                // show selected
                $('#w2ui-overlay' + name + ' tr.w2ui-selected').removeClass('w2ui-selected');
                var cur = $('#w2ui-overlay' + name + ' tr[index=' + options.index + ']');
                var scrTop = $('#w2ui-overlay' + name + ' div.menu').scrollTop();
                cur.addClass('w2ui-selected');
                if (options.tmp) options.tmp.contentHeight = $('#w2ui-overlay' + name + ' table').height() + (options.search ? 50 : 10);
                if (options.tmp) options.tmp.contentWidth = $('#w2ui-overlay' + name + ' table').width();
                if ($('#w2ui-overlay' + name).length > 0) $('#w2ui-overlay' + name)[0].resize();
                // scroll into view
                if (cur.length > 0) {
                    var top = cur[0].offsetTop - 5; // 5 is margin top
                    var el = $('#w2ui-overlay' + name + ' div.menu');
                    var height = el.height();
                    $('#w2ui-overlay' + name + ' div.menu').scrollTop(scrTop);
                    if (top &lt; scrTop || top + cur.height() > scrTop + height) {
                        $('#w2ui-overlay' + name + ' div.menu').animate({'scrollTop': top - (height - cur.height() * 2) / 2}, 200, 'linear');
                    }
                }
            }, 1);
        }

        function change(event) {
            var search = this.value;
            var key = event.keyCode;
            var cancel = false;
            switch (key) {
                case 13: // enter
                    $('#w2ui-overlay' + name).remove();
                    $.fn.w2menuClick(event, options.index);
                    break;
                case 9:  // tab
                case 27: // escape
                    $('#w2ui-overlay' + name).remove();
                    $.fn.w2menuClick(event, -1);
                    break;
                case 38: // up
                    options.index = w2utils.isInt(options.index) ? parseInt(options.index) : 0;
                    options.index--;
                    while (options.index > 0 &amp;&amp; options.items[options.index].hidden) options.index--;
                    if (options.index === 0 &amp;&amp; options.items[options.index].hidden) {
                        while (options.items[options.index] &amp;&amp; options.items[options.index].hidden) options.index++;
                    }
                    if (options.index &lt; 0) options.index = 0;
                    cancel = true;
                    break;
                case 40: // down
                    options.index = w2utils.isInt(options.index) ? parseInt(options.index) : 0;
                    options.index++;
                    while (options.index &lt; options.items.length - 1 &amp;&amp; options.items[options.index].hidden) options.index++;
                    if (options.index === options.items.length - 1 &amp;&amp; options.items[options.index].hidden) {
                        while (options.items[options.index] &amp;&amp; options.items[options.index].hidden) options.index--;
                    }
                    if (options.index >= options.items.length) options.index = options.items.length - 1;
                    cancel = true;
                    break;
            }
            // filter
            if (!cancel) {
                var shown = 0;
                for (var i = 0; i &lt; options.items.length; i++) {
                    var item = options.items[i];
                    var prefix = '';
                    var suffix = '';
                    if (['is', 'begins with'].indexOf(options.match) !== -1) prefix = '^';
                    if (['is', 'ends with'].indexOf(options.match) !== -1) suffix = '$';
                    try {
                        var re = new RegExp(prefix + search + suffix, 'i');
                        if (re.test(item.text) || item.text === '...') item.hidden = false; else item.hidden = true;
                    } catch (e) {
                    }
                    // do not show selected items
                    if (obj.type === 'enum' &amp;&amp; $.inArray(item.id, ids) !== -1) item.hidden = true;
                    if (item.hidden !== true) shown++;
                }
                options.index = 0;
                while (options.index &lt; options.items.length - 1 &amp;&amp; options.items[options.index].hidden) options.index++;
                if (shown &lt;= 0) options.index = -1;
            }
            $(obj).w2menu('refresh', options);
            mresize();
        }

        function getMenuHTML() {
            if (options.spinner) {
                return '&lt;table class="w2ui-drop-menu">&lt;tbody>&lt;tr>&lt;td style="padding: 5px 10px 10px 10px; text-align: center">' +
                    '    &lt;div class="w2ui-spinner" style="width: 18px; height: 18px; position: relative; top: 5px;">&lt;/div> ' +
                    '    &lt;div style="display: inline-block; padding: 3px; color: #999;">' + w2utils.lang('Loading...') + '&lt;/div>' +
                    '&lt;/td>&lt;/tr>&lt;/tbody>&lt;/table>';
            }
            var count = 0;
            var menu_html = '&lt;table cellspacing="0" cellpadding="0" class="w2ui-drop-menu">&lt;tbody>';
            var img = null, icon = null;
            for (var f = 0; f &lt; options.items.length; f++) {
                var mitem = options.items[f];
                if (typeof mitem === 'string') {
                    mitem = {id: mitem, text: mitem};
                } else {
                    if (mitem.text != null &amp;&amp; mitem.id == null) mitem.id = mitem.text;
                    if (mitem.text == null &amp;&amp; mitem.id != null) mitem.text = mitem.id;
                    if (mitem.caption != null) mitem.text = mitem.caption;
                    img = mitem.img;
                    icon = mitem.icon;
                    if (img == null) img = null; // img might be undefined
                    if (icon == null) icon = null; // icon might be undefined
                }
                if (['radio', 'check'].indexOf(options.type) != -1) {
                    if (mitem.checked === true) icon = 'w2ui-icon-check'; else icon = 'w2ui-icon-empty';
                }
                if (mitem.hidden !== true) {
                    var imgd = '';
                    var txt = mitem.text;
                    if (typeof options.render === 'function') txt = options.render(mitem, options);
                    if (img) imgd = '&lt;td class="menu-icon">&lt;div class="w2ui-tb-image w2ui-icon ' + img + '">&lt;/div>&lt;/td>';
                    if (icon) imgd = '&lt;td class="menu-icon" align="center">&lt;span class="w2ui-icon ' + icon + '">&lt;/span>&lt;/td>';
                    // render only if non-empty
                    if (txt != null &amp;&amp; txt !== '' &amp;&amp; !(/^-+$/.test(txt))) {
                        var bg = (count % 2 === 0 ? 'w2ui-item-even' : 'w2ui-item-odd');
                        if (options.altRows !== true) bg = '';
                        var colspan = 1;
                        if (imgd === '') colspan++;
                        if (mitem.count == null &amp;&amp; mitem.hotkey == null) colspan++;
                        if (mitem.tooltip == null &amp;&amp; mitem.hint != null) mitem.tooltip = mitem.hint; // for backward compatibility
                        menu_html +=
                            '&lt;tr index="' + f + '" style="' + (mitem.style ? mitem.style : '') + '" ' + (mitem.tooltip ? 'title="' + w2utils.lang(mitem.tooltip) + '"' : '') +
                            '        class="' + bg + ' ' + (options.index === f ? 'w2ui-selected' : '') + ' ' + (mitem.disabled === true ? 'w2ui-disabled' : '') + '"' +
                            '        onmousedown="if (' + (mitem.disabled === true ? 'true' : 'false') + ') return;' +
                            '               jQuery.fn.w2menuDown(event, \'' + f + '\');"' +
                            '        onclick="event.stopPropagation(); ' +
                            '               if (' + (mitem.disabled === true ? 'true' : 'false') + ') return;' +
                            '               jQuery.fn.w2menuClick(event, \'' + f + '\');">' +
                            imgd +
                            '   &lt;td class="menu-text" colspan="' + colspan + '">' + w2utils.lang(txt) + '&lt;/td>' +
                            '   &lt;td class="menu-count">' +
                            (mitem.count != null ? '&lt;span>' + mitem.count + '&lt;/span>' : '') +
                            (mitem.hotkey != null ? '&lt;span class="hotkey">' + mitem.hotkey + '&lt;/span>' : '') +
                            '&lt;/td>' +
                            '&lt;/tr>';
                        count++;
                    } else {
                        // horizontal line
                        menu_html += '&lt;tr>&lt;td colspan="3" style="padding: 6px; pointer-events: none">&lt;div style="border-top: 1px solid silver;">&lt;/div>&lt;/td>&lt;/tr>';
                    }
                }
                options.items[f] = mitem;
            }
            if (count === 0) {
                menu_html += '&lt;tr>&lt;td style="padding: 13px; color: #999; text-align: center">' + options.msgNoItems + '&lt;/div>&lt;/td>&lt;/tr>';
            }
            menu_html += "&lt;/tbody>&lt;/table>";
            return menu_html;
        }
    };

    $.fn.w2color = function (options, callBack) {
        var obj = this;
        var el = $(this)[0];
        var index = [-1, -1];
        if ($.fn.w2colorPalette == null) {
            $.fn.w2colorPalette = [
                ['000000', '555555', '888888', 'BBBBBB', 'DDDDDD', 'EEEEEE', 'F7F7F7', 'FFFFFF'],
                ['FF011B', 'FF9838', 'FFFD59', '01FD55', '00FFFE', '006CE7', '9B24F4', 'FF21F5'],
                ['FFEAEA', 'FCEFE1', 'FCF5E1', 'EBF7E7', 'E9F3F5', 'ECF4FC', 'EAE6F4', 'F5E7ED'],
                ['F4CCCC', 'FCE5CD', 'FFF2CC', 'D9EAD3', 'D0E0E3', 'CFE2F3', 'D9D1E9', 'EAD1DC'],
                ['EA9899', 'F9CB9C', 'FEE599', 'B6D7A8', 'A2C4C9', '9FC5E8', 'B4A7D6', 'D5A6BD'],
                ['E06666', 'F6B26B', 'FED966', '93C47D', '76A5AF', '6FA8DC', '8E7CC3', 'C27BA0'],
                ['CC0814', 'E69138', 'F1C232', '6AA84F', '45818E', '3D85C6', '674EA7', 'A54D79'],
                ['99050C', 'B45F17', 'BF901F', '37761D', '124F5C', '0A5394', '351C75', '741B47'],
                // ['660205', '783F0B', '7F6011', '274E12', '0C343D', '063762', '20124D', '4C1030'],
                ['F2F2F2', 'F2F2F2', 'F2F2F2', 'F2F2F2', 'F2F2F2'] // custom colors (up to 4)
            ];
        }
        var pal = $.fn.w2colorPalette;
        if (typeof options == 'string') options = {
            color: options,
            transparent: true
        };
        // add remove transarent color
        if (options.transparent &amp;&amp; pal[0][1] == '555555') {
            pal[0].splice(1, 1);
            pal[0].push('');
        }
        if (!options.transparent &amp;&amp; pal[0][1] != '555555') {
            pal[0].splice(1, 0, '555555');
            pal[0].pop();
        }
        if (options.color) options.color = String(options.color).toUpperCase();

        if ($('#w2ui-overlay').length === 0) {
            $(el).w2overlay(getColorHTML(options), {
                onHide: function () {
                    if (typeof callBack == 'function') callBack($(el).data('_color'));
                    $(el).removeData('_color');
                }
            });
        } else { // only refresh contents
            $('#w2ui-overlay .w2ui-color').parent().html(getColorHTML(options));
        }
        // bind events
        $('#w2ui-overlay .color')
            .off('.w2color')
            .on('mousedown.w2color', function (event) {
                var color = $(event.originalEvent.target).attr('name');
                index = $(event.originalEvent.target).attr('index').split(':');
                $(el).data('_color', color);
            })
            .on('mouseup.w2color', function () {
                setTimeout(function () {
                    if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay').removeData('keepOpen')[0].hide();
                }, 10);
            });
        $('#w2ui-overlay input')
            .off('.w2color')
            .on('mousedown.w2color', function (event) {
                $('#w2ui-overlay').data('keepOpen', true);
                setTimeout(function () {
                    $('#w2ui-overlay').data('keepOpen', true);
                }, 10);
                event.stopPropagation();
            })
            .on('keyup.w2color', function (event) {
                if (this.value !== '' &amp;&amp; this.value[0] !== '#') this.value = '#' + this.value;
            })
            .on('change.w2color', function (event) {
                var tmp = this.value;
                if (tmp.substr(0, 1) == '#') tmp = tmp.substr(1);
                if (tmp.length != 6) {
                    $(this).w2tag('Invalid color.');
                    return;
                }
                $.fn.w2colorPalette[pal.length - 1].unshift(tmp.toUpperCase());
                $(el).w2color(options, callBack);
                setTimeout(function () {
                    $('#w2ui-overlay input')[0].focus();
                }, 100);
            })
            .w2field('hex');

        el.nav = function (direction) {
            switch (direction) {
                case 'up':
                    index[0]--;
                    break;
                case 'down':
                    index[0]++;
                    break;
                case 'right':
                    index[1]++;
                    break;
                case 'left':
                    index[1]--;
                    break;
            }
            if (index[0] &lt; 0) index[0] = 0;
            if (index[0] > pal.length - 2) index[0] = pal.length - 2;
            if (index[1] &lt; 0) index[1] = 0;
            if (index[1] > pal[0].length - 1) index[1] = pal[0].length - 1;

            color = pal[index[0]][index[1]];
            $(el).data('_color', color);
            return color;
        };

        function getColorHTML(options) {
            var color = options.color;
            var html = '&lt;div class="w2ui-color" onmousedown="event.stopPropagation(); event.preventDefault()">' + // prevent default is needed otherwiser selection gets unselected
                '&lt;table cellspacing="5">&lt;tbody>';
            for (var i = 0; i &lt; pal.length - 1; i++) {
                html += '&lt;tr>';
                for (var j = 0; j &lt; pal[i].length; j++) {
                    html += '&lt;td>' +
                        '    &lt;div class="color ' + (pal[i][j] === '' ? 'no-color' : '') + '" style="background-color: #' + pal[i][j] + ';" ' +
                        '       name="' + pal[i][j] + '" index="' + i + ':' + j + '">' + (options.color == pal[i][j] ? '&amp;#149;' : '&amp;#160;') +
                        '    &lt;/div>' +
                        '&lt;/td>';
                    if (options.color == pal[i][j]) index = [i, j];
                }
                html += '&lt;/tr>';
                if (i &lt; 2) html += '&lt;tr>&lt;td style="height: 8px" colspan="8">&lt;/td>&lt;/tr>';
            }
            var tmp = pal[pal.length - 1];
            html += '&lt;tr>&lt;td style="height: 8px" colspan="8">&lt;/td>&lt;/tr>' +
                '&lt;tr>' +
                '   &lt;td colspan="4" style="text-align: left">&lt;input placeholder="#FFF000" style="margin-left: 1px; width: 74px" maxlength="7"/>&lt;/td>' +
                '   &lt;td>&lt;div class="color" style="background-color: #' + tmp[0] + ';" name="' + tmp[0] + '" index="8:0">' + (options.color == tmp[0] ? '&amp;#149;' : '&amp;#160;') + '&lt;/div>&lt;/td>' +
                '   &lt;td>&lt;div class="color" style="background-color: #' + tmp[1] + ';" name="' + tmp[1] + '" index="8:0">' + (options.color == tmp[1] ? '&amp;#149;' : '&amp;#160;') + '&lt;/div>&lt;/td>' +
                '   &lt;td>&lt;div class="color" style="background-color: #' + tmp[2] + ';" name="' + tmp[2] + '" index="8:0">' + (options.color == tmp[2] ? '&amp;#149;' : '&amp;#160;') + '&lt;/div>&lt;/td>' +
                '   &lt;td>&lt;div class="color" style="background-color: #' + tmp[3] + ';" name="' + tmp[3] + '" index="8:0">' + (options.color == tmp[3] ? '&amp;#149;' : '&amp;#160;') + '&lt;/div>&lt;/td>' +
                '&lt;/tr>' +
                '&lt;tr>&lt;td style="height: 4px" colspan="8">&lt;/td>&lt;/tr>';
            html += '&lt;/tbody>&lt;/table>&lt;/div>';
            return html;
        }
    };

})(jQuery);

/************************************************************************
 *   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
 *   - Following objects defined
 *        - w2grid        - grid widget
 *        - $().w2grid    - jQuery wrapper
 *   - Dependencies: jQuery, w2utils, w2toolbar, w2fields
 *
 * == NICE TO HAVE ==
 *   - column autosize based on largest content
 *   - reorder columns/records
 *   - problem with .set() and arrays, array get extended too, but should be replaced
 *   - after edit stay on the same record option
 *   - if supplied array of ids, get should return array of records
 *   - allow functions in routeData (also add routeData to list/enum)
 *   - implement global routeData and all elements read from there
 *   - send parsed URL to the event if there is routeData
 *   - if you set searchData or sortData and call refresh() it should work
 *   - add selectType: 'none' so that no selection can be make but with mouse
 *   - reorder records with frozen columns
 *   - focus/blur for selectType = cell not display grayed out selection
 *   - frozen columns
 - load more only on the right side
 - scrolling on frozen columns is not working only on regular columns
 *   - copy or large number of records is slow
 *   - reusable search component (see https://github.com/vitmalina/w2ui/issues/914#issuecomment-107340524)
 *   - allow enum in inline edit (see https://github.com/vitmalina/w2ui/issues/911#issuecomment-107341193)
 *   - if record has no recid, then it should be index in the aray (should not be 0)
 *
 * == KNOWN ISSUES ==
 *   - bug: vs_start = 100 and more then 500 records, when scrolling empty sets
 *   - row drag and drop has bugs
 *   - Shift-click/Ctrl-click/Ctrl-Shift-Click selection is not as robust as it should be
 *
 * == 1.5 changes
 *   - $('#grid').w2grid() - if called w/o argument then it returns grid object
 *   - added statusRange     : true,
 *           statusBuffered  : false,
 *           statusRecordID  : true,
 *           statusSelection : true,
 *           statusResponse  : true,
 *           statusSort      : true,
 *           statusSearch    : true,
 *   - change selectAll() and selectNone() - return time it took
 *   - added vs_start and vs_extra
 *   - added update(cells) - updates only data in the grid (or cells)
 *   - add to docs onColumnDragStart, onColumnDragEnd
 *   - onSelect and onSelect should fire 1 time for selects with shift or selectAll(), selectNone()
 *   - record.w2ui.style[field_name]
 *   - use column field for style: { 1: 'color: red' }
 *   - added focus(), blur(), onFocus, onBlur
 *   - search.simple - if false, will not show up in simple search
 *   - search.operator - default operator to use with search field
 *   - search.operators - array of operators for the serach
 *   - search.hidden - could not be clearned by the user
 *   - search.value - only for hidden searches
 *   - if .search(val) - search all fields
 *   - refactor reorderRow (not finished)
 *   - return JSON can now have summary array
 *   - frozen columns
 *   - added selectionSave, selectionRestore - for internal use
 *   - added additional search filter options for int, float, date, time
 *   - added getLineHTML
 *   - added lineNumberWidth
 *   - add searches.style
 *   - getColumn without params returns fields of all columns
 *   - getSearch without params returns fields of all searches
 *   - added column.tooltip
 *   - added hasFocus, refactored w2utils.keyboard
 *   - do not clear selection when clicked and it was not in focus
 *   - added record.w2ui.colspan
 *   - editable area extends with typing
 *   - removed onSubmit and onDeleted - now it uses onSave and onDelete
 *   - column.seachable - can be an object, which will create search
 *   - added null, not null filters
 *   - update(cells) - added argument cells
 *   - scrollIntoView(..., ..., instant) - added third argument
 *   - added onResizeDblClick
 *   - added onColumnDblClick
 *   - implemented showBubble
 *   - added show.searchAll
 *   - added w2grid.operators
 *   - added w2grid.operatorsMap
 *   - move events into prototype
 *   - move rec.summary, rec.style, rec.editable -> into rec.w2ui.summary, rec.w2ui.style, rec.w2ui.editable
 *   - record: {
        recid
        field1
        ...
        fieldN
        w2ui: {
            colspan: { field: 5, ...}
            editable: true/false
            changes: {
                field: chagned_value,
                ....
            },
            children: [
                // similar to records array
                // can have sub children
            ]
            parent_recid: (internally set, id of the parent record, when children are copied to records array)
            summary: true/false
            style: 'string' - for entire row OR { field: 'string', ...} - per field
            class: 'string' - for entire row OR { field: 'string', ...} - per field
        }
    }
 *   - added this.show.toolbarInput
 *   - disableCVS
 *   - grid.message
 *   - added noReset option to localSort()
 *   - onColumnSelect
 *   - need to update PHP example
 *   - added scrollToColumn(field)
 *   - textSearch: 'begins' (default), 'contains', 'is', ...
 *   - added refreshBody
 *   - added response.total = -1 (or not present) to indicate that number of records is unknown
 *   - message(.., callBack) - added callBack
 *   - grid.msgEmpty
 *   - field.render(..., data) -- added last argument which is what grid thinks should be there
 *   - onSearchOpen (onSearch will have mutli and reset flags)
 *   - added httpHeaders
 *   - col.editable can be a function which will be called with the same args as col.render()
 *   - getCellEditable(index, col_ind) -- return an 'editable' descriptor if cell is really editable
 *   - added stateId
 *   - rec.w2ui.class (and rec.w2ui.class { fname: '...' })
 *   - columnTooltip
 *   - expendable grids are still working
 *   - added search.type = 'color'
 *
 ************************************************************************/

(function ($) {
    var w2grid = function (options) {

        // public properties
        this.name = null;
        this.box = null;     // HTML element that hold this element
        this.header = '';
        this.url = '';
        this.routeData = {};       // data for dynamic routes
        this.columns = [];       // { field, caption, size, attr, render, hidden, gridMinWidth, editable }
        this.columnGroups = [];       // { span: int, caption: 'string', master: true/false }
        this.records = [];       // { recid: int(requied), field1: 'value1', ... fieldN: 'valueN', style: 'string',  changes: object }
        this.summary = [];       // arry of summary records, same structure as records array
        this.searches = [];       // { type, caption, field, inTag, outTag, hidden }
        this.searchData = [];
        this.sortData = [];
        this.postData = {};
        this.httpHeaders = {};
        this.toolbar = {};       // if not empty object; then it is toolbar object
        this.stateId = null;     // Custom state name for satateSave, stateRestore and stateReset

        this.show = {
            header: false,
            toolbar: false,
            footer: false,
            columnHeaders: true,
            lineNumbers: false,
            expandColumn: false,
            selectColumn: false,
            emptyRecords: true,
            toolbarReload: true,
            toolbarColumns: true,
            toolbarSearch: true,
            toolbarInput: true,
            toolbarAdd: false,
            toolbarEdit: false,
            toolbarDelete: false,
            toolbarSave: false,
            searchAll: true,
            statusRange: true,
            statusBuffered: false,
            statusRecordID: true,
            statusSelection: true,
            statusResponse: true,
            statusSort: false,
            statusSearch: false,
            recordTitles: true,
            selectionBorder: true,
            skipRecords: true,
            saveRestoreState: true
        };

        this.hasFocus = false;
        this.autoLoad = true;     // for infinite scroll
        this.fixedBody = true;     // if false; then grid grows with data
        this.recordHeight = 24;       // should be in prototype
        this.lineNumberWidth = null;
        this.vs_start = 150;
        this.vs_extra = 15;
        this.keyboard = true;
        this.selectType = 'row';    // can be row|cell
        this.multiSearch = true;
        this.multiSelect = true;
        this.multiSort = true;
        this.reorderColumns = false;
        this.reorderRows = false;
        this.markSearch = true;
        this.columnTooltip = 'normal'; // can be normal, top, bottom, left, right
        this.disableCVS = false;    // disable Column Virtual Scroll
        this.textSearch = 'begins'; // default search type for text

        this.total = 0;     // server total
        this.limit = 100;
        this.offset = 0;     // how many records to skip (for infinite scroll) when pulling from server
        this.style = '';
        this.ranges = [];
        this.menu = [];
        this.method = null;  // if defined, then overwrited ajax method
        this.recid = null;
        this.parser = null;

        // internal
        this.last = {
            field: '',
            caption: '',
            logic: 'OR',
            search: '',
            searchIds: [],
            selection: {
                indexes: [],
                columns: {}
            },
            multi: false,
            scrollTop: 0,
            scrollLeft: 0,
            colStart: 0,    // for column virtual scrolling
            colEnd: 0,
            sortData: null,
            sortCount: 0,
            xhr: null,
            range_start: null,
            range_end: null,
            sel_ind: null,
            sel_col: null,
            sel_type: null,
            edit_col: null,
            isSafari: (/^((?!chrome|android).)*safari/i).test(navigator.userAgent)
        };

        $.extend(true, this, w2obj.grid, options);
    };

    // ====================================================
    // -- Registers as a jQuery plugin

    $.fn.w2grid = function (method) {
        if ($.isPlainObject(method)) {
            // check name parameter
            if (!w2utils.checkName(method, 'w2grid')) return;
            // remember items
            var columns = method.columns;
            var columnGroups = method.columnGroups;
            var records = method.records;
            var searches = method.searches;
            var searchData = method.searchData;
            var sortData = method.sortData;
            var postData = method.postData;
            var httpHeaders = method.httpHeaders;
            var toolbar = method.toolbar;
            // extend items
            var object = new w2grid(method);
            $.extend(object, {
                postData: {},
                httpHeaders: {},
                records: [],
                columns: [],
                searches: [],
                toolbar: {},
                sortData: [],
                searchData: [],
                handlers: []
            });
            if (object.onExpand != null) object.show.expandColumn = true;
            $.extend(true, object.toolbar, toolbar);
            // reassign variables
            var p;
            if (columns)      for (p = 0; p &lt; columns.length; p++)      object.columns[p] = $.extend(true, {}, columns[p]);
            if (columnGroups) for (p = 0; p &lt; columnGroups.length; p++) object.columnGroups[p] = $.extend(true, {}, columnGroups[p]);
            if (searches)     for (p = 0; p &lt; searches.length; p++)     object.searches[p] = $.extend(true, {}, searches[p]);
            if (searchData)   for (p = 0; p &lt; searchData.length; p++)   object.searchData[p] = $.extend(true, {}, searchData[p]);
            if (sortData)     for (p = 0; p &lt; sortData.length; p++)     object.sortData[p] = $.extend(true, {}, sortData[p]);
            object.postData = $.extend(true, {}, postData);
            object.httpHeaders = $.extend(true, {}, httpHeaders);

            // check if there are records without recid
            if (records) for (var r = 0; r &lt; records.length; r++) {
                if (records[r].recid == null &amp;&amp; records[r][object.recid] == null) {
                    console.log('ERROR: Cannot add records without recid. (obj: ' + object.name + ')');
                    return;
                }
                object.records[r] = $.extend(true, {}, records[r]);
            }
            // add searches
            for (var i = 0; i &lt; object.columns.length; i++) {
                var col = object.columns[i];
                var search = col.searchable;
                if (search == null || search === false || object.getSearch(col.field) != null) continue;
                if ($.isPlainObject(search)) {
                    object.addSearch($.extend({field: col.field, caption: col.caption, type: 'text'}, search));
                } else {
                    var stype = col.searchable, attr = '';
                    if (col.searchable === true) {
                        stype = 'text';
                        attr = 'size="20"';
                    }
                    object.addSearch({field: col.field, caption: col.caption, type: stype, attr: attr});
                }
            }
            // init toolbar
            object.initToolbar();
            // render if necessary
            if ($(this).length !== 0) {
                object.render($(this)[0]);
            }
            // register new object
            w2ui[object.name] = object;
            return object;

        } else {
            var obj = w2ui[$(this).attr('name')];
            if (!obj) return null;
            if (arguments.length > 0) {
                if (obj[method]) obj[method].apply(obj, Array.prototype.slice.call(arguments, 1));
                return this;
            } else {
                return obj;
            }
        }
    };

    // ====================================================
    // -- Implementation of core functionality

    w2grid.prototype = {
        msgDelete: 'Are you sure you want to delete selected records?',
        msgNotJSON: 'Returned data is not in valid JSON format.',
        msgAJAXerror: 'AJAX error. See console for more details.',
        msgRefresh: 'Refreshing...',
        msgNeedReload: 'Your remote data source record count has changed, reloading from the first record.',
        msgEmpty: '', // if not blank, then it is message when server returns no records

        buttons: {
            'reload': {type: 'button', id: 'w2ui-reload', icon: 'w2ui-icon-reload', tooltip: 'Reload data in the list'},
            'columns': {
                type: 'drop',
                id: 'w2ui-column-on-off',
                icon: 'w2ui-icon-columns',
                tooltip: 'Show/hide columns',
                arrow: false,
                html: ''
            },
            'search': {
                type: 'html', id: 'w2ui-search',
                html: '&lt;div class="w2ui-icon icon-search-down w2ui-search-down" ' +
                'onclick="var obj = w2ui[jQuery(this).parents(\'div.w2ui-grid\').attr(\'name\')]; obj.searchShowFields();">&lt;/div>'
            },
            'search-go': {
                type: 'drop',
                id: 'w2ui-search-advanced',
                icon: 'w2ui-icon-search',
                text: 'Search',
                tooltip: 'Open Search Fields'
            },
            'add': {type: 'button', id: 'w2ui-add', text: 'Add New', tooltip: 'Add new record', icon: 'w2ui-icon-plus'},
            'edit': {
                type: 'button',
                id: 'w2ui-edit',
                text: 'Edit',
                tooltip: 'Edit selected record',
                icon: 'w2ui-icon-pencil',
                disabled: true
            },
            'delete': {
                type: 'button',
                id: 'w2ui-delete',
                text: 'Delete',
                tooltip: 'Delete selected records',
                icon: 'w2ui-icon-cross',
                disabled: true
            },
            'save': {
                type: 'button',
                id: 'w2ui-save',
                text: 'Save',
                tooltip: 'Save changed records',
                icon: 'w2ui-icon-check'
            }
        },

        operators: { // for search fields
            "text": ['is', 'begins', 'contains', 'ends'],
            "number": ['is', 'between', {oper: 'less', text: 'less than'}, {oper: 'more', text: 'more than'}],
            "date": ['is', 'between', {oper: 'less', text: 'before'}, {oper: 'more', text: 'after'}],
            "list": ['is'],
            "hex": ['is', 'between'],
            "color": ['is', 'begins', 'contains', 'ends'],
            "enum": ['in', 'not in']
            // -- all posible
            // "text"    : ['is', 'begins', 'contains', 'ends'],
            // "number"  : ['is', 'between', 'less:less than', 'more:more than', 'null:is null', 'not null:is not null'],
            // "list"    : ['is', 'null:is null', 'not null:is not null'],
            // "enum"    : ['in', 'not in', 'null:is null', 'not null:is not null']
        },

        operatorsMap: {
            "text": "text",
            "int": "number",
            "float": "number",
            "money": "number",
            "currency": "number",
            "percent": "number",
            "hex": "hex",
            "alphanumeric": "text",
            "color": "color",
            "date": "date",
            "time": "date",
            "datetime": "date",
            "list": "list",
            "combo": "text",
            "enum": "enum",
            "file": "enum",
            "select": "list",
            "radio": "list",
            "checkbox": "list",
            "toggle": "list"
        },

        // events
        onAdd: null,
        onEdit: null,
        onRequest: null,        // called on any server event
        onLoad: null,
        onDelete: null,
        onSave: null,
        onSelect: null,
        onUnselect: null,
        onClick: null,
        onDblClick: null,
        onContextMenu: null,
        onMenuClick: null,        // when context menu item selected
        onColumnClick: null,
        onColumnDblClick: null,
        onColumnResize: null,
        onSort: null,
        onSearch: null,
        onSearchOpen: null,
        onChange: null,        // called when editable record is changed
        onRestore: null,        // called when editable record is restored
        onExpand: null,
        onCollapse: null,
        onError: null,
        onKeydown: null,
        onToolbar: null,        // all events from toolbar
        onColumnOnOff: null,
        onCopy: null,
        onPaste: null,
        onSelectionExtend: null,
        onEditField: null,
        onRender: null,
        onRefresh: null,
        onReload: null,
        onResize: null,
        onDestroy: null,
        onStateSave: null,
        onStateRestore: null,
        onFocus: null,
        onBlur: null,
        onReorderRow: null,
        onTreeExpand: null,

        add: function (record, first) {
            if (!$.isArray(record)) record = [record];
            var added = 0;
            for (var i = 0; i &lt; record.length; i++) {
                var rec = record[i];
                if (rec.recid == null &amp;&amp; rec[this.recid] == null) {
                    console.log('ERROR: Cannot add record without recid. (obj: ' + this.name + ')');
                    continue;
                }
                if (rec.w2ui &amp;&amp; rec.w2ui.summary === true) {
                    if (first) this.summary.unshift(rec); else this.summary.push(rec);
                } else {
                    if (first) this.records.unshift(rec); else this.records.push(rec);
                }
                added++;
            }
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (!url) {
                this.total = this.records.length;
                this.localSort(false, true);
                this.localSearch();
                // do not call this.refresh(), this is unnecessary, heavy, and messes with the toolbar.
                this.refreshBody();
                this.resizeRecords();
                return added;
            }
            this.refresh(); // ??  should it be reload?
            return added;
        },

        find: function (obj, returnIndex) {
            if (obj == null) obj = {};
            var recs = [];
            var hasDots = false;
            // check if property is nested - needed for speed
            for (var o in obj) if (String(o).indexOf('.') != -1) hasDots = true;
            // look for an item
            for (var i = 0; i &lt; this.records.length; i++) {
                var match = true;
                for (var o in obj) {
                    var val = this.records[i][o];
                    if (hasDots &amp;&amp; String(o).indexOf('.') != -1) val = this.parseField(this.records[i], o);
                    if (obj[o] == 'not-null') {
                        if (val == null || val === '') match = false;
                    } else {
                        if (obj[o] != val) match = false;
                    }
                }
                if (match &amp;&amp; returnIndex !== true) recs.push(this.records[i].recid);
                if (match &amp;&amp; returnIndex === true) recs.push(i);
            }
            return recs;
        },

        set: function (recid, record, noRefresh) { // does not delete existing, but overrides on top of it
            if (typeof recid == 'object') {
                noRefresh = record;
                record = recid;
                recid = null;
            }
            // update all records
            if (recid == null) {
                for (var i = 0; i &lt; this.records.length; i++) {
                    $.extend(true, this.records[i], record); // recid is the whole record
                }
                if (noRefresh !== true) this.refresh();
            } else { // find record to update
                var ind = this.get(recid, true);
                if (ind == null) return false;
                var isSummary = (this.records[ind] &amp;&amp; this.records[ind].recid == recid ? false : true);
                if (isSummary) {
                    $.extend(true, this.summary[ind], record);
                } else {
                    $.extend(true, this.records[ind], record);
                }
                if (noRefresh !== true) this.refreshRow(recid, ind); // refresh only that record
            }
            return true;
        },

        get: function (recid, returnIndex) {
            // search records
            if ($.isArray(recid)) {
                var recs = [];
                for (var i = 0; i &lt; this.records.length; i++) {
                    if ($.inArray(this.records[i].recid, recid) != -1) {
                        if (returnIndex === true) {
                            recs.push(i);
                        } else {
                            recs.push(this.records[i]);
                        }
                    }
                }
                for (var i = 0; i &lt; this.summary.length; i++) {
                    if ($.inArray(this.summary[i].recid, recid) != -1) {
                        if (returnIndex === true) {
                            recs.push(i);
                        } else {
                            recs.push(this.summary[i]);
                        }
                    }
                }
                return recs;
            } else {
                for (var i = 0; i &lt; this.records.length; i++) {
                    if (this.records[i].recid == recid) {
                        if (returnIndex === true) return i; else return this.records[i];
                    }
                }
                // search summary
                for (var i = 0; i &lt; this.summary.length; i++) {
                    if (this.summary[i].recid == recid) {
                        if (returnIndex === true) return i; else return this.summary[i];
                    }
                }
                return null;
            }
        },

        remove: function () {
            var removed = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                for (var r = this.records.length - 1; r >= 0; r--) {
                    if (this.records[r].recid == arguments[a]) {
                        this.records.splice(r, 1);
                        removed++;
                    }
                }
                for (var r = this.summary.length - 1; r >= 0; r--) {
                    if (this.summary[r].recid == arguments[a]) {
                        this.summary.splice(r, 1);
                        removed++;
                    }
                }
            }
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (!url) {
                this.localSort(false, true);
                this.localSearch();
            }
            this.refresh();
            return removed;
        },

        addColumn: function (before, columns) {
            var added = 0;
            if (arguments.length == 1) {
                columns = before;
                before = this.columns.length;
            } else {
                if (typeof before == 'string') before = this.getColumn(before, true);
                if (before == null) before = this.columns.length;
            }
            if (!$.isArray(columns)) columns = [columns];
            for (var i = 0; i &lt; columns.length; i++) {
                this.columns.splice(before, 0, columns[i]);
                // if column is searchable, add search field
                if (columns[i].searchable) {
                    var stype = columns[i].searchable;
                    var attr = '';
                    if (columns[i].searchable === true) {
                        stype = 'text';
                        attr = 'size="20"';
                    }
                    this.addSearch({field: columns[i].field, caption: columns[i].caption, type: stype, attr: attr});
                }
                before++;
                added++;
            }
            this.refresh();
            return added;
        },

        removeColumn: function () {
            var removed = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                for (var r = this.columns.length - 1; r >= 0; r--) {
                    if (this.columns[r].field == arguments[a]) {
                        if (this.columns[r].searchable) this.removeSearch(arguments[a]);
                        this.columns.splice(r, 1);
                        removed++;
                    }
                }
            }
            this.refresh();
            return removed;
        },

        getColumn: function (field, returnIndex) {
            // no arguments - return fields of all columns
            if (arguments.length === 0) {
                var ret = [];
                for (var i = 0; i &lt; this.columns.length; i++) ret.push(this.columns[i].field);
                return ret;
            }
            // find column
            for (var i = 0; i &lt; this.columns.length; i++) {
                if (this.columns[i].field == field) {
                    if (returnIndex === true) return i; else return this.columns[i];
                }
            }
            return null;
        },

        toggleColumn: function () {
            var effected = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                for (var r = this.columns.length - 1; r >= 0; r--) {
                    var col = this.columns[r];
                    if (col.field == arguments[a]) {
                        col.hidden = !col.hidden;
                        effected++;
                    }
                }
            }
            this.refreshBody();
            this.resizeRecords();
            return effected;
        },

        showColumn: function () {
            var shown = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                for (var r = this.columns.length - 1; r >= 0; r--) {
                    var col = this.columns[r];
                    if (col.gridMinWidth) delete col.gridMinWidth;
                    if (col.field == arguments[a] &amp;&amp; col.hidden !== false) {
                        col.hidden = false;
                        shown++;
                    }
                }
            }
            this.refreshBody();
            this.resizeRecords();
            return shown;
        },

        hideColumn: function () {
            var hidden = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                for (var r = this.columns.length - 1; r >= 0; r--) {
                    var col = this.columns[r];
                    if (col.field == arguments[a] &amp;&amp; col.hidden !== true) {
                        col.hidden = true;
                        hidden++;
                    }
                }
            }
            this.refreshBody();
            this.resizeRecords();
            return hidden;
        },

        addSearch: function (before, search) {
            var added = 0;
            if (arguments.length == 1) {
                search = before;
                before = this.searches.length;
            } else {
                if (typeof before == 'string') before = this.getSearch(before, true);
                if (before == null) before = this.searches.length;
            }
            if (!$.isArray(search)) search = [search];
            for (var i = 0; i &lt; search.length; i++) {
                this.searches.splice(before, 0, search[i]);
                before++;
                added++;
            }
            this.searchClose();
            return added;
        },

        removeSearch: function () {
            var removed = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                for (var r = this.searches.length - 1; r >= 0; r--) {
                    if (this.searches[r].field == arguments[a]) {
                        this.searches.splice(r, 1);
                        removed++;
                    }
                }
            }
            this.searchClose();
            return removed;
        },

        getSearch: function (field, returnIndex) {
            // no arguments - return fields of all searches
            if (arguments.length === 0) {
                var ret = [];
                for (var i = 0; i &lt; this.searches.length; i++) ret.push(this.searches[i].field);
                return ret;
            }
            // find search
            for (var i = 0; i &lt; this.searches.length; i++) {
                if (this.searches[i].field == field) {
                    if (returnIndex === true) return i; else return this.searches[i];
                }
            }
            return null;
        },

        toggleSearch: function () {
            var effected = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                for (var r = this.searches.length - 1; r >= 0; r--) {
                    if (this.searches[r].field == arguments[a]) {
                        this.searches[r].hidden = !this.searches[r].hidden;
                        effected++;
                    }
                }
            }
            this.searchClose();
            return effected;
        },

        showSearch: function () {
            var shown = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                for (var r = this.searches.length - 1; r >= 0; r--) {
                    if (this.searches[r].field == arguments[a] &amp;&amp; this.searches[r].hidden !== false) {
                        this.searches[r].hidden = false;
                        shown++;
                    }
                }
            }
            this.searchClose();
            return shown;
        },

        hideSearch: function () {
            var hidden = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                for (var r = this.searches.length - 1; r >= 0; r--) {
                    if (this.searches[r].field == arguments[a] &amp;&amp; this.searches[r].hidden !== true) {
                        this.searches[r].hidden = true;
                        hidden++;
                    }
                }
            }
            this.searchClose();
            return hidden;
        },

        getSearchData: function (field) {
            for (var i = 0; i &lt; this.searchData.length; i++) {
                if (this.searchData[i].field == field) return this.searchData[i];
            }
            return null;
        },

        localSort: function (silent, noResetRefresh) {
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (url) {
                console.log('ERROR: grid.localSort can only be used on local data source, grid.url should be empty.');
                return;
            }
            if ($.isEmptyObject(this.sortData)) return;
            var time = (new Date()).getTime();
            var obj = this;
            // process date fields
            obj.selectionSave();
            obj.prepareData();
            if (!noResetRefresh) {
                obj.reset();
            }
            // process sortData
            for (var i = 0; i &lt; this.sortData.length; i++) {
                var column = this.getColumn(this.sortData[i].field);
                if (!column) return;
                if (typeof column.render == 'string') {
                    if (['date', 'age'].indexOf(column.render.split(':')[0]) != -1) {
                        this.sortData[i]['field_'] = column.field + '_';
                    }
                    if (['time'].indexOf(column.render.split(':')[0]) != -1) {
                        this.sortData[i]['field_'] = column.field + '_';
                    }
                }
            }

            // prepare paths and process sort
            preparePaths();
            this.records.sort(function (a, b) {
                return compareRecordPaths(a, b);
            });
            cleanupPaths();

            obj.selectionRestore(noResetRefresh);
            time = (new Date()).getTime() - time;
            if (silent !== true &amp;&amp; obj.show.statusSort) {
                setTimeout(function () {
                    obj.status(w2utils.lang('Sorting took') + ' ' + time / 1000 + ' ' + w2utils.lang('sec'));
                }, 10);
            }
            return time;

            // grab paths before sorting for efficiency and because calling obj.get()
            // while sorting 'obj.records' is unsafe, at least on webkit
            function preparePaths() {
                for (var i = 0; i &lt; obj.records.length; i++) {
                    var rec = obj.records[i];
                    if (rec.w2ui &amp;&amp; rec.w2ui.parent_recid != null)
                        rec.w2ui._path = getRecordPath(rec);
                }
            }

            // cleanup and release memory allocated by preparePaths()
            function cleanupPaths() {
                for (var i = 0; i &lt; obj.records.length; i++) {
                    var rec = obj.records[i];
                    if (rec.w2ui &amp;&amp; rec.w2ui.parent_recid != null)
                        rec.w2ui._path = null;
                }
            }

            // compare two paths, from root of tree to given records
            function compareRecordPaths(a, b) {
                if ((!a.w2ui || a.w2ui.parent_recid == null) &amp;&amp; (!b.w2ui || b.w2ui.parent_recid == null)) {
                    return compareRecords(a, b);    // no tree, fast path
                }
                var pa = getRecordPath(a);
                var pb = getRecordPath(b);
                for (var i = 0; i &lt; Math.min(pa.length, pb.length); i++) {
                    var diff = compareRecords(pa[i], pb[i]);
                    if (diff !== 0) return diff;     // different subpath
                }
                if (pa.length > pb.length) return 1;
                if (pa.length &lt; pb.length) return -1;
                console.log('ERROR: two paths should not be equal.');
                return 0;
            }

            // return an array of all records from root to and including 'rec'
            function getRecordPath(rec) {
                if (!rec.w2ui || rec.w2ui.parent_recid == null) return [rec];
                if (rec.w2ui._path)
                    return rec.w2ui._path;
                // during actual sort, we should never reach this point
                var subrec = obj.get(rec.w2ui.parent_recid);
                if (!subrec) {
                    console.log('ERROR: no parent record: ' + rec.w2ui.parent_recid);
                    return [rec];
                }
                return (getRecordPath(subrec).concat(rec));
            }

            // compare two records according to sortData and finally recid
            function compareRecords(a, b) {
                if (a === b) return 0; // optimize, same object
                for (var i = 0; i &lt; obj.sortData.length; i++) {
                    var fld = obj.sortData[i].field;
                    if (obj.sortData[i].field_) fld = obj.sortData[i].field_;
                    var aa = a[fld];
                    var bb = b[fld];
                    if (String(fld).indexOf('.') != -1) {
                        aa = obj.parseField(a, fld);
                        bb = obj.parseField(b, fld);
                    }
                    var col = obj.getColumn(fld);
                    if (col &amp;&amp; col.editable != null) { // for drop editable fields and drop downs
                        if ($.isPlainObject(aa) &amp;&amp; aa.text) aa = aa.text;
                        if ($.isPlainObject(bb) &amp;&amp; bb.text) bb = bb.text;
                    }
                    var ret = compareCells(aa, bb, i, obj.sortData[i].direction);
                    if (ret !== 0) return ret;
                }
                // break tie for similar records,
                // required to have consistent ordering for tree paths
                var ret = compareCells(a.recid, b.recid, -1, 'asc');
                if (ret !== 0) return ret;
                return 0;
            }

            // compare two values, aa and bb, producing consistent ordering
            function compareCells(aa, bb, i, direction) {
                // if both objects are strictly equal, we're done
                if (aa === bb)
                    return 0;
                // all nulls, empty and undefined on bottom
                if ((aa == null || aa === "") &amp;&amp; (bb != null &amp;&amp; bb !== ""))
                    return 1;
                if ((aa != null &amp;&amp; aa !== "") &amp;&amp; (bb == null || bb === ""))
                    return -1;
                var dir = (direction == 'asc') ? 1 : -1;
                // for different kind of objects, sort by object type
                if (typeof aa != typeof bb)
                    return (typeof aa > typeof bb) ? dir : -dir;
                // for different kind of classes, sort by classes
                if (aa.constructor.name != bb.constructor.name)
                    return (aa.constructor.name > bb.constructor.name) ? dir : -dir;
                // if we're dealing with non-null objects, call valueOf().
                // this mean that Date() or custom objects will compare properly.
                if (aa &amp;&amp; typeof aa == 'object')
                    aa = aa.valueOf();
                if (bb &amp;&amp; typeof bb == 'object')
                    bb = bb.valueOf();
                // if we're still dealing with non-null objects that have
                // a useful Object => String conversion, convert to string.
                var defaultToString = {}.toString;
                if (aa &amp;&amp; typeof aa == 'object' &amp;&amp; aa.toString != defaultToString)
                    aa = String(aa);
                if (bb &amp;&amp; typeof bb == 'object' &amp;&amp; bb.toString != defaultToString)
                    bb = String(bb);
                // do case-insensitive string comparaison
                if (typeof aa == 'string')
                    aa = $.trim(aa.toLowerCase());
                if (typeof bb == 'string')
                    bb = $.trim(bb.toLowerCase());
                // compare both objects
                if (aa > bb)
                    return dir;
                if (aa &lt; bb)
                    return -dir;
                return 0;
            }
        },

        localSearch: function (silent) {
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (url) {
                console.log('ERROR: grid.localSearch can only be used on local data source, grid.url should be empty.');
                return;
            }
            var time = (new Date()).getTime();
            var obj = this;
            var defaultToString = {}.toString;
            var duplicateMap = {};
            this.total = this.records.length;
            // mark all records as shown
            this.last.searchIds = [];
            // prepare date/time fields
            this.prepareData();
            // hide records that did not match
            if (this.searchData.length > 0 &amp;&amp; !url) {
                this.total = 0;
                for (var i = 0; i &lt; this.records.length; i++) {
                    var rec = this.records[i];
                    var match = searchRecord(rec);
                    if (match) {
                        if (rec &amp;&amp; rec.w2ui)
                            addParent(rec.w2ui.parent_recid);
                        this.last.searchIds.push(i);
                    }
                }
                this.total = this.last.searchIds.length;
            }
            time = (new Date()).getTime() - time;
            if (silent !== true &amp;&amp; obj.show.statusSearch) {
                setTimeout(function () {
                    obj.status(w2utils.lang('Search took') + ' ' + time / 1000 + ' ' + w2utils.lang('sec'));
                }, 10);
            }
            return time;

            // check if a record (or one of its closed children) matches the search data
            function searchRecord(rec) {
                var fl = 0;
                for (var j = 0; j &lt; obj.searchData.length; j++) {
                    var sdata = obj.searchData[j];
                    var search = obj.getSearch(sdata.field);
                    if (sdata == null) continue;
                    if (search == null) search = {field: sdata.field, type: sdata.type};
                    var val1b = obj.parseField(rec, search.field);
                    var val1 = (val1b !== null &amp;&amp; val1b !== undefined &amp;&amp;
                    (typeof val1b != "object" || val1b.toString != defaultToString)) ?
                        String(val1b).toLowerCase() : "";  // do not match a bogus string
                    if (sdata.value != null) {
                        if (!$.isArray(sdata.value)) {
                            var val2 = String(sdata.value).toLowerCase();
                        } else {
                            var val2 = sdata.value[0];
                            var val3 = sdata.value[1];
                        }
                    }
                    switch (sdata.operator) {
                        case 'is':
                            if (obj.parseField(rec, search.field) == sdata.value) fl++; // do not hide record
                            else if (search.type == 'date') {
                                var tmp = (obj.parseField(rec, search.field + '_') instanceof Date ? obj.parseField(rec, search.field + '_') : obj.parseField(rec, search.field));
                                var val1 = w2utils.formatDate(tmp, 'yyyy-mm-dd');
                                var val2 = w2utils.formatDate(w2utils.isDate(val2, w2utils.settings.dateFormat, true), 'yyyy-mm-dd');
                                if (val1 == val2) fl++;
                            }
                            else if (search.type == 'time') {
                                var tmp = (obj.parseField(rec, search.field + '_') instanceof Date ? obj.parseField(rec, search.field + '_') : obj.parseField(rec, search.field));
                                var val1 = w2utils.formatTime(tmp, 'hh24:mi');
                                var val2 = w2utils.formatTime(val2, 'hh24:mi');
                                if (val1 == val2) fl++;
                            }
                            else if (search.type == 'datetime') {
                                var tmp = (obj.parseField(rec, search.field + '_') instanceof Date ? obj.parseField(rec, search.field + '_') : obj.parseField(rec, search.field));
                                var val1 = w2utils.formatDateTime(tmp, 'yyyy-mm-dd|hh24:mm:ss');
                                var val2 = w2utils.formatDateTime(w2utils.isDateTime(val2, w2utils.settings.datetimeFormat, true), 'yyyy-mm-dd|hh24:mm:ss');
                                if (val1 == val2) fl++;
                            }
                            break;
                        case 'between':
                            if (['int', 'float', 'money', 'currency', 'percent'].indexOf(search.type) != -1) {
                                if (parseFloat(obj.parseField(rec, search.field)) >= parseFloat(val2) &amp;&amp; parseFloat(obj.parseField(rec, search.field)) &lt;= parseFloat(val3)) fl++;
                            }
                            else if (search.type == 'date') {
                                var val1 = (obj.parseField(rec, search.field + '_') instanceof Date ? obj.parseField(rec, search.field + '_') : obj.parseField(rec, search.field));
                                var val2 = w2utils.isDate(val2, w2utils.settings.dateFormat, true);
                                var val3 = w2utils.isDate(val3, w2utils.settings.dateFormat, true);
                                if (val3 != null) val3 = new Date(val3.getTime() + 86400000); // 1 day
                                if (val1 >= val2 &amp;&amp; val1 &lt; val3) fl++;
                            }
                            else if (search.type == 'time') {
                                var val1 = (obj.parseField(rec, search.field + '_') instanceof Date ? obj.parseField(rec, search.field + '_') : obj.parseField(rec, search.field));
                                var val2 = w2utils.isTime(val2, true);
                                var val3 = w2utils.isTime(val3, true);
                                val2 = (new Date()).setHours(val2.hours, val2.minutes, val2.seconds ? val2.seconds : 0, 0);
                                val3 = (new Date()).setHours(val3.hours, val3.minutes, val3.seconds ? val3.seconds : 0, 0);
                                if (val1 >= val2 &amp;&amp; val1 &lt; val3) fl++;
                            }
                            else if (search.type == 'datetime') {
                                var val1 = (obj.parseField(rec, search.field + '_') instanceof Date ? obj.parseField(rec, search.field + '_') : obj.parseField(rec, search.field));
                                var val2 = w2utils.isDateTime(val2, w2utils.settings.datetimeFormat, true);
                                var val3 = w2utils.isDateTime(val3, w2utils.settings.datetimeFormat, true);
                                if (val3) val3 = new Date(val3.getTime() + 86400000); // 1 day
                                if (val1 >= val2 &amp;&amp; val1 &lt; val3) fl++;
                            }
                            break;
                        case 'less':
                            if (['int', 'float', 'money', 'currency', 'percent'].indexOf(search.type) != -1) {
                                if (parseFloat(obj.parseField(rec, search.field)) &lt;= parseFloat(sdata.value)) fl++;
                            }
                            else if (search.type == 'date') {
                                var tmp = (obj.parseField(rec, search.field + '_') instanceof Date ? obj.parseField(rec, search.field + '_') : obj.parseField(rec, search.field));
                                var val1 = w2utils.formatDate(tmp, 'yyyy-mm-dd');
                                var val2 = w2utils.formatDate(w2utils.isDate(val2, w2utils.settings.dateFormat, true), 'yyyy-mm-dd');
                                if (val1 &lt;= val2) fl++;
                            }
                            else if (search.type == 'time') {
                                var tmp = (obj.parseField(rec, search.field + '_') instanceof Date ? obj.parseField(rec, search.field + '_') : obj.parseField(rec, search.field));
                                var val1 = w2utils.formatTime(tmp, 'hh24:mi');
                                var val2 = w2utils.formatTime(val2, 'hh24:mi');
                                if (val1 &lt;= val2) fl++;
                            }
                            else if (search.type == 'datetime') {
                                var tmp = (obj.parseField(rec, search.field + '_') instanceof Date ? obj.parseField(rec, search.field + '_') : obj.parseField(rec, search.field));
                                var val1 = w2utils.formatDateTime(tmp, 'yyyy-mm-dd|hh24:mm:ss');
                                var val2 = w2utils.formatDateTime(w2utils.isDateTime(val2, w2utils.settings.datetimeFormat, true), 'yyyy-mm-dd|hh24:mm:ss');
                                if ((val1.length == val2.length) &amp;&amp; (val1 &lt;= val2)) fl++;
                            }
                            break;
                        case 'more':
                            if (['int', 'float', 'money', 'currency', 'percent'].indexOf(search.type) != -1) {
                                if (parseFloat(obj.parseField(rec, search.field)) >= parseFloat(sdata.value)) fl++;
                            }
                            else if (search.type == 'date') {
                                var tmp = (obj.parseField(rec, search.field + '_') instanceof Date ? obj.parseField(rec, search.field + '_') : obj.parseField(rec, search.field));
                                var val1 = w2utils.formatDate(tmp, 'yyyy-mm-dd');
                                var val2 = w2utils.formatDate(w2utils.isDate(val2, w2utils.settings.dateFormat, true), 'yyyy-mm-dd');
                                if (val1 >= val2) fl++;
                            }
                            else if (search.type == 'time') {
                                var tmp = (obj.parseField(rec, search.field + '_') instanceof Date ? obj.parseField(rec, search.field + '_') : obj.parseField(rec, search.field));
                                var val1 = w2utils.formatTime(tmp, 'hh24:mi');
                                var val2 = w2utils.formatTime(val2, 'hh24:mi');
                                if (val1 >= val2) fl++;
                            }
                            else if (search.type == 'datetime') {
                                var tmp = (obj.parseField(rec, search.field + '_') instanceof Date ? obj.parseField(rec, search.field + '_') : obj.parseField(rec, search.field));
                                var val1 = w2utils.formatDateTime(tmp, 'yyyy-mm-dd|hh24:mm:ss');
                                var val2 = w2utils.formatDateTime(w2utils.isDateTime(val2, w2utils.settings.datetimeFormat, true), 'yyyy-mm-dd|hh24:mm:ss');
                                if ((val1.length == val2.length) &amp;&amp; (val1 >= val2)) fl++;
                            }
                            break;
                        case 'in':
                            var tmp = sdata.value;
                            if (sdata.svalue) tmp = sdata.svalue;
                            if (tmp.indexOf(w2utils.isFloat(val1) ? parseFloat(val1) : val1) !== -1) fl++;
                            if (tmp.indexOf(w2utils.isFloat(val1b) ? parseFloat(val1b) : val1b) !== -1) fl++;
                            break;
                        case 'not in':
                            var tmp = sdata.value;
                            if (sdata.svalue) tmp = sdata.svalue;
                            if (tmp.indexOf(w2utils.isFloat(val1) ? parseFloat(val1) : val1) == -1) fl++;
                            if (tmp.indexOf(w2utils.isFloat(val1b) ? parseFloat(val1b) : val1b) == -1) fl++;
                            break;
                        case 'begins':
                        case 'begins with': // need for back compatib.
                            if (val1.indexOf(val2) === 0) fl++; // do not hide record
                            break;
                        case 'contains':
                            if (val1.indexOf(val2) >= 0) fl++; // do not hide record
                            break;
                        case 'null':
                            if (obj.parseField(rec, search.field) == null) fl++; // do not hide record
                            break;
                        case 'not null':
                            if (obj.parseField(rec, search.field) != null) fl++; // do not hide record
                            break;
                        case 'ends':
                        case 'ends with': // need for back compatib.
                            var lastIndex = val1.lastIndexOf(val2);
                            if (lastIndex !== -1 &amp;&amp; lastIndex == val1.length - val2.length) fl++; // do not hide record
                            break;
                    }
                }
                if ((obj.last.logic == 'OR' &amp;&amp; fl !== 0) ||
                    (obj.last.logic == 'AND' &amp;&amp; fl == obj.searchData.length))
                    return true;
                if (rec.w2ui &amp;&amp; rec.w2ui.children &amp;&amp; rec.w2ui.expanded !== true) {
                    // there are closed children, search them too.
                    for (var r = 0; r &lt; rec.w2ui.children.length; r++) {
                        var subRec = rec.w2ui.children[r];
                        if (searchRecord(subRec))
                            return true;
                    }
                }
                return false;
            }

            // add parents nodes recursively
            function addParent(recid) {
                if (recid === undefined)
                    return;
                if (duplicateMap[recid])
                    return; // already visited
                duplicateMap[recid] = true;
                var i = obj.get(recid, true);
                if (i == null)
                    return;
                if ($.inArray(i, obj.last.searchIds) != -1)
                    return;
                var rec = obj.records[i];
                if (rec &amp;&amp; rec.w2ui)
                    addParent(rec.w2ui.parent_recid);
                obj.last.searchIds.push(i);
            }
        },

        getRangeData: function (range, extra) {
            var rec1 = this.get(range[0].recid, true);
            var rec2 = this.get(range[1].recid, true);
            var col1 = range[0].column;
            var col2 = range[1].column;

            var res = [];
            if (col1 == col2) { // one row
                for (var r = rec1; r &lt;= rec2; r++) {
                    var record = this.records[r];
                    var dt = record[this.columns[col1].field] || null;
                    if (extra !== true) {
                        res.push(dt);
                    } else {
                        res.push({data: dt, column: col1, index: r, record: record});
                    }
                }
            } else if (rec1 == rec2) { // one line
                var record = this.records[rec1];
                for (var i = col1; i &lt;= col2; i++) {
                    var dt = record[this.columns[i].field] || null;
                    if (extra !== true) {
                        res.push(dt);
                    } else {
                        res.push({data: dt, column: i, index: rec1, record: record});
                    }
                }
            } else {
                for (var r = rec1; r &lt;= rec2; r++) {
                    var record = this.records[r];
                    res.push([]);
                    for (var i = col1; i &lt;= col2; i++) {
                        var dt = record[this.columns[i].field];
                        if (extra !== true) {
                            res[res.length - 1].push(dt);
                        } else {
                            res[res.length - 1].push({data: dt, column: i, index: r, record: record});
                        }
                    }
                }
            }
            return res;
        },

        addRange: function (ranges) {
            var added = 0;
            if (this.selectType == 'row') return added;
            if (!$.isArray(ranges)) ranges = [ranges];
            // if it is selection
            for (var i = 0; i &lt; ranges.length; i++) {
                if (typeof ranges[i] != 'object') ranges[i] = {name: 'selection'};
                if (ranges[i].name == 'selection') {
                    if (this.show.selectionBorder === false) continue;
                    var sel = this.getSelection();
                    if (sel.length === 0) {
                        this.removeRange('selection');
                        continue;
                    } else {
                        var first = sel[0];
                        var last = sel[sel.length - 1];
                    }
                } else { // other range
                    var first = ranges[i].range[0];
                    var last = ranges[i].range[1];
                }
                if (first) {
                    var rg = {
                        name: ranges[i].name,
                        range: [{recid: first.recid, column: first.column}, {recid: last.recid, column: last.column}],
                        style: ranges[i].style || ''
                    };
                    // add range
                    var ind = false;
                    for (var j = 0; j &lt; this.ranges.length; j++) if (this.ranges[j].name == ranges[i].name) {
                        ind = j;
                        break;
                    }
                    if (ind !== false) {
                        this.ranges[ind] = rg;
                    } else {
                        this.ranges.push(rg);
                    }
                    added++;
                }
            }
            this.refreshRanges();
            return added;
        },

        removeRange: function () {
            var removed = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                var name = arguments[a];
                $('#grid_' + this.name + '_' + name).remove();
                $('#grid_' + this.name + '_f' + name).remove();
                for (var r = this.ranges.length - 1; r >= 0; r--) {
                    if (this.ranges[r].name == name) {
                        this.ranges.splice(r, 1);
                        removed++;
                    }
                }
            }
            return removed;
        },

        refreshRanges: function () {
            if (this.ranges.length === 0) return;
            var obj = this;
            var time = (new Date()).getTime();
            var rec1 = $('#grid_' + this.name + '_frecords');
            var rec2 = $('#grid_' + this.name + '_records');
            for (var i = 0; i &lt; this.ranges.length; i++) {
                var rg = this.ranges[i];
                var first = rg.range[0];
                var last = rg.range[1];
                if (first.index == null) first.index = this.get(first.recid, true);
                if (last.index == null) last.index = this.get(last.recid, true);
                var td1 = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(first.recid) + ' td[col="' + first.column + '"]');
                var td2 = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(last.recid) + ' td[col="' + last.column + '"]');
                var td1f = $('#grid_' + this.name + '_frec_' + w2utils.escapeId(first.recid) + ' td[col="' + first.column + '"]');
                var td2f = $('#grid_' + this.name + '_frec_' + w2utils.escapeId(last.recid) + ' td[col="' + last.column + '"]');
                var _lastColumn = last.column;
                // adjustment due to column virtual scroll
                if (first.column &lt; this.last.colStart &amp;&amp; last.column > this.last.colStart) {
                    td1 = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(first.recid) + ' td[col="start"]');
                }
                if (first.column &lt; this.last.colEnd &amp;&amp; last.column > this.last.colEnd) {
                    _lastColumn = '"end"';
                    td2 = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(last.recid) + ' td[col="end"]');
                }
                // if virtual scrolling kicked in
                var index_top = parseInt($('#grid_' + this.name + '_rec_top').next().attr('index'));
                var index_bottom = parseInt($('#grid_' + this.name + '_rec_bottom').prev().attr('index'));
                var index_ftop = parseInt($('#grid_' + this.name + '_frec_top').next().attr('index'));
                var index_fbottom = parseInt($('#grid_' + this.name + '_frec_bottom').prev().attr('index'));
                if (td1.length === 0 &amp;&amp; first.index &lt; index_top &amp;&amp; last.index > index_top) {
                    td1 = $('#grid_' + this.name + '_rec_top').next().find('td[col=' + first.column + ']');
                }
                if (td2.length === 0 &amp;&amp; last.index > index_bottom &amp;&amp; first.index &lt; index_bottom) {
                    td2 = $('#grid_' + this.name + '_rec_bottom').prev().find('td[col=' + _lastColumn + ']');
                }
                if (td1f.length === 0 &amp;&amp; first.index &lt; index_ftop &amp;&amp; last.index > index_ftop) { // frozen
                    td1f = $('#grid_' + this.name + '_frec_top').next().find('td[col=' + first.column + ']');
                }
                if (td2f.length === 0 &amp;&amp; last.index > index_fbottom &amp;&amp; first.index &lt; index_fbottom) {  // frozen
                    td2f = $('#grid_' + this.name + '_frec_bottom').prev().find('td[col=' + last.column + ']');
                }

                // do not show selection cell if it is editable
                var edit = $(this.box).find('#grid_' + this.name + '_editable');
                var tmp = edit.find('.w2ui-input');
                var tmp1 = tmp.attr('recid');
                var tmp2 = tmp.attr('column');
                if (rg.name == 'selection' &amp;&amp; rg.range[0].recid == tmp1 &amp;&amp; rg.range[0].column == tmp2) continue;

                // frozen regular columns range
                var $range = $('#grid_' + this.name + '_f' + rg.name);
                if (td1f.length > 0 || td2f.length > 0) {
                    if ($range.length === 0) {
                        rec1.append('&lt;div id="grid_' + this.name + '_f' + rg.name + '" class="w2ui-selection" style="' + rg.style + '">' +
                            (rg.name == 'selection' ? '&lt;div id="grid_' + this.name + '_resizer" class="w2ui-selection-resizer">&lt;/div>' : '') +
                            '&lt;/div>');
                        $range = $('#grid_' + this.name + '_f' + rg.name);
                    } else {
                        $range.attr('style', rg.style);
                        $range.find('.w2ui-selection-resizer').show();
                    }
                    if (td2f.length === 0) {
                        td2f = $('#grid_' + this.name + '_frec_' + w2utils.escapeId(last.recid) + ' td:last-child');
                        if (td2f.length === 0) td2f = $('#grid_' + this.name + '_frec_bottom td:first-child');
                        $range.css('border-right', '0px');
                        $range.find('.w2ui-selection-resizer').hide();
                    }
                    if (first.recid != null &amp;&amp; last.recid != null &amp;&amp; td1f.length > 0 &amp;&amp; td2f.length > 0) {
                        var _left = (td1f.position().left - 1 + rec1.scrollLeft());
                        var _top = (td1f.position().top - 1 + rec1.scrollTop());
                        $range.show().css({
                            left: (_left > 0 ? _left : 0) + 'px',
                            top: (_top > 0 ? _top : 0) + 'px',
                            width: (td2f.position().left - td1f.position().left + td2f.width() + 3) + 'px',
                            height: (td2f.position().top - td1f.position().top + td2f.height() + 3) + 'px'
                        });
                    } else {
                        $range.hide();
                    }
                } else {
                    $range.hide();
                }
                // regular columns range
                var $range = $('#grid_' + this.name + '_' + rg.name);
                if (td1.length > 0 || td2.length > 0) {
                    if ($range.length === 0) {
                        rec2.append('&lt;div id="grid_' + this.name + '_' + rg.name + '" class="w2ui-selection" style="' + rg.style + '">' +
                            (rg.name == 'selection' ? '&lt;div id="grid_' + this.name + '_resizer" class="w2ui-selection-resizer">&lt;/div>' : '') +
                            '&lt;/div>');
                        $range = $('#grid_' + this.name + '_' + rg.name);
                    } else {
                        $range.attr('style', rg.style);
                    }
                    if (td1.length === 0) {
                        td1 = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(first.recid) + ' td:first-child');
                        if (td1.length === 0) td1 = $('#grid_' + this.name + '_rec_top td:first-child');
                    }
                    if (td2f.length !== 0) {
                        $range.css('border-left', '0px');
                    }
                    if (first.recid != null &amp;&amp; last.recid != null &amp;&amp; td1.length > 0 &amp;&amp; td2.length > 0) {
                        var _left = (td1.position().left - 1 + rec2.scrollLeft());
                        var _top = (td1.position().top - 1 + rec2.scrollTop());
                        $range.show().css({
                            left: (_left > 0 ? _left : 0) + 'px',
                            top: (_top > 0 ? _top : 0) + 'px',
                            width: (td2.position().left - td1.position().left + td2.width() + 3) + 'px',
                            height: (td2.position().top - td1.position().top + td2.height() + 3) + 'px'
                        });
                    } else {
                        $range.hide();
                    }
                } else {
                    $range.hide();
                }
            }

            // add resizer events
            $(this.box).find('.w2ui-selection-resizer')
                .off('mousedown').on('mousedown', mouseStart)
                .off('dblclick').on('dblclick', function (event) {
                var edata = obj.trigger({
                    phase: 'before',
                    type: 'resizerDblClick',
                    target: obj.name,
                    originalEvent: event
                });
                if (edata.isCancelled === true) return;
                obj.trigger($.extend(edata, {phase: 'after'}));
            });
            var edata = {
                phase: 'before',
                type: 'selectionExtend',
                target: obj.name,
                originalRange: null,
                newRange: null
            };

            return (new Date()).getTime() - time;

            function mouseStart(event) {
                var sel = obj.getSelection();
                obj.last.move = {
                    type: 'expand',
                    x: event.screenX,
                    y: event.screenY,
                    divX: 0,
                    divY: 0,
                    recid: sel[0].recid,
                    column: sel[0].column,
                    originalRange: [{recid: sel[0].recid, column: sel[0].column}, {
                        recid: sel[sel.length - 1].recid,
                        column: sel[sel.length - 1].column
                    }],
                    newRange: [{recid: sel[0].recid, column: sel[0].column}, {
                        recid: sel[sel.length - 1].recid,
                        column: sel[sel.length - 1].column
                    }]
                };
                $(document).off('mousemove', mouseMove).on('mousemove', mouseMove);
                $(document).off('mouseup', mouseStop).on('mouseup', mouseStop);
                // do not blur grid
                event.preventDefault();
            }

            function mouseMove(event) {
                var mv = obj.last.move;
                if (!mv || mv.type != 'expand') return;
                mv.divX = (event.screenX - mv.x);
                mv.divY = (event.screenY - mv.y);
                // find new cell
                var recid, column;
                var tmp = event.originalEvent.target;
                if (tmp.tagName.toUpperCase() != 'TD') tmp = $(tmp).parents('td')[0];
                if ($(tmp).attr('col') != null) column = parseInt($(tmp).attr('col'));
                tmp = $(tmp).parents('tr')[0];
                recid = $(tmp).attr('recid');
                // new range
                if (mv.newRange[1].recid == recid &amp;&amp; mv.newRange[1].column == column) return;
                var prevNewRange = $.extend({}, mv.newRange);
                mv.newRange = [{recid: mv.recid, column: mv.column}, {recid: recid, column: column}];
                // event before
                edata = obj.trigger($.extend(edata, {originalRange: mv.originalRange, newRange: mv.newRange}));
                if (edata.isCancelled === true) {
                    mv.newRange = prevNewRange;
                    edata.newRange = prevNewRange;
                    return;
                } else {
                    // default behavior
                    obj.removeRange('grid-selection-expand');
                    obj.addRange({
                        name: 'grid-selection-expand',
                        range: edata.newRange,
                        style: 'background-color: rgba(100,100,100,0.1); border: 2px dotted rgba(100,100,100,0.5);'
                    });
                }
            }

            function mouseStop(event) {
                // default behavior
                obj.removeRange('grid-selection-expand');
                delete obj.last.move;
                $(document).off('mousemove', mouseMove);
                $(document).off('mouseup', mouseStop);
                // event after
                obj.trigger($.extend(edata, {phase: 'after'}));
            }
        },

        select: function () {
            if (arguments.length === 0) return 0;
            var time = (new Date).getTime();
            var selected = 0;
            var sel = this.last.selection;
            if (!this.multiSelect) this.selectNone();

            // event before
            var tmp = {phase: 'before', type: 'select', target: this.name};
            if (arguments.length == 1) {
                tmp.multiple = false;
                if ($.isPlainObject(arguments[0])) {
                    tmp.recid = arguments[0].recid;
                    tmp.column = arguments[0].column;
                } else {
                    tmp.recid = arguments[0];
                }
            } else {
                tmp.multiple = true;
                tmp.recids = Array.prototype.slice.call(arguments, 0);
            }
            var edata = this.trigger(tmp);
            if (edata.isCancelled === true) return 0;

            // default action
            if (this.selectType == 'row') {
                for (var a = 0; a &lt; arguments.length; a++) {
                    var recid = typeof arguments[a] == 'object' ? arguments[a].recid : arguments[a];
                    //handmade
                    if (recid.split('&amp;')[0] === 'group') continue;
                    var index = this.get(recid, true);
                    if (index == null) continue;
                    var recEl1 = null;
                    var recEl2 = null;
                    if (this.searchData.length !== 0 || (index + 1 >= this.last.range_start &amp;&amp; index + 1 &lt;= this.last.range_end)) {
                        recEl1 = $('#grid_' + this.name + '_frec_' + w2utils.escapeId(recid));
                        recEl2 = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(recid));
                    }
                    if (this.selectType == 'row') {
                        if (sel.indexes.indexOf(index) != -1) continue;
                        sel.indexes.push(index);
                        if (recEl1 &amp;&amp; recEl2) {
                            recEl1.addClass('w2ui-selected').data('selected', 'yes').find('.w2ui-col-number').addClass('w2ui-row-selected');
                            recEl2.addClass('w2ui-selected').data('selected', 'yes').find('.w2ui-col-number').addClass('w2ui-row-selected');
                            recEl1.find('.w2ui-grid-select-check').prop("checked", true);
                        }
                        selected++;
                    }
                }
            } else {
                // normalize for performance
                var new_sel = {};
                for (var a = 0; a &lt; arguments.length; a++) {
                    var recid = typeof arguments[a] == 'object' ? arguments[a].recid : arguments[a];
                    var column = typeof arguments[a] == 'object' ? arguments[a].column : null;
                    new_sel[recid] = new_sel[recid] || [];
                    if ($.isArray(column)) {
                        new_sel[recid] = column;
                    } else if (w2utils.isInt(column)) {
                        new_sel[recid].push(column);
                    } else {
                        for (var i = 0; i &lt; this.columns.length; i++) {
                            if (this.columns[i].hidden) continue;
                            new_sel[recid].push(parseInt(i));
                        }
                    }
                }
                // add all
                var col_sel = [];
                for (var recid in new_sel) {
                    var index = this.get(recid, true);
                    if (index == null) continue;
                    var recEl1 = null;
                    var recEl2 = null;
                    if (index + 1 >= this.last.range_start &amp;&amp; index + 1 &lt;= this.last.range_end) {
                        recEl1 = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(recid));
                        recEl2 = $('#grid_' + this.name + '_frec_' + w2utils.escapeId(recid));
                    }
                    var s = sel.columns[index] || [];
                    // default action
                    if (sel.indexes.indexOf(index) == -1) {
                        sel.indexes.push(index);
                    }
                    // anly only those that are new
                    for (var t = 0; t &lt; new_sel[recid].length; t++) {
                        if (s.indexOf(new_sel[recid][t]) == -1) s.push(new_sel[recid][t]);
                    }
                    s.sort(function (a, b) {
                        return a - b;
                    }); // sort function must be for numerical sort
                    for (var t = 0; t &lt; new_sel[recid].length; t++) {
                        var col = new_sel[recid][t];
                        if (col_sel.indexOf(col) == -1) col_sel.push(col);
                        if (recEl1) {
                            recEl1.find('#grid_' + this.name + '_data_' + index + '_' + col).addClass('w2ui-selected');
                            recEl1.find('.w2ui-col-number').addClass('w2ui-row-selected');
                            recEl1.data('selected', 'yes');
                            recEl1.find('.w2ui-grid-select-check').prop("checked", true);
                        }
                        if (recEl2) {
                            recEl2.find('#grid_' + this.name + '_data_' + index + '_' + col).addClass('w2ui-selected');
                            recEl2.find('.w2ui-col-number').addClass('w2ui-row-selected');
                            recEl2.data('selected', 'yes');
                            recEl2.find('.w2ui-grid-select-check').prop("checked", true);
                        }
                        selected++;
                    }
                    // save back to selection object
                    sel.columns[index] = s;
                }
                // select columns (need here for speed)
                for (var c = 0; c &lt; col_sel.length; c++) {
                    $(this.box).find('#grid_' + this.name + '_column_' + col_sel[c] + ' .w2ui-col-header').addClass('w2ui-col-selected');
                }
            }
            // need to sort new selection for speed
            sel.indexes.sort(function (a, b) {
                return a - b;
            });
            // all selected?
            var areAllSelected = (this.records.length > 0 &amp;&amp; sel.indexes.length == this.records.length),
                areAllSearchedSelected = (sel.indexes.length > 0 &amp;&amp; this.searchData.length !== 0 &amp;&amp; sel.indexes.length == this.last.searchIds.length);
            if (areAllSelected || areAllSearchedSelected) {
                $('#grid_' + this.name + '_check_all').prop('checked', true);
            } else {
                $('#grid_' + this.name + '_check_all').prop('checked', false);
            }
            this.status();
            this.addRange('selection');
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            return selected;
        },

        unselect: function () {
            var unselected = 0;
            var sel = this.last.selection;
            for (var a = 0; a &lt; arguments.length; a++) {
                var recid = typeof arguments[a] == 'object' ? arguments[a].recid : arguments[a];
                var record = this.get(recid);
                if (record == null) continue;
                var index = this.get(record.recid, true);
                var recEl1 = $('#grid_' + this.name + '_frec_' + w2utils.escapeId(recid));
                var recEl2 = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(recid));
                if (this.selectType == 'row') {
                    if (sel.indexes.indexOf(index) == -1) continue;
                    // event before
                    var edata = this.trigger({
                        phase: 'before',
                        type: 'unselect',
                        target: this.name,
                        recid: recid,
                        index: index
                    });
                    if (edata.isCancelled === true) continue;
                    // default action
                    sel.indexes.splice(sel.indexes.indexOf(index), 1);
                    recEl1.removeClass('w2ui-selected w2ui-inactive').removeData('selected').find('.w2ui-col-number').removeClass('w2ui-row-selected');
                    recEl2.removeClass('w2ui-selected w2ui-inactive').removeData('selected').find('.w2ui-col-number').removeClass('w2ui-row-selected');
                    if (recEl1.length != 0) {
                        recEl1[0].style.cssText = 'height: ' + this.recordHeight + 'px; ' + recEl1.attr('custom_style');
                        recEl2[0].style.cssText = 'height: ' + this.recordHeight + 'px; ' + recEl2.attr('custom_style');
                    }
                    recEl1.find('.w2ui-grid-select-check').prop("checked", false);
                    unselected++;
                } else {
                    var col = arguments[a].column;
                    if (!w2utils.isInt(col)) { // unselect all columns
                        var cols = [];
                        for (var i = 0; i &lt; this.columns.length; i++) {
                            if (this.columns[i].hidden) continue;
                            cols.push({recid: recid, column: i});
                        }
                        return this.unselect.apply(this, cols);
                    }
                    var s = sel.columns[index];
                    if (!$.isArray(s) || s.indexOf(col) == -1) continue;
                    // event before
                    var edata = this.trigger({
                        phase: 'before',
                        type: 'unselect',
                        target: this.name,
                        recid: recid,
                        column: col
                    });
                    if (edata.isCancelled === true) continue;
                    // default action
                    s.splice(s.indexOf(col), 1);
                    $('#grid_' + this.name + '_rec_' + w2utils.escapeId(recid)).find(' > td[col=' + col + ']').removeClass('w2ui-selected w2ui-inactive');
                    $('#grid_' + this.name + '_frec_' + w2utils.escapeId(recid)).find(' > td[col=' + col + ']').removeClass('w2ui-selected w2ui-inactive');
                    // check if any row/column still selected
                    var isColSelected = false;
                    var isRowSelected = false;
                    var tmp = this.getSelection();
                    for (var i = 0; i &lt; tmp.length; i++) {
                        if (tmp[i].column == col) isColSelected = true;
                        if (tmp[i].recid == recid) isRowSelected = true;
                    }
                    if (!isColSelected) {
                        $(this.box).find('.w2ui-grid-columns td[col=' + col + '] .w2ui-col-header, .w2ui-grid-fcolumns td[col=' + col + '] .w2ui-col-header').removeClass('w2ui-col-selected');
                    }
                    if (!isRowSelected) {
                        $('#grid_' + this.name + '_frec_' + w2utils.escapeId(recid)).find('.w2ui-col-number').removeClass('w2ui-row-selected');
                    }
                    unselected++;
                    if (s.length === 0) {
                        delete sel.columns[index];
                        sel.indexes.splice(sel.indexes.indexOf(index), 1);
                        recEl1.removeData('selected');
                        recEl1.find('.w2ui-grid-select-check').prop("checked", false);
                        recEl2.removeData('selected');
                    }
                }
                // event after
                this.trigger($.extend(edata, {phase: 'after'}));
            }
            // all selected?
            var areAllSelected = (this.records.length > 0 &amp;&amp; sel.indexes.length == this.records.length),
                areAllSearchedSelected = (sel.indexes.length > 0 &amp;&amp; this.searchData.length !== 0 &amp;&amp; sel.indexes.length == this.last.searchIds.length);
            if (areAllSelected || areAllSearchedSelected) {
                $('#grid_' + this.name + '_check_all').prop('checked', true);
            } else {
                $('#grid_' + this.name + '_check_all').prop('checked', false);
            }
            // show number of selected
            this.status();
            this.addRange('selection');
            return unselected;
        },

        selectAll: function () {
            var time = (new Date()).getTime();
            if (this.multiSelect === false) return;
            // event before
            var edata = this.trigger({phase: 'before', type: 'select', target: this.name, all: true});
            if (edata.isCancelled === true) return;
            // default action
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            var sel = this.last.selection;
            var cols = [];
            for (var i = 0; i &lt; this.columns.length; i++) cols.push(i);
            // if local data source and searched
            sel.indexes = [];
            if (!url &amp;&amp; this.searchData.length !== 0) {
                // local search applied
                for (var i = 0; i &lt; this.last.searchIds.length; i++) {
                    sel.indexes.push(this.last.searchIds[i]);
                    if (this.selectType != 'row') sel.columns[this.last.searchIds[i]] = cols.slice(); // .slice makes copy of the array
                }
            } else {
                var buffered = this.records.length;
                if (this.searchData.length != 0 &amp;&amp; !url) buffered = this.last.searchIds.length;
                for (var i = 0; i &lt; buffered; i++) {
                    sel.indexes.push(i);
                    if (this.selectType != 'row') sel.columns[i] = cols.slice(); // .slice makes copy of the array
                }
            }
            // add selected class
            if (this.selectType == 'row') {
                $(this.box).find('.w2ui-grid-records tr').not('.w2ui-empty-record')
                    .addClass('w2ui-selected').data('selected', 'yes').find('.w2ui-col-number').addClass('w2ui-row-selected');
                $(this.box).find('.w2ui-grid-frecords tr').not('.w2ui-empty-record')
                    .addClass('w2ui-selected').data('selected', 'yes').find('.w2ui-col-number').addClass('w2ui-row-selected');
                $(this.box).find('input.w2ui-grid-select-check').prop('checked', true);
            } else {
                $(this.box).find('.w2ui-grid-columns td .w2ui-col-header, .w2ui-grid-fcolumns td .w2ui-col-header').addClass('w2ui-col-selected');
                $(this.box).find('.w2ui-grid-records tr .w2ui-col-number').addClass('w2ui-row-selected');
                $(this.box).find('.w2ui-grid-records tr').not('.w2ui-empty-record')
                    .find('.w2ui-grid-data').not('.w2ui-col-select').addClass('w2ui-selected').data('selected', 'yes');
                $(this.box).find('.w2ui-grid-frecords tr .w2ui-col-number').addClass('w2ui-row-selected');
                $(this.box).find('.w2ui-grid-frecords tr').not('.w2ui-empty-record')
                    .find('.w2ui-grid-data').not('.w2ui-col-select').addClass('w2ui-selected').data('selected', 'yes');
                $(this.box).find('input.w2ui-grid-select-check').prop('checked', true);
            }
            // enable/disable toolbar buttons
            var sel = this.getSelection();
            if (sel.length == 1) this.toolbar.enable('w2ui-edit'); else this.toolbar.disable('w2ui-edit');
            if (sel.length >= 1) this.toolbar.enable('w2ui-delete'); else this.toolbar.disable('w2ui-delete');
            this.addRange('selection');
            $('#grid_' + this.name + '_check_all').prop('checked', true);
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            return (new Date()).getTime() - time;
        },

        selectNone: function () {
            var time = (new Date()).getTime();
            // event before
            var edata = this.trigger({phase: 'before', type: 'unselect', target: this.name, all: true});
            if (edata.isCancelled === true) return;
            // default action
            var sel = this.last.selection;
            // remove selected class
            if (this.selectType == 'row') {
                $(this.box).find('.w2ui-grid-records tr.w2ui-selected').removeClass('w2ui-selected w2ui-inactive').removeData('selected')
                    .find('.w2ui-col-number').removeClass('w2ui-row-selected');
                $(this.box).find('.w2ui-grid-frecords tr.w2ui-selected').removeClass('w2ui-selected w2ui-inactive').removeData('selected')
                    .find('.w2ui-col-number').removeClass('w2ui-row-selected');
                $(this.box).find('input.w2ui-grid-select-check').prop('checked', false);
            } else {
                $(this.box).find('.w2ui-grid-columns td .w2ui-col-header, .w2ui-grid-fcolumns td .w2ui-col-header').removeClass('w2ui-col-selected');
                $(this.box).find('.w2ui-grid-records tr .w2ui-col-number').removeClass('w2ui-row-selected');
                $(this.box).find('.w2ui-grid-frecords tr .w2ui-col-number').removeClass('w2ui-row-selected');
                $(this.box).find('.w2ui-grid-data.w2ui-selected').removeClass('w2ui-selected w2ui-inactive').removeData('selected');
                $(this.box).find('input.w2ui-grid-select-check').prop('checked', false);
            }
            sel.indexes = [];
            sel.columns = {};
            this.toolbar.disable('w2ui-edit', 'w2ui-delete');
            this.removeRange('selection');
            $('#grid_' + this.name + '_check_all').prop('checked', false);
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            return (new Date()).getTime() - time;
        },

        getSelection: function (returnIndex) {
            var ret = [];
            var sel = this.last.selection;
            if (this.selectType == 'row') {
                for (var i = 0; i &lt; sel.indexes.length; i++) {
                    if (!this.records[sel.indexes[i]]) continue;
                    if (returnIndex === true) ret.push(sel.indexes[i]); else ret.push(this.records[sel.indexes[i]].recid);
                }
                return ret;
            } else {
                for (var i = 0; i &lt; sel.indexes.length; i++) {
                    var cols = sel.columns[sel.indexes[i]];
                    if (!this.records[sel.indexes[i]]) continue;
                    for (var j = 0; j &lt; cols.length; j++) {
                        ret.push({
                            recid: this.records[sel.indexes[i]].recid,
                            index: parseInt(sel.indexes[i]),
                            column: cols[j]
                        });
                    }
                }
                return ret;
            }
        },

        search: function (field, value) {
            var obj = this;
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            var searchData = [];
            var last_multi = this.last.multi;
            var last_logic = this.last.logic;
            var last_field = this.last.field;
            var last_search = this.last.search;
            var hasHiddenSearches = false;
            // add hidden searches
            for (var i = 0; i &lt; this.searches.length; i++) {
                if (!this.searches[i].hidden) continue;
                searchData.push({
                    field: this.searches[i].field,
                    operator: this.searches[i].operator || 'is',
                    type: this.searches[i].type,
                    value: this.searches[i].value || ''
                });
                hasHiddenSearches = true;
            }
            // 1: search() - advanced search (reads from popup)
            if (arguments.length === 0) {
                last_search = '';
                // advanced search
                for (var i = 0; i &lt; this.searches.length; i++) {
                    var search = this.searches[i];
                    var operator = $('#grid_' + this.name + '_operator_' + i).val();
                    var field1 = $('#grid_' + this.name + '_field_' + i);
                    var field2 = $('#grid_' + this.name + '_field2_' + i);
                    var value1 = field1.val();
                    var value2 = field2.val();
                    var svalue = null;
                    var text = null;

                    if (['int', 'float', 'money', 'currency', 'percent'].indexOf(search.type) != -1) {
                        var fld1 = field1.data('w2field');
                        var fld2 = field2.data('w2field');
                        if (fld1) value1 = fld1.clean(value1);
                        if (fld2) value2 = fld2.clean(value2);
                    }
                    if (['list', 'enum'].indexOf(search.type) != -1) {
                        value1 = field1.data('selected') || {};
                        if ($.isArray(value1)) {
                            svalue = [];
                            for (var j = 0; j &lt; value1.length; j++) {
                                svalue.push(w2utils.isFloat(value1[j].id) ? parseFloat(value1[j].id) : String(value1[j].id).toLowerCase());
                                delete value1[j].hidden;
                            }
                            if ($.isEmptyObject(value1)) value1 = '';
                        } else {
                            text = value1.text || '';
                            value1 = value1.id || '';
                        }
                    }
                    if ((value1 !== '' &amp;&amp; value1 != null) || (value2 != null &amp;&amp; value2 !== '')) {
                        var tmp = {
                            field: search.field,
                            type: search.type,
                            operator: operator
                        };
                        if (operator == 'between') {
                            $.extend(tmp, {value: [value1, value2]});
                        } else if (operator == 'in' &amp;&amp; typeof value1 == 'string') {
                            $.extend(tmp, {value: value1.split(',')});
                        } else if (operator == 'not in' &amp;&amp; typeof value1 == 'string') {
                            $.extend(tmp, {value: value1.split(',')});
                        } else {
                            $.extend(tmp, {value: value1});
                        }
                        if (svalue) $.extend(tmp, {svalue: svalue});
                        if (text) $.extend(tmp, {text: text});

                        // conver date to unix time
                        try {
                            if (search.type == 'date' &amp;&amp; operator == 'between') {
                                tmp.value[0] = value1; // w2utils.isDate(value1, w2utils.settings.dateFormat, true).getTime();
                                tmp.value[1] = value2; // w2utils.isDate(value2, w2utils.settings.dateFormat, true).getTime();
                            }
                            if (search.type == 'date' &amp;&amp; operator == 'is') {
                                tmp.value = value1; // w2utils.isDate(value1, w2utils.settings.dateFormat, true).getTime();
                            }
                        } catch (e) {

                        }
                        searchData.push(tmp);
                    }
                }
                last_multi = true;
                last_logic = 'AND';
            }
            // 2: search(field, value) - regular search
            if (typeof field == 'string') {
                // if only one argument - search all
                if (arguments.length == 1) {
                    value = field;
                    field = 'all';
                }
                last_field = field;
                last_search = value;
                last_multi = false;
                last_logic = (hasHiddenSearches ? 'AND' : 'OR');
                // loop through all searches and see if it applies
                if (value != null) {
                    if (field.toLowerCase() == 'all') {
                        // if there are search fields loop thru them
                        if (this.searches.length > 0) {
                            for (var i = 0; i &lt; this.searches.length; i++) {
                                var search = this.searches[i];
                                if (search.type == 'text' || (search.type == 'alphanumeric' &amp;&amp; w2utils.isAlphaNumeric(value))
                                    || (search.type == 'int' &amp;&amp; w2utils.isInt(value)) || (search.type == 'float' &amp;&amp; w2utils.isFloat(value))
                                    || (search.type == 'percent' &amp;&amp; w2utils.isFloat(value)) || ((search.type == 'hex' || search.type == 'color') &amp;&amp; w2utils.isHex(value))
                                    || (search.type == 'currency' &amp;&amp; w2utils.isMoney(value)) || (search.type == 'money' &amp;&amp; w2utils.isMoney(value))
                                    || (search.type == 'date' &amp;&amp; w2utils.isDate(value)) || (search.type == 'time' &amp;&amp; w2utils.isTime(value))
                                    || (search.type == 'datetime' &amp;&amp; w2utils.isDateTime(value)) || (search.type == 'enum' &amp;&amp; w2utils.isAlphaNumeric(value))
                                    || (search.type == 'list' &amp;&amp; w2utils.isAlphaNumeric(value))
                                ) {
                                    var tmp = {
                                        field: search.field,
                                        type: search.type,
                                        operator: (search.operator != null ? search.operator : (search.type == 'text' ? this.textSearch : 'is')),
                                        value: value
                                    };
                                    if ($.trim(value) != '') searchData.push(tmp);
                                }
                                // range in global search box
                                if (['int', 'float', 'money', 'currency', 'percent'].indexOf(search.type) != -1 &amp;&amp; $.trim(String(value)).split('-').length == 2) {
                                    var t = $.trim(String(value)).split('-');
                                    var tmp = {
                                        field: search.field,
                                        type: search.type,
                                        operator: (search.operator != null ? search.operator : 'between'),
                                        value: [t[0], t[1]]
                                    };
                                    searchData.push(tmp);
                                }
                                // lists fiels
                                if (['list', 'enum'].indexOf(search.type) != -1) {
                                    var new_values = [];
                                    for (var j = 0; j &lt; search.options.items; j++) {
                                        var tmp = search.options.items[j];
                                        try {
                                            var re = new RegExp(value, 'i');
                                            if (re.test(tmp)) new_values.push(j);
                                            if (tmp.text &amp;&amp; re.test(tmp.text)) new_values.push(tmp.id);
                                        } catch (e) {
                                        }
                                    }
                                    if (new_values.length > 0) {
                                        var tmp = {
                                            field: search.field,
                                            type: search.type,
                                            operator: (search.operator != null ? search.operator : 'in'),
                                            value: new_values
                                        };
                                        searchData.push(tmp);
                                    }
                                }
                            }
                        } else {
                            // no search fields, loop thru columns
                            for (var i = 0; i &lt; this.columns.length; i++) {
                                var tmp = {
                                    field: this.columns[i].field,
                                    type: 'text',
                                    operator: this.textSearch,
                                    value: value
                                };
                                searchData.push(tmp);
                            }
                        }
                    } else {
                        var el = $('#grid_' + this.name + '_search_all');
                        var search = this.getSearch(field);
                        if (search == null) search = {field: field, type: 'text'};
                        if (search.field == field) this.last.caption = search.caption;
                        if (value !== '') {
                            var op = this.textSearch;
                            var val = value;
                            if (['date', 'time', 'datetime'].indexOf(search.type) != -1) op = 'is';
                            if (['list', 'enum'].indexOf(search.type) != -1) {
                                op = 'is';
                                var tmp = el.data('selected');
                                if (tmp &amp;&amp; !$.isEmptyObject(tmp)) val = tmp.id; else val = '';
                            }
                            if (search.type == 'int' &amp;&amp; value !== '') {
                                op = 'is';
                                if (String(value).indexOf('-') != -1) {
                                    var tmp = value.split('-');
                                    if (tmp.length == 2) {
                                        op = 'between';
                                        val = [parseInt(tmp[0]), parseInt(tmp[1])];
                                    }
                                }
                                if (String(value).indexOf(',') != -1) {
                                    var tmp = value.split(',');
                                    op = 'in';
                                    val = [];
                                    for (var i = 0; i &lt; tmp.length; i++) val.push(tmp[i]);
                                }
                            }
                            if (search.operator != null) op = search.operator;
                            var tmp = {
                                field: search.field,
                                type: search.type,
                                operator: op,
                                value: val
                            };
                            searchData.push(tmp);
                        }
                    }
                }
            }
            // 3: search([ { field, value, [operator,] [type] }, { field, value, [operator,] [type] } ], logic) - submit whole structure
            if ($.isArray(field)) {
                var logic = 'AND';
                if (typeof value == 'string') {
                    logic = value.toUpperCase();
                    if (logic != 'OR' &amp;&amp; logic != 'AND') logic = 'AND';
                }
                last_search = '';
                last_multi = true;
                last_logic = logic;
                for (var i = 0; i &lt; field.length; i++) {
                    var data = field[i];
                    var search = this.getSearch(data.field);
                    if (search == null) search = {type: 'text', operator: 'begins'};
                    if ($.isArray(data.value)) {
                        for (var j = 0; j &lt; data.value.length; j++) {
                            if (typeof data.value[j] == 'string') data.value[j] = data.value[j].toLowerCase();
                        }
                    }
                    // merge current field and search if any
                    searchData.push($.extend(true, {}, search, data));
                }
            }
            // event before
            var edata = this.trigger({
                phase: 'before',
                type: 'search',
                multi: (arguments.length === 0 ? true : false),
                target: this.name,
                searchData: searchData,
                searchField: (field ? field : 'multi'),
                searchValue: (field ? value : 'multi')
            });
            if (edata.isCancelled === true) return;
            // default action
            this.searchData = edata.searchData;
            this.last.field = last_field;
            this.last.search = last_search;
            this.last.multi = last_multi;
            this.last.logic = last_logic;
            this.last.scrollTop = 0;
            this.last.scrollLeft = 0;
            this.last.selection.indexes = [];
            this.last.selection.columns = {};
            // -- clear all search field
            this.searchClose();
            // apply search
            if (url) {
                this.last.xhr_offset = 0;
                this.reload();
            } else {
                // local search
                this.localSearch();
                this.refresh();
            }
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        searchOpen: function () {
            if (!this.box) return;
            if (this.searches.length === 0) return;
            var obj = this;
            // event before
            var edata = this.trigger({phase: 'before', type: 'searchOpen', target: this.name});
            if (edata.isCancelled === true) {
                setTimeout(function () {
                    obj.toolbar.uncheck('w2ui-search-advanced');
                }, 1);
                return;
            }
            // show search
            $('#tb_' + this.name + '_toolbar_item_w2ui-search-advanced').w2overlay({
                html: this.getSearchesHTML(),
                name: this.name + '-searchOverlay',
                left: -10,
                'class': 'w2ui-grid-searches',
                onShow: function () {
                    obj.initSearches();
                    $('#w2ui-overlay-' + obj.name + '-searchOverlay .w2ui-grid-searches').data('grid-name', obj.name);
                    var sfields = $('#w2ui-overlay-' + this.name + '-searchOverlay .w2ui-grid-searches *[rel=search]');
                    if (sfields.length > 0) sfields[0].focus();
                    // event after
                    obj.trigger($.extend(edata, {phase: 'after'}));
                }
            });
        },

        searchClose: function () {
            var obj = this;
            if (!this.box) return;
            if (this.searches.length === 0) return;
            if (this.toolbar) this.toolbar.uncheck('w2ui-search-advanced');
            // hide search
            $().w2overlay({name: this.name + '-searchOverlay'});
            $().w2overlay({name: this.name + '-searchOverlay'}); // need to call twice as first ignored after click
        },

        searchReset: function (noRefresh) {
            var searchData = [];
            var hasHiddenSearches = false;
            // add hidden searches
            for (var i = 0; i &lt; this.searches.length; i++) {
                if (!this.searches[i].hidden) continue;
                searchData.push({
                    field: this.searches[i].field,
                    operator: this.searches[i].operator || 'is',
                    type: this.searches[i].type,
                    value: this.searches[i].value || ''
                });
                hasHiddenSearches = true;
            }
            // event before
            var edata = this.trigger({
                phase: 'before',
                type: 'search',
                reset: true,
                target: this.name,
                searchData: searchData
            });
            if (edata.isCancelled === true) return;
            // default action
            this.searchData = edata.searchData;
            this.last.search = '';
            this.last.logic = (hasHiddenSearches ? 'AND' : 'OR');
            // --- do not reset to All Fields (I think)
            if (this.searches.length > 0) {
                if (!this.multiSearch || !this.show.searchAll) {
                    var tmp = 0;
                    while (tmp &lt; this.searches.length &amp;&amp; (this.searches[tmp].hidden || this.searches[tmp].simple === false)) tmp++;
                    if (tmp >= this.searches.length) {
                        // all searches are hidden
                        this.last.field = '';
                        this.last.caption = '';
                    } else {
                        this.last.field = this.searches[tmp].field;
                        this.last.caption = this.searches[tmp].caption;
                    }
                } else {
                    this.last.field = 'all';
                    this.last.caption = w2utils.lang('All Fields');
                }
            }
            this.last.multi = false;
            this.last.xhr_offset = 0;
            // reset scrolling position
            this.last.scrollTop = 0;
            this.last.scrollLeft = 0;
            this.last.selection.indexes = [];
            this.last.selection.columns = {};
            // -- clear all search field
            this.searchClose();
            $('#grid_' + this.name + '_search_all').val('').removeData('selected');
            // apply search
            if (!noRefresh) this.reload();
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        searchShowFields: function () {
            var obj = this;
            var el = $('#grid_' + this.name + '_search_all');
            var html = '&lt;div class="w2ui-select-field">&lt;table>&lt;tbody>';
            for (var s = -1; s &lt; this.searches.length; s++) {
                var search = this.searches[s];
                if (s == -1) {
                    if (!this.multiSearch || !this.show.searchAll) continue;
                    search = {field: 'all', caption: w2utils.lang('All Fields')};
                } else {
                    if (this.searches[s].hidden === true || this.searches[s].simple === false) continue;
                }
                html += '&lt;tr ' + (w2utils.isIOS ? 'onTouchStart' : 'onClick') + '="w2ui[\'' + this.name + '\'].initAllField(\'' + search.field + '\');' +
                    '      event.stopPropagation(); jQuery(\'#grid_' + this.name + '_search_all\').w2overlay({ name: \'' + this.name + '-searchFields\' });">' +
                    '   &lt;td>' +
                    '       &lt;span class="w2ui-column-check w2ui-icon-' + (search.field == this.last.field ? 'check' : 'empty') + '">&lt;/span>' +
                    '   &lt;/td>' +
                    '   &lt;td>' + search.caption + '&lt;/td>' +
                    '&lt;/tr>';
            }
            html += "&lt;/tbody>&lt;/table>&lt;/div>";
            // need timer otherwise does nto show with list type
            setTimeout(function () {
                $(el).w2overlay({html: html, name: obj.name + '-searchFields', left: -10});
            }, 1);
        },

        initAllField: function (field, value) {
            var el = $('#grid_' + this.name + '_search_all');
            if (field == 'all') {
                var search = {field: 'all', caption: w2utils.lang('All Fields')};
                el.w2field('clear');
                el.change();
            } else {
                var search = this.getSearch(field);
                if (search == null) return;
                var st = search.type;
                if (['enum', 'select'].indexOf(st) != -1) st = 'list';
                el.w2field(st, $.extend({}, search.options, {suffix: '', autoFormat: false, selected: value}));
                if (['list', 'enum', 'date', 'time', 'datetime'].indexOf(search.type) != -1) {
                    this.last.search = '';
                    this.last.item = '';
                    el.val('');
                }
            }
            // update field
            if (this.last.search != '') {
                this.last.caption = search.caption;
                this.search(search.field, this.last.search);
            } else {
                this.last.field = search.field;
                this.last.caption = search.caption;
            }
            el.attr('placeholder', w2utils.lang(search.caption));
            $().w2overlay({name: this.name + '-searchFields'});
        },

        // clears records and related params
        clear: function (noRefresh) {
            this.total = 0;
            this.records = [];
            this.summary = [];
            this.last.xhr_offset = 0;   // need this for reload button to work on remote data set
            this.reset(true);
            // refresh
            if (!noRefresh) this.refresh();
        },

        // clears scroll position, selection, ranges
        reset: function (noRefresh) {
            // position
            this.last.scrollTop = 0;
            this.last.scrollLeft = 0;
            this.last.selection = {indexes: [], columns: {}};
            this.last.range_start = null;
            this.last.range_end = null;
            // additional
            $('#grid_' + this.name + '_records').prop('scrollTop', 0);
            // refresh
            if (!noRefresh) this.refresh();
        },

        skip: function (offset, callBack) {
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (url) {
                this.offset = parseInt(offset);
                if (this.offset > this.total) this.offset = this.total - this.limit;
                if (this.offset &lt; 0 || !w2utils.isInt(this.offset)) this.offset = 0;
                this.clear(true);
                this.reload(callBack);
            } else {
                console.log('ERROR: grid.skip() can only be called when you have remote data source.');
            }
        },

        load: function (url, callBack) {
            if (url == null) {
                console.log('ERROR: You need to provide url argument when calling .load() method of "' + this.name + '" object.');
                return;
            }
            // default action
            this.clear(true);
            this.request('get', {}, url, callBack);
        },

        reload: function (callBack) {
            var grid = this;
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            grid.selectionSave();
            if (url) {
                // need to remember selection (not just last.selection object)
                this.load(url, function () {
                    grid.selectionRestore();
                    if (typeof callBack == 'function') callBack();
                });
            } else {
                this.reset(true);
                this.localSearch();
                this.selectionRestore();
                if (typeof callBack == 'function') callBack({status: 'success'});
            }
        },

        request: function (cmd, add_params, url, callBack) {
            if (add_params == null) add_params = {};
            if (url == '' || url == null) url = this.url;
            if (url == '' || url == null) return;
            // build parameters list
            var params = {};
            if (!w2utils.isInt(this.offset)) this.offset = 0;
            if (!w2utils.isInt(this.last.xhr_offset)) this.last.xhr_offset = 0;
            // add list params
            params['cmd'] = cmd;
            params['selected'] = this.getSelection();
            params['limit'] = this.limit;
            params['offset'] = parseInt(this.offset) + parseInt(this.last.xhr_offset);
            params['search'] = this.searchData;
            params['searchLogic'] = this.last.logic;
            params['sort'] = this.sortData;
            if (this.searchData.length === 0) {
                delete params['search'];
                delete params['searchLogic'];
            }
            if (this.sortData.length === 0) {
                delete params['sort'];
            }
            // append other params
            $.extend(params, this.postData);
            $.extend(params, add_params);
            // event before
            if (cmd == 'get') {
                var edata = this.trigger({
                    phase: 'before',
                    type: 'request',
                    target: this.name,
                    url: url,
                    postData: params,
                    httpHeaders: this.httpHeaders
                });
                if (edata.isCancelled === true) {
                    if (typeof callBack == 'function') callBack({status: 'error', message: 'Request aborted.'});
                    return;
                }
            } else {
                var edata = {url: url, postData: params, httpHeaders: this.httpHeaders};
            }
            // call server to get data
            var obj = this;
            if (this.last.xhr_offset === 0) {
                obj.lock(w2utils.lang(obj.msgRefresh), true);
            } else {
                var more = $('#grid_' + this.name + '_rec_more, #grid_' + this.name + '_frec_more');
                if (this.autoLoad === true) {
                    more.show().find('td').html('&lt;div>&lt;div style="width: 20px; height: 20px;" class="w2ui-spinner">&lt;/div>&lt;/div>');
                } else {
                    more.find('td').html('&lt;div>' + w2utils.lang('Load') + ' ' + obj.limit + ' ' + w2utils.lang('More') + '...&lt;/div>');
                }
            }
            if (this.last.xhr) try {
                this.last.xhr.abort();
            } catch (e) {
            }
            // URL
            url = (typeof edata.url != 'object' ? edata.url : edata.url.get);
            if (params.cmd == 'save' &amp;&amp; typeof edata.url == 'object') url = edata.url.save;
            if (params.cmd == 'delete' &amp;&amp; typeof edata.url == 'object') url = edata.url.remove;
            // process url with routeData
            if (!$.isEmptyObject(obj.routeData)) {
                var info = w2utils.parseRoute(url);
                if (info.keys.length > 0) {
                    for (var k = 0; k &lt; info.keys.length; k++) {
                        if (obj.routeData[info.keys[k].name] == null) continue;
                        url = url.replace((new RegExp(':' + info.keys[k].name, 'g')), obj.routeData[info.keys[k].name]);
                    }
                }
            }
            // ajax ptions
            var ajaxOptions = {
                type: 'POST',
                url: url,
                data: edata.postData,
                headers: edata.httpHeaders,
                dataType: 'text'  // expected data type from server
            };
            if (w2utils.settings.dataType == 'HTTP') {
                ajaxOptions.data = (typeof ajaxOptions.data == 'object' ? String($.param(ajaxOptions.data, false)).replace(/%5B/g, '[').replace(/%5D/g, ']') : ajaxOptions.data);
            }
            if (w2utils.settings.dataType == 'HTTPJSON') {
                //handemade
                ajaxOptions.data = $.param(ajaxOptions.data)/*{ request: JSON.stringify(ajaxOptions.data) }*/;
            }
            if (w2utils.settings.dataType == 'RESTFULL') {
                ajaxOptions.type = 'GET';
                if (params.cmd == 'save') ajaxOptions.type = 'PUT';  // so far it is always update
                if (params.cmd == 'delete') ajaxOptions.type = 'DELETE';
                ajaxOptions.data = (typeof ajaxOptions.data == 'object' ? String($.param(ajaxOptions.data, false)).replace(/%5B/g, '[').replace(/%5D/g, ']') : ajaxOptions.data);
            }
            if (w2utils.settings.dataType == 'RESTFULLJSON') {
                ajaxOptions.type = 'GET';
                if (params.cmd == 'save') ajaxOptions.type = 'PUT';  // so far it is always update
                if (params.cmd == 'delete') ajaxOptions.type = 'DELETE';
                ajaxOptions.data = JSON.stringify(ajaxOptions.data);
                ajaxOptions.contentType = 'application/json';
            }
            if (w2utils.settings.dataType == 'JSON') {
                ajaxOptions.type = 'POST';
                ajaxOptions.data = JSON.stringify(ajaxOptions.data);
                ajaxOptions.contentType = 'application/json';
            }
            if (this.method) ajaxOptions.type = this.method;

            this.last.xhr_cmd = params.cmd;
            this.last.xhr_start = (new Date()).getTime();
            this.last.xhr = $.ajax(ajaxOptions)
                .done(function (data, status, xhr) {
                    obj.requestComplete(status, cmd, callBack);
                })
                .fail(function (xhr, status, error) {
                    // trigger event
                    var errorObj = {status: status, error: error, rawResponseText: xhr.responseText};
                    var edata2 = obj.trigger({phase: 'before', type: 'error', error: errorObj, xhr: xhr});
                    if (edata2.isCancelled === true) return;
                    // default behavior
                    if (status != 'abort') { // it can be aborted by the grid itself
                        var data;
                        try {
                            data = $.parseJSON(xhr.responseText);
                        } catch (e) {
                        }
                        console.log('ERROR: Server communication failed.',
                            '\n   EXPECTED:', {status: 'success', total: 5, records: [{recid: 1, field: 'value'}]},
                            '\n         OR:', {status: 'error', message: 'error message'},
                            '\n   RECEIVED:', typeof data == 'object' ? data : xhr.responseText);
                        obj.requestComplete('error', cmd, callBack);
                    }
                    // event after
                    obj.trigger($.extend(edata2, {phase: 'after'}));
                });
            if (cmd == 'get') {
                // event after
                this.trigger($.extend(edata, {phase: 'after'}));
            }
        },

        requestComplete: function (status, cmd, callBack) {
            var obj = this;
            this.unlock();
            setTimeout(function () {
                if (obj.show.statusResponse) obj.status(w2utils.lang('Server Response') + ' ' + ((new Date()).getTime() - obj.last.xhr_start) / 1000 + ' ' + w2utils.lang('sec'));
            }, 10);
            this.last.pull_more = false;
            this.last.pull_refresh = true;

            // event before
            var event_name = 'load';
            if (this.last.xhr_cmd == 'save') event_name = 'save';
            if (this.last.xhr_cmd == 'delete') event_name = 'delete';
            var edata = this.trigger({
                phase: 'before',
                target: this.name,
                type: event_name,
                xhr: this.last.xhr,
                status: status
            });
            if (edata.isCancelled === true) {
                if (typeof callBack == 'function') callBack({status: 'error', message: 'Request aborted.'});
                return;
            }
            // parse server response
            var data;
            var responseText = this.last.xhr.responseText;
            if (status != 'error') {
                // default action
                if (responseText != null &amp;&amp; responseText != '') {
                    // check if the onLoad handler has not already parsed the data
                    if (typeof responseText == "object") {
                        data = responseText;
                    } else {
                        if (typeof obj.parser == 'function') {
                            data = obj.parser(responseText);
                            if (typeof data != 'object') {
                                console.log('ERROR: Your parser did not return proper object');
                            }
                        } else {
                            // $.parseJSON or $.getJSON did not work because those expect perfect JSON data - where everything is in double quotes
                            //
                            // TODO: avoid (potentially malicious) code injection from the response.
                            try {
                                eval('data = ' + responseText);
                            } catch (e) {
                            }
                        }
                    }
                    if (data == null) {
                        data = {
                            status: 'error',
                            message: w2utils.lang(this.msgNotJSON),
                            responseText: responseText
                        };
                    } else if (Array.isArray(data)) {
                        // if it is plain array, assume these are records
                        data = {
                            status: 'success',
                            records: data
                        }
                    }
                    if (obj.recid &amp;&amp; data.records) {
                        // convert recids
                        for (var i = 0; i &lt; data.records.length; i++) {
                            data.records[i]['recid'] = data.records[i][obj.recid];
                        }
                    }
                    if (data['status'] == 'error') {
                        obj.error(data['message']);
                    } else {
                        if (cmd == 'get') {
                            if (data.total == null) data.total = -1;
                            if (data.records.length == this.limit) {
                                this.last.xhr_hasMore = true;
                            } else {
                                this.last.xhr_hasMore = false;
                                this.total = this.last.xhr_offset + data.records.length;
                            }
                            if (this.last.xhr_offset === 0) {
                                this.records = [];
                                this.summary = [];
                                if (w2utils.isInt(data.total)) this.total = parseInt(data.total);
                            } else {
                                if (data.total != -1 &amp;&amp; parseInt(data.total) != parseInt(this.total)) {
                                    this.message(w2utils.lang(this.msgNeedReload), function () {
                                        delete this.last.xhr_offset;
                                        this.reload();
                                    }.bind(this));
                                    return;
                                }
                            }
                            // records
                            if (data.records) {
                                for (var r = 0; r &lt; data.records.length; r++) {
                                    this.records.push(data.records[r]);
                                }
                            }
                            // summary records (if any)
                            if (data.summary) {
                                this.summary = [];
                                for (var r = 0; r &lt; data.summary.length; r++) {
                                    this.summary.push(data.summary[r]);
                                }
                            }
                        }
                        if (cmd == 'delete') {
                            this.reset(); // unselect old selections
                            this.reload();
                            return;
                        }
                    }
                }
            } else {
                data = {
                    status: 'error',
                    message: w2utils.lang(this.msgAJAXerror),
                    responseText: responseText
                };
                obj.error(w2utils.lang(this.msgAJAXerror));
            }
            // event after
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (!url) {
                this.localSort();
                this.localSearch();
            }
            this.total = parseInt(this.total);
            // do not refresh if loading on infinite scroll
            if (this.last.xhr_offset === 0) {
                this.refresh();
            } else {
                this.scroll();
                this.resize();
            }
            // call back
            if (typeof callBack == 'function') callBack(data); // need to be befor event:after
            // after event
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        error: function (msg) {
            var obj = this;
            // let the management of the error outside of the grid
            var edata = this.trigger({target: this.name, type: 'error', message: msg, xhr: this.last.xhr});
            if (edata.isCancelled === true) {
                if (typeof callBack == 'function') callBack({status: 'error', message: 'Request aborted.'});
                return;
            }
            this.message(msg);
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        getChanges: function () {
            var changes = [];
            for (var r = 0; r &lt; this.records.length; r++) {
                var rec = this.records[r];
                if (rec.w2ui &amp;&amp; rec.w2ui.changes != null) {
                    changes.push($.extend(true, {recid: rec.recid}, rec.w2ui.changes));
                }
            }
            return changes;
        },

        mergeChanges: function () {
            var changes = this.getChanges();
            for (var c = 0; c &lt; changes.length; c++) {
                var record = this.get(changes[c].recid);
                for (var s in changes[c]) {
                    if (s == 'recid') continue; // do not allow to change recid
                    if (typeof changes[c][s] === "object") changes[c][s] = changes[c][s].text;
                    try {
                        if (s.indexOf('.') != -1) {
                            eval("record['" + s.replace(/\./g, "']['") + "'] = changes[c][s]")
                        } else {
                            record[s] = changes[c][s];
                        }
                    } catch (e) {
                        console.log('ERROR: Cannot merge. ', e.message || '', e);
                    }
                    if (record.w2ui) delete record.w2ui.changes;
                }
            }
            this.refresh();
        },

        // ===================================================
        // --  Action Handlers

        save: function () {
            var obj = this;
            var changes = this.getChanges();
            // event before
            var edata = this.trigger({phase: 'before', target: this.name, type: 'save', changes: changes});
            if (edata.isCancelled === true) return;
            var url = (typeof this.url != 'object' ? this.url : this.url.save);
            if (url) {
                this.request('save', {'changes': edata.changes}, null,
                    function (data) {
                        if (data.status !== 'error') {
                            // only merge changes, if save was successful
                            obj.mergeChanges();
                        }
                        // event after
                        obj.trigger($.extend(edata, {phase: 'after'}));
                    }
                );
            } else {
                this.mergeChanges();
                // event after
                this.trigger($.extend(edata, {phase: 'after'}));
            }
        },

        editField: function (recid, column, value, event) {
            var obj = this;
            var index = obj.get(recid, true);
            var edit = obj.getCellEditable(index, column);
            if (!edit) return;
            var rec = obj.records[index];
            var col = obj.columns[column];
            var prefix = (col.frozen === true ? '_f' : '_');
            if (['enum', 'file'].indexOf(edit.type) != -1) {
                console.log('ERROR: input types "enum" and "file" are not supported in inline editing.');
                return;
            }
            // event before
            var edata = obj.trigger({
                phase: 'before', type: 'editField', target: obj.name, recid: recid, column: column, value: value,
                index: index, originalEvent: event
            });
            if (edata.isCancelled === true) return;
            value = edata.value;
            // default behaviour
            this.selectNone();
            this.select({recid: recid, column: column});
            this.last.edit_col = column;
            if (['checkbox', 'check'].indexOf(edit.type) != -1) return;
            // create input element
            var tr = $('#grid_' + obj.name + prefix + 'rec_' + w2utils.escapeId(recid));
            var el = tr.find('[col=' + column + '] > div');
            // clear previous if any
            $(this.box).find('div.w2ui-edit-box').remove();
            // for spreadsheet - insert into selection
            if (this.selectType != 'row') {
                $('#grid_' + this.name + prefix + 'selection')
                    .attr('id', 'grid_' + this.name + '_editable')
                    .removeClass('w2ui-selection')
                    .addClass('w2ui-edit-box')
                    .prepend('&lt;div style="position: absolute; top: 0px; bottom: 0px; left: 0px; right: 0px;">&lt;/div>')
                    .find('.w2ui-selection-resizer')
                    .remove();
                el = $('#grid_' + this.name + '_editable >div:first-child');
            }
            if (edit.inTag == null) edit.inTag = '';
            if (edit.outTag == null) edit.outTag = '';
            if (edit.style == null) edit.style = '';
            if (edit.items == null) edit.items = [];
            var val = (rec.w2ui &amp;&amp; rec.w2ui.changes &amp;&amp; rec.w2ui.changes[col.field] != null ? w2utils.stripTags(rec.w2ui.changes[col.field]) : w2utils.stripTags(rec[col.field]));
            if (val == null) val = '';
            var old_value = (typeof val != 'object' ? val : '');
            if (edata.old_value != null) old_value = edata.old_value;
            if (value != null) val = value;
            var addStyle = (col.style != null ? col.style + ';' : '');
            if (typeof col.render == 'string' &amp;&amp; ['number', 'int', 'float', 'money', 'percent', 'size'].indexOf(col.render.split(':')[0]) != -1) {
                addStyle += 'text-align: right;';
            }
            // normalize items
            if (edit.items.length > 0 &amp;&amp; !$.isPlainObject(edit.items[0])) {
                edit.items = w2obj.field.prototype.normMenu(edit.items);
            }
            switch (edit.type) {

                case 'select':
                    var html = '';
                    for (var i = 0; i &lt; edit.items.length; i++) {
                        html += '&lt;option value="' + edit.items[i].id + '"' + (edit.items[i].id == val ? ' selected="selected"' : '') + '>' + edit.items[i].text + '&lt;/option>';
                    }
                    el.addClass('w2ui-editable')
                        .html('&lt;select id="grid_' + obj.name + '_edit_' + recid + '_' + column + '" column="' + column + '" class="w2ui-input"' +
                            '    style="width: 100%; pointer-events: auto; padding: 0 0 0 3px; margin: 0px; border-left: 0; border-right: 0; border-radius: 0px; ' +
                            '           outline: none; font-family: inherit;' + addStyle + edit.style + '" ' +
                            '    field="' + col.field + '" recid="' + recid + '" ' +
                            '    ' + edit.inTag +
                            '>' + html + '&lt;/select>' + edit.outTag);
                    setTimeout(function () {
                        el.find('select')
                            .on('change', function (event) {
                                delete obj.last.move;
                            })
                            .on('blur', function (event) {
                                if ($(this).data('keep-open') == true) return;
                                obj.editChange.call(obj, this, index, column, event);
                            });
                    }, 10);
                    break;

                case 'div':
                    var $tmp = tr.find('[col=' + column + '] > div');
                    var font = 'font-family: ' + $tmp.css('font-family') + '; font-size: ' + $tmp.css('font-size') + ';';
                    el.addClass('w2ui-editable')
                        .html('&lt;div id="grid_' + obj.name + '_edit_' + recid + '_' + column + '" class="w2ui-input"' +
                            '    contenteditable style="' + font + addStyle + edit.style + '" autocorrect="off" autocomplete="off" spellcheck="false" ' +
                            '    field="' + col.field + '" recid="' + recid + '" column="' + column + '" ' + edit.inTag +
                            '>&lt;/div>' + edit.outTag);
                    if (value == null) el.find('div.w2ui-input').text(typeof val != 'object' ? val : '');
                    // add blur listener
                    var input = el.find('div.w2ui-input').get(0);
                    setTimeout(function () {
                        var tmp = input;
                        $(tmp).on('blur', function (event) {
                            if ($(this).data('keep-open') == true) return;
                            obj.editChange.call(obj, tmp, index, column, event);
                        });
                    }, 10);
                    if (value != null) $(input).text(typeof val != 'object' ? val : '');
                    break;

                default:
                    var $tmp = tr.find('[col=' + column + '] > div');
                    var font = 'font-family: ' + $tmp.css('font-family') + '; font-size: ' + $tmp.css('font-size');
                    el.addClass('w2ui-editable')
                        .html('&lt;input id="grid_' + obj.name + '_edit_' + recid + '_' + column + '" autocorrect="off" autocomplete="off" spellcheck="false" type="text" ' +
                            '    style="' + font + '; width: 100%; height: 100%; padding: 3px; border-color: transparent; outline: none; border-radius: 0; ' +
                            '       pointer-events: auto; ' + addStyle + edit.style + '" ' +
                            '    field="' + col.field + '" recid="' + recid + '" column="' + column + '" class="w2ui-input"' + edit.inTag +
                            '/>' + edit.outTag);
                    // issue #499
                    if (edit.type == 'number') {
                        val = w2utils.formatNumber(val);
                    }
                    if (edit.type == 'date') {
                        val = w2utils.formatDate(w2utils.isDate(val, edit.format, true), edit.format);
                    }
                    if (value == null) el.find('input').val(typeof val != 'object' ? val : '');
                    // init w2field
                    var input = el.find('input').get(0);
                    $(input).w2field(edit.type, $.extend(edit, {selected: val}));
                    // add blur listener
                    setTimeout(function () {
                        var tmp = input;
                        if (edit.type == 'list') {
                            tmp = $($(input).data('w2field').helpers.focus).find('input');
                            if (typeof val != 'object' &amp;&amp; val != '') tmp.val(val).css({opacity: 1}).prev().css({opacity: 1});
                            el.find('input').on('change', function (event) {
                                obj.editChange.call(obj, input, index, column, event);
                            });
                        }
                        $(tmp).on('blur', function (event) {
                            if ($(this).data('keep-open') == true) return;
                            obj.editChange.call(obj, input, index, column, event);
                        });
                    }, 10);
                    if (value != null) $(input).val(typeof val != 'object' ? val : '');
            }

            setTimeout(function () {
                el.find('input, select, div.w2ui-input')
                    .data('old_value', old_value)
                    .on('mousedown', function (event) {
                        event.stopPropagation();
                    })
                    .on('click', function (event) {
                        if (edit.type == 'div') {
                            expand.call(el.find('div.w2ui-input')[0], null);
                        } else {
                            expand.call(el.find('input, select')[0], null);
                        }
                    })
                    .on('paste', function (event) {
                        // clean paste to be plain text
                        var e = event.originalEvent;
                        event.preventDefault();
                        var text = e.clipboardData.getData("text/plain");
                        document.execCommand("insertHTML", false, text);
                    })
                    .on('keydown', function (event) {
                        var el = this;
                        var val = (el.tagName.toUpperCase() == 'DIV' ? $(el).text() : $(el).val());
                        switch (event.keyCode) {
                            case 8: // backspace;
                                if (edit.type == 'list' &amp;&amp; !$(input).data('w2field')) { // cancel backspace when deleting element
                                    event.preventDefault();
                                }
                                break;
                            case 9:
                            case 13:
                                event.preventDefault();
                                break;
                            case 37:
                                if (w2utils.getCursorPosition(el) === 0) {
                                    event.preventDefault();
                                }
                                break;
                            case 39:
                                if (w2utils.getCursorPosition(el) == val.length) {
                                    w2utils.setCursorPosition(el, val.length);
                                    event.preventDefault();
                                }
                                break;
                        }
                        // need timeout so, this handler is executed last
                        setTimeout(function () {
                            switch (event.keyCode) {
                                case 9:  // tab
                                    var next_rec = recid;
                                    var next_col = event.shiftKey ? obj.prevCell(index, column, true) : obj.nextCell(index, column, true);
                                    // next or prev row
                                    if (next_col == null) {
                                        var tmp = event.shiftKey ? obj.prevRow(index, column) : obj.nextRow(index, column);
                                        if (tmp != null &amp;&amp; tmp != index) {
                                            next_rec = obj.records[tmp].recid;
                                            // find first editable row
                                            for (var c = 0; c &lt; obj.columns.length; c++) {
                                                var edit = obj.getCellEditable(index, c);
                                                if (edit != null &amp;&amp; ['checkbox', 'check'].indexOf(edit.type) == -1) {
                                                    next_col = parseInt(c);
                                                    if (!event.shiftKey) break;
                                                }
                                            }
                                        }

                                    }
                                    if (next_rec === false) next_rec = recid;
                                    if (next_col == null) next_col = column;
                                    // init new or same record
                                    el.blur();
                                    setTimeout(function () {
                                        if (obj.selectType != 'row') {
                                            obj.selectNone();
                                            obj.select({recid: next_rec, column: next_col});
                                        } else {
                                            obj.editField(next_rec, next_col, null, event);
                                        }
                                    }, 1);
                                    if (event.preventDefault) event.preventDefault();
                                    break;

                                case 13: // enter
                                    el.blur();
                                    var next = event.shiftKey ? obj.prevRow(index, column) : obj.nextRow(index, column);
                                    if (next != null &amp;&amp; next != index) {
                                        setTimeout(function () {
                                            if (obj.selectType != 'row') {
                                                obj.selectNone();
                                                obj.select({recid: obj.records[next].recid, column: column});
                                            } else {
                                                obj.editField(obj.records[next].recid, column, null, event);
                                            }
                                        }, 1);
                                    }
                                    if (el.tagName.toUpperCase() == 'DIV') {
                                        event.preventDefault();
                                    }
                                    break;

                                case 27: // escape
                                    var old = obj.parseField(rec, col.field);
                                    if (rec.w2ui &amp;&amp; rec.w2ui.changes &amp;&amp; rec.w2ui.changes[col.field] != null) old = rec.w2ui.changes[col.field];
                                    if ($(el).data('old_value') != null) old = $(el).data('old_value');
                                    if (el.tagName.toUpperCase() == 'DIV') {
                                        $(el).text(old != null ? old : '');
                                    } else {
                                        el.value = old != null ? old : '';
                                    }
                                    el.blur();
                                    setTimeout(function () {
                                        obj.select({recid: recid, column: column});
                                    }, 1);
                                    break;
                            }
                            // if input too small - expand
                            expand.call(el, event);
                        }, 1);
                    })
                    .on('keyup', function (event) {
                        expand.call(this, event);
                    });
                // focus and select
                setTimeout(function () {
                    var tmp = el.find('.w2ui-input');
                    var len = $(tmp).val().length;
                    if (edit.type == 'div') len = $(tmp).text().length;
                    if (tmp.length > 0) {
                        tmp.focus();
                        clearTimeout(obj.last.kbd_timer); // keep focus
                        if (tmp[0].tagName != 'SELECT') w2utils.setCursorPosition(tmp[0], len);
                        tmp[0].resize = expand;
                        expand.call(tmp[0], null);
                    }
                }, 50);
                // event after
                obj.trigger($.extend(edata, {phase: 'after', input: el.find('input, select, div.w2ui-input')}));
            }, 5); // needs to be 5-10
            return;

            function expand(event) {
                try {
                    var val = (this.tagName.toUpperCase() == 'DIV' ? $(this).text() : this.value);
                    var $sel = $('#grid_' + obj.name + '_editable');
                    var style = 'font-family: ' + $(this).css('font-family') + '; font-size: ' + $(this).css('font-size') + '; white-space: pre;';
                    var width = w2utils.getStrWidth(val, style);
                    if (width + 20 > $sel.width()) {
                        $sel.width(width + 20);
                    }
                } catch (e) {
                }
            }
        },

        editChange: function (el, index, column, event) {
            var obj = this;
            // keep focus
            setTimeout(function () {
                var $input = $(obj.box).find('#grid_' + obj.name + '_focus');
                if (!$input.is(':focus')) $input.focus();
            }, 10);
            // all other fields
            var summary = index &lt; 0;
            index = index &lt; 0 ? -index - 1 : index;
            var records = summary ? this.summary : this.records;
            var rec = records[index];
            var col = this.columns[column];
            var tr = $('#grid_' + this.name + (col.frozen === true ? '_frec_' : '_rec_') + w2utils.escapeId(rec.recid));
            var new_val = (el.tagName &amp;&amp; el.tagName.toUpperCase() == 'DIV' ? $(el).text() : el.value);
            var old_val = this.parseField(rec, col.field);
            var tmp = $(el).data('w2field');
            if (tmp) {
                if (tmp.type == 'list') new_val = $(el).data('selected');
                if ($.isEmptyObject(new_val) || new_val == null) new_val = '';
                if (!$.isPlainObject(new_val)) new_val = tmp.clean(new_val);
            }
            if (el.type == 'checkbox') {
                if (rec.w2ui &amp;&amp; rec.w2ui.editable === false) el.checked = !el.checked;
                new_val = el.checked;
            }
            // change/restore event
            var edata = {
                phase: 'before',
                type: 'change',
                target: this.name,
                input_id: el.id,
                recid: rec.recid,
                index: index,
                column: column,
                originalEvent: (event.originalEvent ? event.originalEvent : event),
                value_new: new_val,
                value_previous: (rec.w2ui &amp;&amp; rec.w2ui.changes &amp;&amp; rec.w2ui.changes.hasOwnProperty(col.field) ? rec.w2ui.changes[col.field] : old_val),
                value_original: old_val
            };
            if ($(event.target).data('old_value') != null) edata.value_previous = $(event.target).data('old_value');
            // if (old_val == null) old_val = ''; -- do not uncomment, error otherwise
            while (true) {
                new_val = edata.value_new;
                if ((typeof new_val != 'object' &amp;&amp; String(old_val) != String(new_val)) ||
                    (typeof new_val == 'object' &amp;&amp; new_val.id != old_val &amp;&amp; (typeof old_val != 'object' || old_val == null || new_val.id != old_val.id))) {
                    // change event
                    edata = this.trigger($.extend(edata, {type: 'change', phase: 'before'}));
                    if (edata.isCancelled !== true) {
                        if (new_val !== edata.value_new) {
                            // re-evaluate the type of change to be made
                            continue;
                        }
                        // default action
                        rec.w2ui = rec.w2ui || {};
                        rec.w2ui.changes = rec.w2ui.changes || {};
                        rec.w2ui.changes[col.field] = edata.value_new;
                        // event after
                        this.trigger($.extend(edata, {phase: 'after'}));
                    }
                } else {
                    // restore event
                    edata = this.trigger($.extend(edata, {type: 'restore', phase: 'before'}));
                    if (edata.isCancelled !== true) {
                        if (new_val !== edata.value_new) {
                            // re-evaluate the type of change to be made
                            continue;
                        }
                        // default action
                        if (rec.w2ui &amp;&amp; rec.w2ui.changes) delete rec.w2ui.changes[col.field];
                        if (rec.w2ui &amp;&amp; $.isEmptyObject(rec.w2ui.changes)) delete rec.w2ui.changes;
                        // event after
                        this.trigger($.extend(edata, {phase: 'after'}));
                    }
                }
                break;
            }
            // refresh cell
            var cell = $(tr).find('[col=' + column + ']');
            if (!summary) {
                if (rec.w2ui &amp;&amp; rec.w2ui.changes &amp;&amp; rec.w2ui.changes[col.field] != null) {
                    cell.addClass('w2ui-changed');
                } else {
                    cell.removeClass('w2ui-changed');
                }
                // update cell data
                cell.replaceWith(this.getCellHTML(index, column, summary));
            }
            // remove
            $(this.box).find('div.w2ui-edit-box').remove();
            // enable/disable toolbar search button
            if (this.show.toolbarSave) {
                if (this.getChanges().length > 0) this.toolbar.enable('w2ui-save'); else this.toolbar.disable('w2ui-save');
            }
        },

        "delete": function (force) {
            var time = (new Date()).getTime();
            var obj = this;
            // event before
            var edata = this.trigger({phase: 'before', target: this.name, type: 'delete', force: force});
            if (edata.isCancelled === true) return;
            force = edata.force;
            // hide all tooltips
            setTimeout(function () {
                $().w2tag();
            }, 20);
            // default action
            var recs = this.getSelection();
            if (recs.length === 0) return;
            if (this.msgDelete != '' &amp;&amp; !force) {
                this.message({
                    width: 350,
                    height: 170,
                    body: '&lt;div class="w2ui-centered">' + w2utils.lang(obj.msgDelete) + '&lt;/div>',
                    buttons: '&lt;button class="w2ui-btn w2ui-btn-red" onclick="w2ui[\'' + this.name + '\'].delete(true)">' + w2utils.lang('Yes') + '&lt;/button>' +
                    '&lt;button class="w2ui-btn" onclick="w2ui[\'' + this.name + '\'].message()">' + w2utils.lang('No') + '&lt;/button>',
                    onOpen: function (event) {
                        var inputs = $(this.box).find('input, textarea, select, button');
                        inputs.off('.message')
                            .on('blur.message', function (evt) {
                                // last input
                                if (inputs.index(evt.target) + 1 === inputs.length) {
                                    inputs.get(0).focus();
                                    evt.preventDefault();
                                }
                            })
                            .on('keydown.message', function (evt) {
                                if (evt.keyCode == 27) obj.message(); // esc
                            });
                        setTimeout(function () {
                            $(this.box).find('.w2ui-btn:last-child').focus();
                            clearTimeout(obj.last.kbd_timer);
                        }, 25);
                    }
                });
                return;
            }
            this.message(); // hides confirmation message
            // call delete script
            var url = (typeof this.url != 'object' ? this.url : this.url.remove);
            if (url) {
                this.request('delete');
            } else {
                if (typeof recs[0] != 'object') {
                    this.selectNone();
                    this.remove.apply(this, recs);
                } else {
                    // clear cells
                    for (var r = 0; r &lt; recs.length; r++) {
                        var fld = this.columns[recs[r].column].field;
                        var ind = this.get(recs[r].recid, true);
                        var rec = this.records[ind];
                        if (ind != null &amp;&amp; fld != 'recid') {
                            this.records[ind][fld] = '';
                            if (rec.w2ui &amp;&amp; rec.w2ui.changes) delete rec.w2ui.changes[fld];
                            // -- style should not be deleted
                            // if (rec.style != null &amp;&amp; $.isPlainObject(rec.style) &amp;&amp; rec.style[recs[r].column]) {
                            //     delete rec.style[recs[r].column];
                            // }
                        }
                    }
                    this.update();
                }
            }
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        click: function (recid, event) {
            var time = (new Date()).getTime();
            var column = null;
            var obj = this;
            if (this.last.cancelClick == true || (event &amp;&amp; event.altKey)) return;
            if (typeof recid == 'object') {
                column = recid.column;
                recid = recid.recid;
            }
            if (event == null) event = {};
            // check for double click
            if (time - parseInt(this.last.click_time) &lt; 350 &amp;&amp; this.last.click_recid == recid &amp;&amp; event.type == 'click') {
                this.dblClick(recid, event);
                return;
            }
            // hide bubble
            if (this.last.bubbleEl) {
                $(this.last.bubbleEl).w2tag();
                this.last.bubbleEl = null;
            }
            this.last.click_time = time;
            var last_recid = this.last.click_recid;
            this.last.click_recid = recid;
            // column user clicked on
            if (column == null &amp;&amp; event.target) {
                var tmp = event.target;
                if (tmp.tagName.toUpperCase() != 'TD') tmp = $(tmp).parents('td')[0];
                if ($(tmp).attr('col') != null) column = parseInt($(tmp).attr('col'));
            }
            // event before
            var edata = this.trigger({
                phase: 'before',
                target: this.name,
                type: 'click',
                recid: recid,
                column: column,
                originalEvent: event
            });
            if (edata.isCancelled === true) return;
            // default action
            var obj = this;
            var sel = this.getSelection();
            $('#grid_' + this.name + '_check_all').prop("checked", false);
            var ind = this.get(recid, true);
            var record = this.records[ind];
            var selectColumns = [];
            obj.last.sel_ind = ind;
            obj.last.sel_col = column;
            obj.last.sel_recid = recid;
            obj.last.sel_type = 'click';
            // multi select with shif key
            if (event.shiftKey &amp;&amp; sel.length > 0 &amp;&amp; obj.multiSelect) {
                if (sel[0].recid) {
                    var start = this.get(sel[0].recid, true);
                    var end = this.get(recid, true);
                    if (column > sel[0].column) {
                        var t1 = sel[0].column;
                        var t2 = column;
                    } else {
                        var t1 = column;
                        var t2 = sel[0].column;
                    }
                    for (var c = t1; c &lt;= t2; c++) selectColumns.push(c);
                } else {
                    var start = this.get(last_recid, true);
                    var end = this.get(recid, true);
                }
                var sel_add = [];
                if (start > end) {
                    var tmp = start;
                    start = end;
                    end = tmp;
                }
                var url = (typeof this.url != 'object' ? this.url : this.url.get);
                for (var i = start; i &lt;= end; i++) {
                    if (this.searchData.length > 0 &amp;&amp; !url &amp;&amp; $.inArray(i, this.last.searchIds) == -1) continue;
                    if (this.selectType == 'row') {
                        sel_add.push(this.records[i].recid);
                    } else {
                        for (var sc = 0; sc &lt; selectColumns.length; sc++) {
                            sel_add.push({recid: this.records[i].recid, column: selectColumns[sc]});
                        }
                    }
                    //sel.push(this.records[i].recid);
                }
                this.select.apply(this, sel_add);
            } else {
                var last = this.last.selection;
                var flag = (last.indexes.indexOf(ind) != -1 ? true : false);
                var fselect = false;
                // if clicked on the checkbox
                if ($(event.target).parents('td').hasClass('w2ui-col-select')) fselect = true;
                // clear other if necessary
                if (((!event.ctrlKey &amp;&amp; !event.shiftKey &amp;&amp; !event.metaKey &amp;&amp; !fselect) || !this.multiSelect) &amp;&amp; !this.showSelectColumn) {
                    if (this.selectType != 'row' &amp;&amp; $.inArray(column, last.columns[ind]) == -1) flag = false;
                    if (sel.length > 300) this.selectNone(); else this.unselect.apply(this, sel);
                    if (flag === true &amp;&amp; sel.length == 1) {
                        this.unselect({recid: recid, column: column});
                    } else {
                        this.select({recid: recid, column: column});
                    }
                } else {
                    if (this.selectType != 'row' &amp;&amp; $.inArray(column, last.columns[ind]) == -1) flag = false;
                    if (flag === true) {
                        this.unselect({recid: recid, column: column});
                    } else {
                        this.select({recid: recid, column: column});
                    }
                }
            }
            this.status();
            obj.initResize();
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        columnClick: function (field, event) {
            // event before
            var edata = this.trigger({
                phase: 'before',
                type: 'columnClick',
                target: this.name,
                field: field,
                originalEvent: event
            });
            if (edata.isCancelled === true) return;
            // default behaviour
            if (this.selectType == 'row') {
                var column = this.getColumn(field);
                if (column &amp;&amp; column.sortable) this.sort(field, null, (event &amp;&amp; (event.ctrlKey || event.metaKey) ? true : false));
                if (edata.field == 'line-number') {
                    if (this.getSelection().length >= this.records.length) {
                        this.selectNone();
                    } else {
                        this.selectAll();
                    }
                }
            } else {
                // select entire column
                if (edata.field == 'line-number') {
                    if (this.getSelection().length >= this.records.length) {
                        this.selectNone();
                    } else {
                        this.selectAll();
                    }
                } else {
                    if (!event.shiftKey &amp;&amp; !event.metaKey &amp;&amp; !event.ctrlKey) {
                        this.selectNone();
                    }
                    var tmp = this.getSelection();
                    var column = this.getColumn(edata.field, true);
                    var sel = [];
                    var cols = [];
                    // check if there was a selection before
                    if (tmp.length != 0 &amp;&amp; event.shiftKey) {
                        var start = column;
                        var end = tmp[0].column;
                        if (start > end) {
                            start = tmp[0].column;
                            end = column;
                        }
                        for (var i = start; i &lt;= end; i++) cols.push(i);
                    } else {
                        cols.push(column);
                    }
                    var edata = this.trigger({phase: 'before', type: 'columnSelect', target: this.name, columns: cols});
                    if (edata.isCancelled !== true) {
                        for (var i = 0; i &lt; this.records.length; i++) {
                            sel.push({recid: this.records[i].recid, column: cols});
                        }
                        this.select.apply(this, sel);
                    }
                    this.trigger($.extend(edata, {phase: 'after'}));
                }
            }
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        columnDblClick: function (field, event) {
            // event before
            var edata = this.trigger({
                phase: 'before',
                type: 'columnDblClick',
                target: this.name,
                field: field,
                originalEvent: event
            });
            if (edata.isCancelled === true) return;
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        focus: function (event) {
            var obj = this;
            // event before
            var edata = this.trigger({phase: 'before', type: 'focus', target: this.name, originalEvent: event});
            if (edata.isCancelled === true) return false;
            // default behaviour
            this.hasFocus = true;
            $(this.box).find('.w2ui-inactive').removeClass('w2ui-inactive');
            setTimeout(function () {
                var $input = $(obj.box).find('#grid_' + obj.name + '_focus');
                if (!$input.is(':focus')) $input.focus();
            }, 10);
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        blur: function (event) {
            // event before
            var edata = this.trigger({phase: 'before', type: 'blur', target: this.name, originalEvent: event});
            if (edata.isCancelled === true) return false;
            // default behaviour
            this.hasFocus = false;
            $(this.box).find('.w2ui-selected').addClass('w2ui-inactive');
            $(this.box).find('.w2ui-selection').addClass('w2ui-inactive');
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        keydown: function (event) {
            // this method is called from w2utils
            var obj = this;
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (obj.keyboard !== true) return;
            // trigger event
            var edata = obj.trigger({phase: 'before', type: 'keydown', target: obj.name, originalEvent: event});
            if (edata.isCancelled === true) return;
            // default behavior
            if ($(this.box).find('>.w2ui-message').length > 0) {
                // if there are messages
                if (event.keyCode == 27) this.message();
                return
            }
            var empty = false;
            var records = $('#grid_' + obj.name + '_records');
            var sel = obj.getSelection();
            if (sel.length === 0) empty = true;
            var recid = sel[0] || null;
            var columns = [];
            var recid2 = sel[sel.length - 1];
            if (typeof recid == 'object' &amp;&amp; recid != null) {
                recid = sel[0].recid;
                columns = [];
                var ii = 0;
                while (true) {
                    if (!sel[ii] || sel[ii].recid != recid) break;
                    columns.push(sel[ii].column);
                    ii++;
                }
                recid2 = sel[sel.length - 1].recid;
            }
            var ind = obj.get(recid, true);
            var ind2 = obj.get(recid2, true);
            var rec = obj.get(recid);
            var recEL = $('#grid_' + obj.name + '_rec_' + (ind != null ? w2utils.escapeId(obj.records[ind].recid) : 'none'));
            var cancel = false;
            var key = event.keyCode;
            var shiftKey = event.shiftKey;

            switch (key) {
                case 8:  // backspace
                case 46: // delete
                    if (this.show.toolbarDelete || this.onDelete) obj["delete"]();
                    cancel = true;
                    event.stopPropagation();
                    break;

                case 27: // escape
                    obj.selectNone();
                    cancel = true;
                    break;

                case 65: // cmd + A
                    if (!event.metaKey &amp;&amp; !event.ctrlKey) break;
                    obj.selectAll();
                    cancel = true;
                    break;

                case 13: // enter
                    // if expandable columns - expand it
                    if (this.selectType == 'row' &amp;&amp; obj.show.expandColumn === true) {
                        if (recEL.length &lt;= 0) break;
                        obj.toggle(recid, event);
                        cancel = true;
                    } else { // or enter edit
                        for (var c = 0; c &lt; this.columns.length; c++) {
                            var edit = this.getCellEditable(ind, c);
                            if (edit) {
                                columns.push(parseInt(c));
                                break;
                            }
                        }
                        // edit last column that was edited
                        if (this.selectType == 'row' &amp;&amp; this.last.edit_col) columns = [this.last.edit_col];
                        if (columns.length > 0) {
                            obj.editField(recid, columns[0], null, event);
                            cancel = true;
                        }
                    }
                    break;

                case 37: // left
                    if (empty) { // no selection
                        selectTopRecord();
                        break;
                    }
                    if (this.selectType == 'row') {
                        if (recEL.length &lt;= 0) break;
                        var tmp = this.records[ind].w2ui || {};
                        if (tmp &amp;&amp; tmp.parent_recid != null &amp;&amp; (!Array.isArray(tmp.children) || tmp.children.length === 0 || !tmp.expanded)) {
                            obj.unselect(recid);
                            obj.collapse(tmp.parent_recid, event);
                            obj.select(tmp.parent_recid);
                        } else {
                            obj.collapse(recid, event);
                        }
                    } else {
                        var prev = obj.prevCell(ind, columns[0]);
                        if (!shiftKey &amp;&amp; prev == null) {
                            this.selectNone();
                            prev = 0;
                        }
                        if (prev != null) {
                            if (shiftKey &amp;&amp; obj.multiSelect) {
                                if (tmpUnselect()) return;
                                var tmp = [];
                                var newSel = [];
                                var unSel = [];
                                if (columns.indexOf(this.last.sel_col) === 0 &amp;&amp; columns.length > 1) {
                                    for (var i = 0; i &lt; sel.length; i++) {
                                        if (tmp.indexOf(sel[i].recid) == -1) tmp.push(sel[i].recid);
                                        unSel.push({recid: sel[i].recid, column: columns[columns.length - 1]});
                                    }
                                    obj.unselect.apply(obj, unSel);
                                    obj.scrollIntoView(ind, columns[columns.length - 1], true);
                                } else {
                                    for (var i = 0; i &lt; sel.length; i++) {
                                        if (tmp.indexOf(sel[i].recid) == -1) tmp.push(sel[i].recid);
                                        newSel.push({recid: sel[i].recid, column: prev});
                                    }
                                    obj.select.apply(obj, newSel);
                                    obj.scrollIntoView(ind, prev, true);
                                }
                            } else {
                                event.metaKey = false;
                                obj.click({recid: recid, column: prev}, event);
                                obj.scrollIntoView(ind, prev, true);
                            }
                        } else {
                            // if selected more then one, then select first
                            if (!shiftKey) {
                                if (sel.length > 1) {
                                    obj.selectNone();
                                } else {
                                    for (var s = 1; s &lt; sel.length; s++) obj.unselect(sel[s]);
                                }
                            }
                        }
                    }
                    cancel = true;
                    break;

                case 39: // right
                    if (empty) {
                        selectTopRecord();
                        break;
                    }
                    if (this.selectType == 'row') {
                        if (recEL.length &lt;= 0) break;
                        obj.expand(recid, event);
                    } else {
                        var next = obj.nextCell(ind, columns[columns.length - 1]); // columns is an array of selected columns
                        if (!shiftKey &amp;&amp; next == null) {
                            this.selectNone();
                            next = this.columns.length - 1;
                        }
                        if (next != null) {
                            if (shiftKey &amp;&amp; key == 39 &amp;&amp; obj.multiSelect) {
                                if (tmpUnselect()) return;
                                var tmp = [];
                                var newSel = [];
                                var unSel = [];
                                if (columns.indexOf(this.last.sel_col) == columns.length - 1 &amp;&amp; columns.length > 1) {
                                    for (var i = 0; i &lt; sel.length; i++) {
                                        if (tmp.indexOf(sel[i].recid) == -1) tmp.push(sel[i].recid);
                                        unSel.push({recid: sel[i].recid, column: columns[0]});
                                    }
                                    obj.unselect.apply(obj, unSel);
                                    obj.scrollIntoView(ind, columns[0], true);
                                } else {
                                    for (var i = 0; i &lt; sel.length; i++) {
                                        if (tmp.indexOf(sel[i].recid) == -1) tmp.push(sel[i].recid);
                                        newSel.push({recid: sel[i].recid, column: next});
                                    }
                                    obj.select.apply(obj, newSel);
                                    obj.scrollIntoView(ind, next, true);
                                }
                            } else {
                                event.metaKey = false;
                                obj.click({recid: recid, column: next}, event);
                                obj.scrollIntoView(ind, next, true);
                            }
                        } else {
                            // if selected more then one, then select first
                            if (!shiftKey) {
                                if (sel.length > 1) {
                                    obj.selectNone();
                                } else {
                                    for (var s = 0; s &lt; sel.length - 1; s++) obj.unselect(sel[s]);
                                }
                            }
                        }
                    }
                    cancel = true;
                    break;

                case 38: // up
                    if (empty) selectTopRecord();
                    if (recEL.length &lt;= 0) break;
                    // move to the previous record
                    var prev = obj.prevRow(ind, columns[0]);
                    if (!shiftKey &amp;&amp; prev == null) {
                        if (this.searchData.length != 0 &amp;&amp; !url) {
                            prev = this.last.searchIds[0];
                        } else {
                            prev = 0;
                        }
                    }
                    if (prev != null) {
                        if (shiftKey &amp;&amp; obj.multiSelect) { // expand selection
                            if (tmpUnselect()) return;
                            if (obj.selectType == 'row') {
                                if (obj.last.sel_ind > prev &amp;&amp; obj.last.sel_ind != ind2) {
                                    obj.unselect(obj.records[ind2].recid);
                                } else {
                                    obj.select(obj.records[prev].recid);
                                }
                            } else {
                                if (obj.last.sel_ind > prev &amp;&amp; obj.last.sel_ind != ind2) {
                                    prev = ind2;
                                    var tmp = [];
                                    for (var c = 0; c &lt; columns.length; c++) tmp.push({
                                        recid: obj.records[prev].recid,
                                        column: columns[c]
                                    });
                                    obj.unselect.apply(obj, tmp);
                                } else {
                                    var tmp = [];
                                    for (var c = 0; c &lt; columns.length; c++) tmp.push({
                                        recid: obj.records[prev].recid,
                                        column: columns[c]
                                    });
                                    obj.select.apply(obj, tmp);
                                }
                            }
                        } else { // move selected record
                            if (sel.length > 300) this.selectNone(); else this.unselect.apply(this, sel);
                            obj.click({recid: obj.records[prev].recid, column: columns[0]}, event);
                        }
                        obj.scrollIntoView(prev);
                        if (event.preventDefault) event.preventDefault();
                    } else {
                        // if selected more then one, then select first
                        if (!shiftKey) {
                            if (sel.length > 1) {
                                obj.selectNone();
                            } else {
                                for (var s = 1; s &lt; sel.length; s++) obj.unselect(sel[s]);
                            }
                        }
                    }
                    break;

                case 40: // down
                    if (empty) selectTopRecord();
                    if (recEL.length &lt;= 0) break;
                    // move to the next record
                    var next = obj.nextRow(ind2, columns[0]);
                    if (!shiftKey &amp;&amp; next == null) {
                        if (this.searchData.length != 0 &amp;&amp; !url) {
                            next = this.last.searchIds[this.last.searchIds.length - 1];
                        } else {
                            next = this.records.length - 1;
                        }
                    }
                    if (next != null) {
                        if (shiftKey &amp;&amp; obj.multiSelect) { // expand selection
                            if (tmpUnselect()) return;
                            if (obj.selectType == 'row') {
                                if (this.last.sel_ind &lt; next &amp;&amp; this.last.sel_ind != ind) {
                                    obj.unselect(obj.records[ind].recid);
                                } else {
                                    obj.select(obj.records[next].recid);
                                }
                            } else {
                                if (this.last.sel_ind &lt; next &amp;&amp; this.last.sel_ind != ind) {
                                    next = ind;
                                    var tmp = [];
                                    for (var c = 0; c &lt; columns.length; c++) tmp.push({
                                        recid: obj.records[next].recid,
                                        column: columns[c]
                                    });
                                    obj.unselect.apply(obj, tmp);
                                } else {
                                    var tmp = [];
                                    for (var c = 0; c &lt; columns.length; c++) tmp.push({
                                        recid: obj.records[next].recid,
                                        column: columns[c]
                                    });
                                    obj.select.apply(obj, tmp);
                                }
                            }
                        } else { // move selected record
                            if (sel.length > 300) this.selectNone(); else this.unselect.apply(this, sel);
                            obj.click({recid: obj.records[next].recid, column: columns[0]}, event);
                        }
                        obj.scrollIntoView(next);
                        cancel = true;
                    } else {
                        // if selected more then one, then select first
                        if (!shiftKey) {
                            if (sel.length > 1) {
                                obj.selectNone();
                            } else {
                                for (var s = 0; s &lt; sel.length - 1; s++) obj.unselect(sel[s]);
                            }
                        }
                    }
                    break;

                // copy &amp; paste

                case 17: // ctrl key
                case 91: // cmd key
                    // SLOW: 10k records take 7.0
                    if (empty) break;
                    // in Safari need to copy to buffer on cmd or ctrl key (otherwise does not work)
                    if (obj.last.isSafari) {
                        obj.last.copy_event = obj.copy(false, event);
                        $('#grid_' + obj.name + '_focus').val(obj.last.copy_event.text).select();
                    }
                    break;

                case 67: // - c
                    // this fill trigger event.onComplete
                    if (event.metaKey || event.ctrlKey) {
                        if (obj.last.isSafari) {
                            obj.copy(obj.last.copy_event, event);
                        } else {
                            obj.last.copy_event = obj.copy(false, event);
                            $('#grid_' + obj.name + '_focus').val(obj.last.copy_event.text).select();
                            obj.copy(obj.last.copy_event, event);
                        }
                    }
                    break;

                case 88: // x - cut
                    if (empty) break;
                    if (event.ctrlKey || event.metaKey) {
                        if (obj.last.isSafari) {
                            obj.copy(obj.last.copy_event, event);
                        } else {
                            obj.last.copy_event = obj.copy(false, event);
                            $('#grid_' + obj.name + '_focus').val(obj.last.copy_event.text).select();
                            obj.copy(obj.last.copy_event, event);
                        }
                        // clear
                        setTimeout(function () {
                            obj["delete"](true);
                        }, 100);
                    }
                    break;
            }
            var tmp = [32, 187, 189, 192, 219, 220, 221, 186, 222, 188, 190, 191]; // other typable chars
            for (var i = 48; i &lt;= 111; i++) tmp.push(i); // 0-9,a-z,A-Z,numpad
            if (tmp.indexOf(key) != -1 &amp;&amp; !event.ctrlKey &amp;&amp; !event.metaKey &amp;&amp; !cancel) {
                if (columns.length === 0) columns.push(0);
                cancel = false;
                // move typed key into edit
                setTimeout(function () {
                    var focus = $('#grid_' + obj.name + '_focus');
                    var key = focus.val();
                    focus.val('');
                    obj.editField(recid, columns[0], key, event);
                }, 1);
            }
            if (cancel) { // cancel default behaviour
                if (event.preventDefault) event.preventDefault();
            }
            // event after
            obj.trigger($.extend(edata, {phase: 'after'}));

            function selectTopRecord() {
                var ind = Math.floor(records[0].scrollTop / obj.recordHeight) + 1;
                if (!obj.records[ind] || ind &lt; 2) ind = 0;
                obj.select({recid: obj.records[ind].recid, column: 0});
            }

            function tmpUnselect() {
                if (obj.last.sel_type != 'click') return false;
                if (obj.selectType != 'row') {
                    obj.last.sel_type = 'key';
                    if (sel.length > 1) {
                        for (var s = 0; s &lt; sel.length; s++) {
                            if (sel[s].recid == obj.last.sel_recid &amp;&amp; sel[s].column == obj.last.sel_col) {
                                sel.splice(s, 1);
                                break;
                            }
                        }
                        obj.unselect.apply(obj, sel);
                        return true;
                    }
                    return false;
                } else {
                    obj.last.sel_type = 'key';
                    if (sel.length > 1) {
                        sel.splice(sel.indexOf(obj.records[obj.last.sel_ind].recid), 1);
                        obj.unselect.apply(obj, sel);
                        return true;
                    }
                    return false;
                }
            }
        },

        scrollIntoView: function (ind, column, instant) {
            var buffered = this.records.length;
            if (this.searchData.length != 0 &amp;&amp; !this.url) buffered = this.last.searchIds.length;
            if (buffered === 0) return;
            if (ind == null) {
                var sel = this.getSelection();
                if (sel.length === 0) return;
                if ($.isPlainObject(sel[0])) {
                    ind = sel[0].index;
                    column = sel[0].column;
                } else {
                    ind = this.get(sel[0], true);
                }
            }
            var records = $('#grid_' + this.name + '_records');
            // if all records in view
            var len = this.last.searchIds.length;
            if (len > 0) ind = this.last.searchIds.indexOf(ind); // if search is applied

            // vertical
            if (records.height() &lt; this.recordHeight * (len > 0 ? len : buffered) &amp;&amp; records.length > 0) {
                // scroll to correct one
                var t1 = Math.floor(records[0].scrollTop / this.recordHeight);
                var t2 = t1 + Math.floor(records.height() / this.recordHeight);
                if (ind == t1) {
                    if (instant === true) {
                        records.prop({'scrollTop': records.scrollTop() - records.height() / 1.3});
                    } else {
                        records.stop();
                        records.animate({'scrollTop': records.scrollTop() - records.height() / 1.3}, 250, 'linear');
                    }
                }
                if (ind == t2) {
                    if (instant === true) {
                        records.prop({'scrollTop': records.scrollTop() + records.height() / 1.3});
                    } else {
                        records.stop();
                        records.animate({'scrollTop': records.scrollTop() + records.height() / 1.3}, 250, 'linear');
                    }
                }
                if (ind &lt; t1 || ind > t2) {
                    if (instant === true) {
                        records.prop({'scrollTop': (ind - 1) * this.recordHeight});
                    } else {
                        records.stop();
                        records.animate({'scrollTop': (ind - 1) * this.recordHeight}, 250, 'linear');
                    }
                }
            }

            // horizontal
            if (column != null) {
                var x1 = 0;
                var x2 = 0;
                var sb = w2utils.scrollBarSize();
                for (var i = 0; i &lt;= column; i++) {
                    var col = this.columns[i];
                    if (col.frozen || col.hidden) continue;
                    x1 = x2;
                    x2 += parseInt(col.sizeCalculated);
                }
                if (records.width() &lt; x2 - records.scrollLeft()) { // right
                    if (instant === true) {
                        records.prop({'scrollLeft': x1 - sb});
                    } else {
                        records.animate({'scrollLeft': x1 - sb}, 250, 'linear');
                    }
                } else if (x1 &lt; records.scrollLeft()) { // left
                    if (instant === true) {
                        records.prop({'scrollLeft': x2 - records.width() + sb * 2});
                    } else {
                        records.animate({'scrollLeft': x2 - records.width() + sb * 2}, 250, 'linear');
                    }
                }
            }
        },

        dblClick: function (recid, event) {
            // find columns
            var column = null;
            if (typeof recid == 'object') {
                column = recid.column;
                recid = recid.recid;
            }
            if (event == null) event = {};
            // column user clicked on
            if (column == null &amp;&amp; event.target) {
                var tmp = event.target;
                if (tmp.tagName.toUpperCase() != 'TD') tmp = $(tmp).parents('td')[0];
                column = parseInt($(tmp).attr('col'));
            }
            var index = this.get(recid, true);
            var rec = this.records[index];
            // event before
            var edata = this.trigger({
                phase: 'before',
                target: this.name,
                type: 'dblClick',
                recid: recid,
                column: column,
                originalEvent: event
            });
            if (edata.isCancelled === true) return;
            // default action
            this.selectNone();
            var edit = this.getCellEditable(index, column);
            if (edit) {
                this.editField(recid, column, null, event);
            } else {
                this.select({recid: recid, column: column});
                if (this.show.expandColumn || (rec.w2ui &amp;&amp; Array.isArray(rec.w2ui.children))) this.toggle(recid);
            }
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        contextMenu: function (recid, column, event) {
            var obj = this;
            if (obj.last.userSelect == 'text') return;
            if (event == null) event = {offsetX: 0, offsetY: 0, target: $('#grid_' + obj.name + '_rec_' + recid)[0]};
            if (event.offsetX == null) {
                event.offsetX = event.layerX - event.target.offsetLeft;
                event.offsetY = event.layerY - event.target.offsetTop;
            }
            if (w2utils.isFloat(recid)) recid = parseFloat(recid);
            var sel = this.getSelection();
            if (this.selectType == 'row') {
                if (sel.indexOf(recid) == -1) obj.click(recid);
            } else {
                var $tmp = $(event.target);
                if ($tmp[0].tagName.toUpperCase() != 'TD') $tmp = $(event.target).parents('td');
                var selected = false;
                column = $tmp.attr('col');
                // check if any selected sel in the right row/column
                for (var i = 0; i &lt; sel.length; i++) {
                    if (sel[i].recid == recid || sel[i].column == column) selected = true;
                }
                if (!selected &amp;&amp; recid != null) obj.click({recid: recid, column: column});
                if (!selected &amp;&amp; column != null) obj.columnClick(this.columns[column].field, event);
            }
            // event before
            var edata = obj.trigger({
                phase: 'before',
                type: 'contextMenu',
                target: obj.name,
                originalEvent: event,
                recid: recid,
                column: column
            });
            if (edata.isCancelled === true) return;
            // default action
            if (obj.menu.length > 0) {
                $(obj.box).find(event.target)
                    .w2menu(obj.menu, {
                            originalEvent: event,
                            contextMenu: true,
                            onSelect: function (event) {
                                obj.menuClick(recid, parseInt(event.index), event.originalEvent);
                            }
                        }
                    );
            }
            // cancel event
            if (event.preventDefault) event.preventDefault();
            // event after
            obj.trigger($.extend(edata, {phase: 'after'}));
        },

        menuClick: function (recid, index, event) {
            var obj = this;
            // event before
            var edata = obj.trigger({
                phase: 'before', type: 'menuClick', target: obj.name, originalEvent: event,
                recid: recid, menuIndex: index, menuItem: obj.menu[index]
            });
            if (edata.isCancelled === true) return;
            // default action
            // -- empty
            // event after
            obj.trigger($.extend(edata, {phase: 'after'}));
        },

        toggle: function (recid) {
            var rec = this.get(recid);
            rec.w2ui = rec.w2ui || {};
            if (rec.w2ui.expanded === true) return this.collapse(recid); else return this.expand(recid);
        },

        expand: function (recid) {
            var obj = this;
            var ind = this.get(recid, true);
            var rec = this.records[ind];
            rec.w2ui = rec.w2ui || {};
            var id = w2utils.escapeId(recid);
            var children = rec.w2ui.children;
            if (Array.isArray(children)) {
                if (rec.w2ui.expanded === true || children.length === 0) return false; // already shown
                var edata = this.trigger({phase: 'before', type: 'expand', target: this.name, recid: recid});
                if (edata.isCancelled === true) return false;
                rec.w2ui.expanded = true;
                children.forEach(function (child) {
                    child.w2ui = child.w2ui || {};
                    child.w2ui.parent_recid = rec.recid;
                    if (child.w2ui.children == null) child.w2ui.children = [];
                });
                this.records.splice.apply(this.records, [ind + 1, 0].concat(children));
                this.total += children.length;
                var url = (typeof this.url != 'object' ? this.url : this.url.get);
                if (!url) {
                    this.localSort(true, true);
                    if (this.searchData.length > 0) {
                        this.localSearch(true);
                    }
                }
                this.refresh();
                this.trigger($.extend(edata, {phase: 'after'}));
            } else {
                if ($('#grid_' + this.name + '_rec_' + id + '_expanded_row').length > 0 || this.show.expandColumn !== true) return false;
                if (rec.w2ui.expanded == 'none') return false;
                // insert expand row
                $('#grid_' + this.name + '_rec_' + id).after(
                    '&lt;tr id="grid_' + this.name + '_rec_' + recid + '_expanded_row" class="w2ui-expanded-row">' +
                    '    &lt;td colspan="100" class="w2ui-expanded2">' +
                    '        &lt;div id="grid_' + this.name + '_rec_' + recid + '_expanded">&lt;/div>' +
                    '    &lt;/td>' +
                    '    &lt;td class="w2ui-grid-data-last">&lt;/td>' +
                    '&lt;/tr>');

                $('#grid_' + this.name + '_frec_' + id).after(
                    '&lt;tr id="grid_' + this.name + '_frec_' + recid + '_expanded_row" class="w2ui-expanded-row">' +
                    (this.show.lineNumbers ? '&lt;td class="w2ui-col-number">&lt;/td>' : '') +
                    '    &lt;td class="w2ui-grid-data w2ui-expanded1" colspan="100">' +
                    '       &lt;div id="grid_' + this.name + '_frec_' + recid + '_expanded">&lt;/div>' +
                    '   &lt;/td>' +
                    '&lt;/tr>');

                // event before
                var edata = this.trigger({
                    phase: 'before',
                    type: 'expand',
                    target: this.name,
                    recid: recid,
                    box_id: 'grid_' + this.name + '_rec_' + recid + '_expanded',
                    fbox_id: 'grid_' + this.name + '_frec_' + id + '_expanded'
                });
                if (edata.isCancelled === true) {
                    $('#grid_' + this.name + '_rec_' + id + '_expanded_row').remove();
                    $('#grid_' + this.name + '_frec_' + id + '_expanded_row').remove();
                    return false;
                }
                // expand column
                var row1 = $(this.box).find('#grid_' + this.name + '_rec_' + recid + '_expanded');
                var row2 = $(this.box).find('#grid_' + this.name + '_frec_' + recid + '_expanded');
                var innerHeight = row1.find('> div:first-child').height();
                if (row1.height() &lt; innerHeight) {
                    row1.css({height: innerHeight + 'px'});
                }
                if (row2.height() &lt; innerHeight) {
                    row2.css({height: innerHeight + 'px'});
                }
                // default action
                $('#grid_' + this.name + '_rec_' + id).attr('expanded', 'yes').addClass('w2ui-expanded');
                $('#grid_' + this.name + '_frec_' + id).attr('expanded', 'yes').addClass('w2ui-expanded');
                // $('#grid_'+ this.name +'_rec_'+ id +'_expanded_row').show();
                $('#grid_' + this.name + '_cell_' + this.get(recid, true) + '_expand div').html('-');
                rec.w2ui.expanded = true;
                // event after
                this.trigger($.extend(edata, {phase: 'after'}));
                this.resizeRecords();
            }
            return true;
        },

        collapse: function (recid) {
            var obj = this;
            var ind = this.get(recid, true);
            var rec = this.records[ind];
            rec.w2ui = rec.w2ui || {};
            var id = w2utils.escapeId(recid);
            var children = rec.w2ui.children;
            if (Array.isArray(children)) {
                if (rec.w2ui.expanded !== true) return false; // already hidden
                var edata = this.trigger({phase: 'before', type: 'collapse', target: this.name, recid: recid});
                if (edata.isCancelled === true) return false;
                clearExpanded(rec);
                var stops = [];
                for (var r = rec; r != null; r = this.get(r.w2ui.parent_recid))
                    stops.push(r.w2ui.parent_recid);
                // stops contains 'undefined' plus the ID of all nodes in the path from 'rec' to the tree root
                var start = ind + 1;
                var end = start;
                while (true) {
                    if (this.records.length &lt;= end + 1 || this.records[end + 1].w2ui == null ||
                        stops.indexOf(this.records[end + 1].w2ui.parent_recid) >= 0) {
                        break;
                    }
                    end++;
                }
                this.records.splice(start, end - start + 1);
                this.total -= end - start + 1;
                var url = (typeof this.url != 'object' ? this.url : this.url.get);
                if (!url) {
                    if (this.searchData.length > 0) {
                        this.localSearch(true);
                    }
                }
                this.refresh();
                obj.trigger($.extend(edata, {phase: 'after'}));
            } else {
                if ($('#grid_' + this.name + '_rec_' + id + '_expanded_row').length === 0 || this.show.expandColumn !== true) return false;
                // event before
                var edata = this.trigger({
                    phase: 'before',
                    type: 'collapse',
                    target: this.name,
                    recid: recid,
                    box_id: 'grid_' + this.name + '_rec_' + id + '_expanded',
                    fbox_id: 'grid_' + this.name + '_frec_' + id + '_expanded'
                });
                if (edata.isCancelled === true) return false;
                // default action
                $('#grid_' + this.name + '_rec_' + id).removeAttr('expanded').removeClass('w2ui-expanded');
                $('#grid_' + this.name + '_frec_' + id).removeAttr('expanded').removeClass('w2ui-expanded');
                $('#grid_' + this.name + '_cell_' + this.get(recid, true) + '_expand div').html('+');
                $('#grid_' + obj.name + '_rec_' + id + '_expanded').css('height', '0px');
                $('#grid_' + obj.name + '_frec_' + id + '_expanded').css('height', '0px');
                setTimeout(function () {
                    $('#grid_' + obj.name + '_rec_' + id + '_expanded_row').remove();
                    $('#grid_' + obj.name + '_frec_' + id + '_expanded_row').remove();
                    rec.w2ui.expanded = false;
                    // event after
                    obj.trigger($.extend(edata, {phase: 'after'}));
                    obj.resizeRecords();
                }, 300);
            }
            return true;

            function clearExpanded(rec) {
                rec.w2ui.expanded = false;
                for (var i = 0; i &lt; rec.w2ui.children.length; i++) {
                    var subRec = rec.w2ui.children[i];
                    if (subRec.w2ui.expanded) {
                        clearExpanded(subRec);
                    }
                }
            }
        },

        sort: function (field, direction, multiField) { // if no params - clears sort
            // event before
            var edata = this.trigger({
                phase: 'before',
                type: 'sort',
                target: this.name,
                field: field,
                direction: direction,
                multiField: multiField
            });
            if (edata.isCancelled === true) return;
            // check if needed to quit
            if (field != null) {
                // default action
                var sortIndex = this.sortData.length;
                for (var s = 0; s &lt; this.sortData.length; s++) {
                    if (this.sortData[s].field == field) {
                        sortIndex = s;
                        break;
                    }
                }
                if (direction == null) {
                    if (this.sortData[sortIndex] == null) {
                        direction = 'asc';
                    } else {
                        switch (String(this.sortData[sortIndex].direction)) {
                            case 'asc'  :
                                direction = 'desc';
                                break;
                            case 'desc' :
                                direction = 'asc';
                                break;
                            default     :
                                direction = 'asc';
                                break;
                        }
                    }
                }
                if (this.multiSort === false) {
                    this.sortData = [];
                    sortIndex = 0;
                }
                if (multiField != true) {
                    this.sortData = [];
                    sortIndex = 0;
                }
                // set new sort
                if (this.sortData[sortIndex] == null) this.sortData[sortIndex] = {};
                this.sortData[sortIndex].field = field;
                this.sortData[sortIndex].direction = direction;
            } else {
                this.sortData = [];
            }
            // if local
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (!url) {
                this.localSort(true, true);
                if (this.searchData.length > 0) this.localSearch(true);
                // reset vertical scroll
                this.last.scrollTop = 0;
                $('#grid_' + this.name + '_records').prop('scrollTop', 0);
                // event after
                this.trigger($.extend(edata, {phase: 'after'}));
                this.refresh();
            } else {
                // event after
                this.trigger($.extend(edata, {phase: 'after'}));
                this.last.xhr_offset = 0;
                this.reload();
            }
        },

        copy: function (flag, oEvent) {
            if ($.isPlainObject(flag)) {
                // event after
                this.trigger($.extend(flag, {phase: 'after'}));
                return flag.text;
            }
            // generate text to copy
            var sel = this.getSelection();
            if (sel.length === 0) return '';
            var text = '';
            if (typeof sel[0] == 'object') { // cell copy
                // find min/max column
                var minCol = sel[0].column;
                var maxCol = sel[0].column;
                var recs = [];
                for (var s = 0; s &lt; sel.length; s++) {
                    if (sel[s].column &lt; minCol) minCol = sel[s].column;
                    if (sel[s].column > maxCol) maxCol = sel[s].column;
                    if (recs.indexOf(sel[s].index) == -1) recs.push(sel[s].index);
                }
                recs.sort(function (a, b) {
                    return a - b;
                }); // sort function must be for numerical sort
                for (var r = 0; r &lt; recs.length; r++) {
                    var ind = recs[r];
                    for (var c = minCol; c &lt;= maxCol; c++) {
                        var col = this.columns[c];
                        if (col.hidden === true) continue;
                        text += w2utils.stripTags(this.getCellHTML(ind, c)) + '\t';
                    }
                    text = text.substr(0, text.length - 1); // remove last \t
                    text += '\n';
                }
            } else { // row copy
                // copy headers
                for (var c = 0; c &lt; this.columns.length; c++) {
                    var col = this.columns[c];
                    if (col.hidden === true) continue;
                    var colName = (col.caption ? col.caption : col.field);
                    if (col.caption &amp;&amp; col.caption.length &lt; 3 &amp;&amp; col.tooltip) colName = col.tooltip; // if column name is less then 3 char and there is tooltip - use it
                    text += '"' + w2utils.stripTags(colName) + '"\t';
                }
                text = text.substr(0, text.length - 1); // remove last \t
                text += '\n';
                // copy selected text
                for (var s = 0; s &lt; sel.length; s++) {
                    var ind = this.get(sel[s], true);
                    for (var c = 0; c &lt; this.columns.length; c++) {
                        var col = this.columns[c];
                        if (col.hidden === true) continue;
                        text += '"' + w2utils.stripTags(this.getCellHTML(ind, c)) + '"\t';
                    }
                    text = text.substr(0, text.length - 1); // remove last \t
                    text += '\n';
                }
            }
            text = text.substr(0, text.length - 1);

            // if called without params
            if (flag == null) {
                // before event
                var edata = this.trigger({
                    phase: 'before',
                    type: 'copy',
                    target: this.name,
                    text: text,
                    originalEvent: oEvent
                });
                if (edata.isCancelled === true) return '';
                text = edata.text;
                // event after
                this.trigger($.extend(edata, {phase: 'after'}));
                return text;
            } else if (flag === false) { // only before event
                // before event
                var edata = this.trigger({
                    phase: 'before',
                    type: 'copy',
                    target: this.name,
                    text: text,
                    originalEvent: oEvent
                });
                if (edata.isCancelled === true) return '';
                text = edata.text;
                return edata;
            }
        },

        paste: function (text) {
            var sel = this.getSelection();
            var ind = this.get(sel[0].recid, true);
            var col = sel[0].column;
            // before event
            var edata = this.trigger({
                phase: 'before',
                type: 'paste',
                target: this.name,
                text: text,
                index: ind,
                column: col
            });
            if (edata.isCancelled === true) return;
            text = edata.text;
            // default action
            if (this.selectType == 'row' || sel.length === 0) {
                console.log('ERROR: You can paste only if grid.selectType = \'cell\' and when at least one cell selected.');
                // event after
                this.trigger($.extend(edata, {phase: 'after'}));
                return;
            }
            var newSel = [];
            var text = text.split('\n');
            for (var t = 0; t &lt; text.length; t++) {
                var tmp = text[t].split('\t');
                var cnt = 0;
                var rec = this.records[ind];
                var cols = [];
                if (rec == null) continue;
                for (var dt = 0; dt &lt; tmp.length; dt++) {
                    if (!this.columns[col + cnt]) continue;
                    var field = this.columns[col + cnt].field;
                    rec.w2ui = rec.w2ui || {};
                    rec.w2ui.changes = rec.w2ui.changes || {};
                    rec.w2ui.changes[field] = tmp[dt];
                    cols.push(col + cnt);
                    cnt++;
                }
                for (var c = 0; c &lt; cols.length; c++) newSel.push({recid: rec.recid, column: cols[c]});
                ind++;
            }
            this.selectNone();
            this.select.apply(this, newSel);
            this.refresh();
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        // ==================================================
        // --- Common functions

        resize: function () {
            var obj = this;
            var time = (new Date()).getTime();
            // make sure the box is right
            if (!this.box || $(this.box).attr('name') != this.name) return;
            // determine new width and height
            $(this.box).find('> div.w2ui-grid-box')
                .css('width', $(this.box).width())
                .css('height', $(this.box).height());
            // event before
            var edata = this.trigger({phase: 'before', type: 'resize', target: this.name});
            if (edata.isCancelled === true) return;
            // resize
            obj.resizeBoxes();
            obj.resizeRecords();
            if (obj.toolbar &amp;&amp; obj.toolbar.resize) obj.toolbar.resize();
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            return (new Date()).getTime() - time;
        },

        update: function (cells) {
            var time = (new Date()).getTime();
            if (this.box == null) return 0;
            if (cells == null) {
                for (var index = this.last.range_start - 1; index &lt;= this.last.range_end - 1; index++) {
                    if (index &lt; 0) continue;
                    var rec = this.records[index] || {};
                    if (!rec.w2ui) rec.w2ui = {};
                    for (var column = 0; column &lt; this.columns.length; column++) {
                        var row = $(this.box).find('#grid_' + this.name + '_rec_' + w2utils.escapeId(rec.recid));
                        var cell = $(this.box).find('#grid_' + this.name + '_data_' + index + '_' + column);
                        cell.replaceWith(this.getCellHTML(index, column, false));
                        cell = $(this.box).find('#grid_' + this.name + '_data_' + index + '_' + column); // need to reselect as it was replaced
                        // assign style
                        if (rec.w2ui.style != null &amp;&amp; !$.isEmptyObject(rec.w2ui.style)) {
                            if (typeof rec.w2ui.style == 'string') {
                                row.attr('style', rec.w2ui.style);
                            }
                            if ($.isPlainObject(rec.w2ui.style) &amp;&amp; typeof rec.w2ui.style[column] == 'string') {
                                cell.attr('style', rec.w2ui.style[column]);
                            }
                        } else {
                            cell.attr('style', '');
                        }
                        // assign class
                        if (rec.w2ui.class != null &amp;&amp; !$.isEmptyObject(rec.w2ui.class)) {
                            if (typeof rec.w2ui.class == 'string') {
                                row.addClass(rec.w2ui.class);
                            }
                            if ($.isPlainObject(rec.w2ui.class) &amp;&amp; typeof rec.w2ui.class[column] == 'string') {
                                cell.addClass(rec.w2ui.class[column]);
                            }
                        }
                    }
                }

            } else {

                for (var i = 0; i &lt; cells.length; i++) {
                    var index = cells[i].index;
                    var column = cells[i].column;
                    if (index &lt; 0) continue;
                    if (index == null || column == null) {
                        console.log('ERROR: Wrong argument for grid.update(cells), cells should be [{ index: X, column: Y }, ...]');
                        continue;
                    }
                    var rec = this.records[index] || {};
                    var row = $(this.box).find('#grid_' + this.name + '_rec_' + w2utils.escapeId(rec.recid));
                    var cell = $(this.box).find('#grid_' + this.name + '_data_' + index + '_' + column);
                    if (!rec.w2ui) rec.w2ui = {};
                    cell.replaceWith(this.getCellHTML(index, column, false));
                    cell = $(this.box).find('#grid_' + this.name + '_data_' + index + '_' + column); // need to reselect as it was replaced
                    // assign style
                    if (rec.w2ui.style != null &amp;&amp; !$.isEmptyObject(rec.w2ui.style)) {
                        if (typeof rec.w2ui.style == 'string') {
                            row.attr('style', rec.w2ui.style);
                        }
                        if ($.isPlainObject(rec.w2ui.style) &amp;&amp; typeof rec.w2ui.style[column] == 'string') {
                            cell.attr('style', rec.w2ui.style[column]);
                        }
                    } else {
                        cell.attr('style', '');
                    }
                    // assign class
                    if (rec.w2ui.class != null &amp;&amp; !$.isEmptyObject(rec.w2ui.class)) {
                        if (typeof rec.w2ui.class == 'string') {
                            row.addClass(rec.w2ui.class);
                        }
                        if ($.isPlainObject(rec.w2ui.class) &amp;&amp; typeof rec.w2ui.class[column] == 'string') {
                            cell.addClass(rec.w2ui.class[column]);
                        }
                    }
                }
            }
            return (new Date()).getTime() - time;
        },

        refreshCell: function (recid, field) {
            var index = this.get(recid, true);
            var isSummary = (this.records[index] &amp;&amp; this.records[index].recid == recid ? false : true);
            var col_ind = this.getColumn(field, true);
            var rec = (isSummary ? this.summary[index] : this.records[index]);
            var col = this.columns[col_ind];
            var cell = $(this.box).find('#grid_' + this.name + '_data_' + index + '_' + col_ind);
            if (rec == null) return false;
            // set cell html and changed flag
            cell.replaceWith(this.getCellHTML(index, col_ind, isSummary));
            cell = $(this.box).find('#grid_' + this.name + '_data_' + index + '_' + col_ind); // need to recelect as it was replaced
            if (rec.w2ui &amp;&amp; rec.w2ui.changes &amp;&amp; rec.w2ui.changes[col.field] != null) {
                cell.addClass('w2ui-changed');
            } else {
                cell.removeClass('w2ui-changed');
            }
            // assign style
            if (rec.w2ui &amp;&amp; rec.w2ui.style != null &amp;&amp; !$.isEmptyObject(rec.w2ui.style)) {
                if (typeof rec.w2ui.style == 'string') {
                    $(this.box).find('#grid_' + this.name + '_rec_' + w2utils.escapeId(rec.recid)).attr('style', rec.w2ui.style);
                }
                if ($.isPlainObject(rec.w2ui.style) &amp;&amp; typeof rec.w2ui.style[col_ind] == 'string') {
                    cell.attr('style', rec.w2ui.style[col_ind]);
                }
            } else {
                cell.attr('style', '');
            }
            // assign class
            if (rec.w2ui &amp;&amp; rec.w2ui.class != null &amp;&amp; !$.isEmptyObject(rec.w2ui.class)) {
                if (typeof rec.w2ui.class == 'string') {
                    $(this.box).find('#grid_' + this.name + '_rec_' + w2utils.escapeId(rec.recid)).addClass(rec.w2ui.class);
                }
                if ($.isPlainObject(rec.w2ui.class) &amp;&amp; typeof rec.w2ui.class[col_ind] == 'string') {
                    cell.addClass(rec.w2ui.class[col_ind]);
                }
            }
        },

        refreshRow: function (recid, ind) {
            var tr1 = $(this.box).find('#grid_' + this.name + '_frec_' + w2utils.escapeId(recid));
            var tr2 = $(this.box).find('#grid_' + this.name + '_rec_' + w2utils.escapeId(recid));
            if (tr1.length > 0) {
                if (ind == null) ind = this.get(recid, true);
                var line = tr1.attr('line');
                var isSummary = (this.records[ind] &amp;&amp; this.records[ind].recid == recid ? false : true);
                // if it is searched, find index in search array
                var url = (typeof this.url != 'object' ? this.url : this.url.get);
                if (this.searchData.length > 0 &amp;&amp; !url) for (var s = 0; s &lt; this.last.searchIds.length; s++) if (this.last.searchIds[s] == ind) ind = s;
                var rec_html = this.getRecordHTML(ind, line, isSummary);
                $(tr1).replaceWith(rec_html[0]);
                $(tr2).replaceWith(rec_html[1]);
                // apply style to row if it was changed in render functions
                var st = (this.records[ind].w2ui ? this.records[ind].w2ui.style : '');
                if (typeof st == 'string') {
                    var tr1 = $(this.box).find('#grid_' + this.name + '_frec_' + w2utils.escapeId(recid));
                    var tr2 = $(this.box).find('#grid_' + this.name + '_rec_' + w2utils.escapeId(recid));
                    tr1.attr('custom_style', st);
                    tr2.attr('custom_style', st);
                    if (tr1.hasClass('w2ui-selected')) {
                        st = st.replace('background-color', 'none');
                    }
                    tr1[0].style.cssText = 'height: ' + this.recordHeight + 'px;' + st;
                    tr2[0].style.cssText = 'height: ' + this.recordHeight + 'px;' + st;
                }
                if (isSummary) {
                    this.resize();
                }
            }
        },

        refresh: function () {
            var obj = this;
            var time = (new Date()).getTime();
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (this.total &lt;= 0 &amp;&amp; !url &amp;&amp; this.searchData.length === 0) {
                this.total = this.records.length;
            }
            this.toolbar.disable('w2ui-edit', 'w2ui-delete');
            if (!this.box) return;
            // event before
            var edata = this.trigger({phase: 'before', target: this.name, type: 'refresh'});
            if (edata.isCancelled === true) return;
            // -- header
            if (this.show.header) {
                $('#grid_' + this.name + '_header').html(this.header + '&amp;#160;').show();
            } else {
                $('#grid_' + this.name + '_header').hide();
            }
            // -- toolbar
            if (this.show.toolbar) {
                // if select-collumn is checked - no toolbar refresh
                if (this.toolbar &amp;&amp; this.toolbar.get('w2ui-column-on-off') &amp;&amp; this.toolbar.get('w2ui-column-on-off').checked) {
                    // no action
                } else {
                    $('#grid_' + this.name + '_toolbar').show();
                    // refresh toolbar all but search field
                    if (typeof this.toolbar == 'object') {
                        var tmp = this.toolbar.items;
                        for (var t = 0; t &lt; tmp.length; t++) {
                            if (tmp[t].id == 'w2ui-search' || tmp[t].type == 'break') continue;
                            this.toolbar.refresh(tmp[t].id);
                        }
                    }
                }
            } else {
                $('#grid_' + this.name + '_toolbar').hide();
            }
            // -- make sure search is closed
            this.searchClose();
            // search placeholder
            var el = $('#grid_' + obj.name + '_search_all');
            if (!this.multiSearch &amp;&amp; this.last.field == 'all' &amp;&amp; this.searches.length > 0) {
                this.last.field = this.searches[0].field;
                this.last.caption = this.searches[0].caption;
            }
            for (var s = 0; s &lt; this.searches.length; s++) {
                if (this.searches[s].field == this.last.field) this.last.caption = this.searches[s].caption;
            }
            if (this.last.multi) {
                el.attr('placeholder', '[' + w2utils.lang('Multiple Fields') + ']');
                el.w2field('clear');
            } else {
                el.attr('placeholder', w2utils.lang(this.last.caption));
            }
            if (el.val() != this.last.search) {
                var val = this.last.search;
                var tmp = el.data('w2field');
                if (tmp) val = tmp.format(val);
                el.val(val);
            }

            // -- body
            obj.refreshBody();

            // -- footer
            if (this.show.footer) {
                $('#grid_' + this.name + '_footer').html(this.getFooterHTML()).show();
            } else {
                $('#grid_' + this.name + '_footer').hide();
            }
            // show/hide clear search link
            var $clear = $('#grid_' + this.name + '_searchClear');
            $clear.hide();
            this.searchData.some(function (item) {
                var tmp = obj.getSearch(item.field);
                if (obj.last.multi || (tmp &amp;&amp; !tmp.hidden &amp;&amp; tmp.type != 'list')) {
                    $clear.show();
                    return true;
                }
            });
            // all selected?
            var sel = this.last.selection,
                areAllSelected = (this.records.length > 0 &amp;&amp; sel.indexes.length == this.records.length),
                areAllSearchedSelected = (sel.indexes.length > 0 &amp;&amp; this.searchData.length !== 0 &amp;&amp; sel.indexes.length == this.last.searchIds.length);
            if (areAllSelected || areAllSearchedSelected) {
                $('#grid_' + this.name + '_check_all').prop('checked', true);
            } else {
                $('#grid_' + this.name + '_check_all').prop('checked', false);
            }
            // show number of selected
            this.status();
            // collapse all records
            var rows = obj.find({'w2ui.expanded': true}, true);
            for (var r = 0; r &lt; rows.length; r++) {
                var tmp = obj.records[rows[r]].w2ui;
                if (tmp &amp;&amp; !Array.isArray(tmp.children)) {
                    tmp.expanded = false;
                }
            }
            // mark selection
            if (obj.markSearch) {
                setTimeout(function () {
                    // mark all search strings
                    var str = [];
                    for (var s = 0; s &lt; obj.searchData.length; s++) {
                        var sdata = obj.searchData[s];
                        var fld = obj.getSearch(sdata.field);
                        if (!fld || fld.hidden) continue;
                        if (str.indexOf(sdata.value) == -1) str.push(sdata.value);
                    }
                    if (str.length > 0) $(obj.box).find('.w2ui-grid-data > div').w2marker(str);
                }, 50);
            }
            // enable/disable toolbar search button
            if (this.show.toolbarSave) {
                if (this.getChanges().length > 0) this.toolbar.enable('w2ui-save'); else this.toolbar.disable('w2ui-save');
            }
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            obj.resize();
            obj.addRange('selection');
            setTimeout(function () { // allow to render first
                obj.resize(); // needed for horizontal scroll to show (do not remove)
                obj.scroll();
            }, 1);

            if (obj.reorderColumns &amp;&amp; !obj.last.columnDrag) {
                obj.last.columnDrag = obj.initColumnDrag();
            } else if (!obj.reorderColumns &amp;&amp; obj.last.columnDrag) {
                obj.last.columnDrag.remove();
            }
            return (new Date()).getTime() - time;
        },

        refreshBody: function () {
            // -- separate summary
            var tmp = this.find({'w2ui.summary': true}, true);
            if (tmp.length > 0) {
                for (var t = 0; t &lt; tmp.length; t++) this.summary.push(this.records[tmp[t]]);
                for (var t = tmp.length - 1; t >= 0; t--) this.records.splice(tmp[t], 1);
            }

            // -- body
            this.scroll(); // need to calculate virtual scolling for columns
            var recHTML = this.getRecordsHTML();
            var colHTML = this.getColumnsHTML();
            var bodyHTML =
                '&lt;div id="grid_' + this.name + '_frecords" class="w2ui-grid-frecords" style="margin-bottom: ' + (w2utils.scrollBarSize() - 1) + 'px;">' +
                recHTML[0] +
                '&lt;/div>' +
                '&lt;div id="grid_' + this.name + '_records" class="w2ui-grid-records" onscroll="w2ui[\'' + this.name + '\'].scroll(event);">' +
                recHTML[1] +
                '&lt;/div>' +
                '&lt;div id="grid_' + this.name + '_scroll1" class="w2ui-grid-scroll1" style="height: ' + w2utils.scrollBarSize() + 'px">&lt;/div>' +
                // Columns need to be after to be able to overlap
                '&lt;div id="grid_' + this.name + '_fcolumns" class="w2ui-grid-fcolumns">' +
                '    &lt;table>&lt;tbody>' + colHTML[0] + '&lt;/tbody>&lt;/table>' +
                '&lt;/div>' +
                '&lt;div id="grid_' + this.name + '_columns" class="w2ui-grid-columns">' +
                '    &lt;table>&lt;tbody>' + colHTML[1] + '&lt;/tbody>&lt;/table>' +
                '&lt;/div>';
            $('#grid_' + this.name + '_body').html(bodyHTML);
            if (this.records.length === 0 &amp;&amp; this.msgEmpty) {
                $('#grid_' + this.name + '_body')
                    .append('&lt;div id="grid_' + this.name + '_empty_msg" class="w2ui-grid-empty-msg">&lt;div>' + this.msgEmpty + '&lt;/div>&lt;/div>');
            } else if ($('#grid_' + this.name + '_empty_msg').length > 0) {
                $('#grid_' + this.name + '_empty_msg').remove();
            }
            // show summary records
            if (this.summary.length > 0) {
                var sumHTML = this.getSummaryHTML();
                $('#grid_' + this.name + '_fsummary').html(sumHTML[0]).show();
                $('#grid_' + this.name + '_summary').html(sumHTML[1]).show();
            } else {
                $('#grid_' + this.name + '_fsummary').hide();
                $('#grid_' + this.name + '_summary').hide();
            }
        },

        render: function (box) {
            var obj = this;
            var time = (new Date()).getTime();
            if (box != null) {
                if ($(this.box).find('#grid_' + this.name + '_body').length > 0) {
                    $(this.box)
                        .removeAttr('name')
                        .removeClass('w2ui-reset w2ui-grid')
                        .html('');
                }
                this.box = box;
            }
            if (!this.box) return;
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            // event before
            var edata = this.trigger({phase: 'before', target: this.name, type: 'render', box: box});
            if (edata.isCancelled === true) return;
            // reset needed if grid existed
            this.reset(true);
            // --- default search field
            if (!this.last.field) {
                if (!this.multiSearch || !this.show.searchAll) {
                    var tmp = 0;
                    while (tmp &lt; this.searches.length &amp;&amp; (this.searches[tmp].hidden || this.searches[tmp].simple === false)) tmp++;
                    if (tmp >= this.searches.length) {
                        // all searches are hidden
                        this.last.field = '';
                        this.last.caption = '';
                    } else {
                        this.last.field = this.searches[tmp].field;
                        this.last.caption = this.searches[tmp].caption;
                    }
                } else {
                    this.last.field = 'all';
                    this.last.caption = w2utils.lang('All Fields');
                }
            }
            // insert elements
            $(this.box)
                .attr('name', this.name)
                .addClass('w2ui-reset w2ui-grid')
                .html('&lt;div class="w2ui-grid-box">' +
                    '    &lt;div id="grid_' + this.name + '_header" class="w2ui-grid-header">&lt;/div>' +
                    '    &lt;div id="grid_' + this.name + '_toolbar" class="w2ui-grid-toolbar">&lt;/div>' +
                    '    &lt;div id="grid_' + this.name + '_body" class="w2ui-grid-body">&lt;/div>' +
                    '    &lt;div id="grid_' + this.name + '_fsummary" class="w2ui-grid-body w2ui-grid-summary">&lt;/div>' +
                    '    &lt;div id="grid_' + this.name + '_summary" class="w2ui-grid-body w2ui-grid-summary">&lt;/div>' +
                    '    &lt;div id="grid_' + this.name + '_footer" class="w2ui-grid-footer">&lt;/div>' +
                    '    &lt;textarea id="grid_' + this.name + '_focus" class="w2ui-grid-focus-input">&lt;/textarea>' +
                    '&lt;/div>');
            if (this.selectType != 'row') $(this.box).addClass('w2ui-ss');
            if ($(this.box).length > 0) $(this.box)[0].style.cssText += this.style;
            // init toolbar
            this.initToolbar();
            if (this.toolbar != null) this.toolbar.render($('#grid_' + this.name + '_toolbar')[0]);
            // reinit search_all
            if (this.last.field &amp;&amp; this.last.field != 'all') {
                var sd = this.searchData;
                setTimeout(function () {
                    obj.initAllField(obj.last.field, (sd.length == 1 ? sd[0].value : null));
                }, 1);
            }
            // init footer
            $('#grid_' + this.name + '_footer').html(this.getFooterHTML());
            // refresh
            if (!this.last.state) this.last.state = this.stateSave(true); // initial default state
            this.stateRestore();
            if (url) this.refresh(); // show empty grid (need it) - should it be only for remote data source
            // if hidden searches - apply it
            var hasHiddenSearches = false;
            for (var i = 0; i &lt; this.searches.length; i++) {
                if (this.searches[i].hidden) {
                    hasHiddenSearches = true;
                    break;
                }
            }
            if (hasHiddenSearches) {
                this.searchReset(false); // will call reload
                if (!url) setTimeout(function () {
                    obj.searchReset();
                }, 1);
            } else {
                this.reload();
            }
            // focus
            $(this.box).find('#grid_' + this.name + '_focus')
                .on('focus', function (event) {
                    clearTimeout(obj.last.kbd_timer);
                    if (!obj.hasFocus) obj.focus();
                })
                .on('blur', function (event) {
                    clearTimeout(obj.last.kbd_timer);
                    obj.last.kbd_timer = setTimeout(function () {
                        if (obj.hasFocus) {
                            obj.blur();
                        }
                    }, 100); // need this timer to be 100 ms
                })
                .on('paste', function (event) {
                    var el = this;
                    setTimeout(function () {
                        w2ui[obj.name].paste(el.value);
                        el.value = '';
                    }, 1)
                })
                .on('keydown', function (event) {
                    w2ui[obj.name].keydown.call(w2ui[obj.name], event);
                });
            // init mouse events for mouse selection
            var edataCol; // event for column select
            $(this.box).on('mousedown', mouseStart);
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            // attach to resize event
            if ($('.w2ui-layout').length === 0) { // if there is layout, it will send a resize event
                $(window).off('resize.w2ui-' + this.name)
                    .on('resize.w2ui-' + this.name, function (event) {
                        w2ui[obj.name].resize();
                    });
            }
            return (new Date()).getTime() - time;

            function mouseStart(event) {
                if (event.which != 1) return; // if not left mouse button
                // restore css user-select
                if (obj.last.userSelect == 'text') {
                    delete obj.last.userSelect;
                    $(obj.box).find('.w2ui-grid-body').css(w2utils.cssPrefix('user-select', 'none'));
                }
                // regular record select
                if (obj.selectType == 'row' &amp;&amp; ($(event.target).parents().hasClass('w2ui-head') || $(event.target).hasClass('w2ui-head'))) return;
                if (obj.last.move &amp;&amp; obj.last.move.type == 'expand') return;
                // if altKey - alow text selection
                if (event.altKey) {
                    $(obj.box).find('.w2ui-grid-body').css(w2utils.cssPrefix('user-select', 'text'));
                    obj.selectNone();
                    obj.last.move = {type: 'text-select'};
                    obj.last.userSelect = 'text';
                } else if (obj.multiSelect || obj.reorderRows) {
                    var tmp = event.target;
                    var pos = {
                        x: event.offsetX - 10,
                        y: event.offsetY - 10
                    }
                    var tmps = false;
                    while (tmp) {
                        if (tmp.classList &amp;&amp; tmp.classList.contains('w2ui-grid')) break;
                        if (tmp.tagName &amp;&amp; tmp.tagName.toUpperCase() == 'TD') tmps = true;
                        if (tmp.tagName &amp;&amp; tmp.tagName.toUpperCase() != 'TR' &amp;&amp; tmps == true) {
                            pos.x += tmp.offsetLeft;
                            pos.y += tmp.offsetTop;
                        }
                        tmp = tmp.parentNode;
                    }

                    obj.last.move = {
                        x: event.screenX,
                        y: event.screenY,
                        divX: 0,
                        divY: 0,
                        focusX: pos.x,
                        focusY: pos.y,
                        recid: $(event.target).parents('tr').attr('recid'),
                        column: parseInt(event.target.tagName.toUpperCase() == 'TD' ? $(event.target).attr('col') : $(event.target).parents('td').attr('col')),
                        type: 'select',
                        ghost: false,
                        start: true
                    };
                    if (obj.last.move.recid == null) obj.last.move.type = 'select-column';
                    // set focus to grid
                    var target = event.target;
                    var $input = $(obj.box).find('#grid_' + obj.name + '_focus');
                    // move input next to cursor so screen does not jump
                    if (obj.last.move) {
                        var sLeft = obj.last.move.focusX;
                        var sTop = obj.last.move.focusY;
                        var $owner = $(target).parents('table').parent();
                        if ($owner.hasClass('w2ui-grid-records') || $owner.hasClass('w2ui-grid-frecords')
                            || $owner.hasClass('w2ui-grid-columns') || $owner.hasClass('w2ui-grid-fcolumns')
                            || $owner.hasClass('w2ui-grid-summary')) {
                            sLeft = obj.last.move.focusX - $(obj.box).find('#grid_' + obj.name + '_records').scrollLeft();
                            sTop = obj.last.move.focusY - $(obj.box).find('#grid_' + obj.name + '_records').scrollTop();
                        }
                        if ($(target).hasClass('w2ui-grid-footer') || $(target).parents('div.w2ui-grid-footer').length > 0) {
                            sTop = $(obj.box).find('#grid_' + obj.name + '_footer').position().top;
                        }
                        $input.css({
                            left: sLeft - 10,
                            top: sTop
                        });
                    }
                    // if toolbar input is clicked
                    setTimeout(function () {
                        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName.toUpperCase()) != -1) {
                            $(target).focus();
                        } else {
                            if (!$input.is(':focus')) $input.focus();
                        }
                    }, 50);
                }
                if (obj.reorderRows == true) {
                    var el = event.target;
                    if (el.tagName.toUpperCase() != 'TD') el = $(el).parents('td')[0];
                    if ($(el).hasClass('w2ui-col-number')) {
                        obj.selectNone();
                        obj.last.move.reorder = true;
                        // supress hover
                        var eColor = $(obj.box).find('.w2ui-even.w2ui-empty-record').css('background-color');
                        var oColor = $(obj.box).find('.w2ui-odd.w2ui-empty-record').css('background-color');
                        $(obj.box).find('.w2ui-even td').not('.w2ui-col-number').css('background-color', eColor);
                        $(obj.box).find('.w2ui-odd td').not('.w2ui-col-number').css('background-color', oColor);
                        // display empty record and ghost record
                        var mv = obj.last.move;
                        if (!mv.ghost) {
                            var row = $('#grid_' + obj.name + '_rec_' + mv.recid);
                            var tmp = row.parents('table').find('tr:first-child').clone();
                            mv.offsetY = event.offsetY;
                            mv.from = mv.recid;
                            mv.pos = row.position();
                            mv.ghost = $(row).clone(true);
                            mv.ghost.removeAttr('id');
                            row.find('td').remove();
                            row.append('&lt;td colspan="1000" style="height: ' + obj.recordHeight + 'px; background-color: #eee; border-bottom: 1px dashed #aaa; border-top: 1px dashed #aaa;">&lt;/td>');
                            var recs = $(obj.box).find('.w2ui-grid-records');
                            recs.append('&lt;table id="grid_' + obj.name + '_ghost" style="position: absolute; z-index: 999999; opacity: 0.7; pointer-events: none;">&lt;/table>');
                            $('#grid_' + obj.name + '_ghost').append(tmp).append(mv.ghost);
                        }
                        var ghost = $('#grid_' + obj.name + '_ghost');
                        var recs = $(obj.box).find('.w2ui-grid-records');
                        ghost.css({
                            top: mv.pos.top + recs.scrollTop(),
                            left: mv.pos.left,
                            "border-top": '1px solid #aaa',
                            "border-bottom": '1px solid #aaa'
                        });
                    } else {
                        obj.last.move.reorder = false;
                    }
                }
                $(document).on('mousemove', mouseMove);
                $(document).on('mouseup', mouseStop);
                // needed when grid grids are nested, see issue #1275
                event.stopPropagation();
            }

            function mouseMove(event) {
                var mv = obj.last.move;
                if (!mv || ['select', 'select-column'].indexOf(mv.type) == -1) return;
                mv.divX = (event.screenX - mv.x);
                mv.divY = (event.screenY - mv.y);
                if (Math.abs(mv.divX) &lt;= 1 &amp;&amp; Math.abs(mv.divY) &lt;= 1) return; // only if moved more then 1px
                obj.last.cancelClick = true;
                if (obj.reorderRows == true &amp;&amp; obj.last.move.reorder) {
                    var tmp = $(event.target).parents('tr');
                    var recid = tmp.attr('recid');
                    if (recid != mv.from) {
                        var row1 = $('#grid_' + obj.name + '_rec_' + mv.recid);
                        var row2 = $('#grid_' + obj.name + '_rec_' + recid);
                        $(obj.box).find('.tmp-ghost').css('border-top', '0px');
                        row2.addClass('tmp-ghost').css('border-top', '2px solid #769EFC');
                        // MOVABLE GHOST
                        // if (event.screenY - mv.lastY &lt; 0) row1.after(row2); else row2.after(row1);
                        mv.lastY = event.screenY;
                        mv.to = recid;
                    }
                    var ghost = $('#grid_' + obj.name + '_ghost');
                    var recs = $(obj.box).find('.w2ui-grid-records');
                    ghost.css({
                        top: mv.pos.top + mv.divY + recs.scrollTop(),
                        left: mv.pos.left
                    });
                    return;
                }
                if (mv.start &amp;&amp; mv.recid) {
                    obj.selectNone();
                    mv.start = false;
                }
                var newSel = [];
                var recid = (event.target.tagName.toUpperCase() == 'TR' ? $(event.target).attr('recid') : $(event.target).parents('tr').attr('recid'));
                if (recid == null) {
                    // select by dragging columns
                    if (obj.selectType == 'row') return;
                    if (obj.last.move &amp;&amp; obj.last.move.type == 'select') return;
                    var col = parseInt($(event.target).parents('td').attr('col'));
                    if (isNaN(col)) {
                        obj.removeRange('column-selection');
                        $(obj.box).find('.w2ui-grid-columns .w2ui-col-header, .w2ui-grid-fcolumns .w2ui-col-header').removeClass('w2ui-col-selected');
                        $(obj.box).find('.w2ui-col-number').removeClass('w2ui-row-selected');
                        delete mv.colRange;
                    } else {
                        // add all columns in between
                        var newRange = col + '-' + col;
                        if (mv.column &lt; col) newRange = mv.column + '-' + col;
                        if (mv.column > col) newRange = col + '-' + mv.column;
                        // array of selected columns
                        var cols = [];
                        var tmp = newRange.split('-');
                        for (var ii = parseInt(tmp[0]); ii &lt;= parseInt(tmp[1]); ii++) {
                            cols.push(ii)
                        }
                        if (mv.colRange != newRange) {
                            edataCol = obj.trigger({
                                phase: 'before',
                                type: 'columnSelect',
                                target: obj.name,
                                columns: cols,
                                isCancelled: false
                            }); // initial isCancelled
                            if (edataCol.isCancelled !== true) {
                                if (mv.colRange == null) obj.selectNone();
                                // highlight columns
                                var tmp = newRange.split('-');
                                $(obj.box).find('.w2ui-grid-columns .w2ui-col-header, .w2ui-grid-fcolumns .w2ui-col-header').removeClass('w2ui-col-selected');
                                for (var j = parseInt(tmp[0]); j &lt;= parseInt(tmp[1]); j++) {
                                    $(obj.box).find('#grid_' + obj.name + '_column_' + j + ' .w2ui-col-header').addClass('w2ui-col-selected');
                                }
                                $(obj.box).find('.w2ui-col-number').not('.w2ui-head').addClass('w2ui-row-selected');
                                // show new range
                                mv.colRange = newRange;
                                obj.removeRange('column-selection');
                                obj.addRange({
                                    name: 'column-selection',
                                    range: [{
                                        recid: obj.records[0].recid,
                                        column: tmp[0]
                                    }, {recid: obj.records[obj.records.length - 1].recid, column: tmp[1]}],
                                    style: 'background-color: rgba(90, 145, 234, 0.1)'
                                });
                            }
                        }
                    }

                } else { // regular selection

                    var ind1 = obj.get(mv.recid, true);
                    // this happens when selection is started on summary row
                    if (ind1 == null || (obj.records[ind1] &amp;&amp; obj.records[ind1].recid != mv.recid)) return;
                    var ind2 = obj.get(recid, true);
                    // this happens when selection is extended into summary row (a good place to implement scrolling)
                    if (ind2 == null) return;
                    var col1 = parseInt(mv.column);
                    var col2 = parseInt(event.target.tagName.toUpperCase() == 'TD' ? $(event.target).attr('col') : $(event.target).parents('td').attr('col'));
                    if (isNaN(col1) &amp;&amp; isNaN(col2)) { // line number select entire record
                        col1 = 0;
                        col2 = obj.columns.length - 1;
                    }
                    if (ind1 > ind2) {
                        var tmp = ind1;
                        ind1 = ind2;
                        ind2 = tmp;
                    }
                    // check if need to refresh
                    var tmp = 'ind1:' + ind1 + ',ind2;' + ind2 + ',col1:' + col1 + ',col2:' + col2;
                    if (mv.range == tmp) return;
                    mv.range = tmp;
                    for (var i = ind1; i &lt;= ind2; i++) {
                        if (obj.last.searchIds.length > 0 &amp;&amp; obj.last.searchIds.indexOf(i) == -1) continue;
                        if (obj.selectType != 'row') {
                            if (col1 > col2) {
                                var tmp = col1;
                                col1 = col2;
                                col2 = tmp;
                            }
                            var tmp = [];
                            for (var c = col1; c &lt;= col2; c++) {
                                if (obj.columns[c].hidden) continue;
                                newSel.push({recid: obj.records[i].recid, column: parseInt(c)});
                            }
                        } else {
                            newSel.push(obj.records[i].recid);
                        }
                    }
                    if (obj.selectType != 'row') {
                        var sel = obj.getSelection();
                        // add more items
                        var tmp = [];
                        for (var ns = 0; ns &lt; newSel.length; ns++) {
                            var flag = false;
                            for (var s = 0; s &lt; sel.length; s++) if (newSel[ns].recid == sel[s].recid &amp;&amp; newSel[ns].column == sel[s].column) flag = true;
                            if (!flag) tmp.push({recid: newSel[ns].recid, column: newSel[ns].column});
                        }
                        obj.select.apply(obj, tmp);
                        // remove items
                        var tmp = [];
                        for (var s = 0; s &lt; sel.length; s++) {
                            var flag = false;
                            for (var ns = 0; ns &lt; newSel.length; ns++) if (newSel[ns].recid == sel[s].recid &amp;&amp; newSel[ns].column == sel[s].column) flag = true;
                            if (!flag) tmp.push({recid: sel[s].recid, column: sel[s].column});
                        }
                        obj.unselect.apply(obj, tmp);
                    } else {
                        if (obj.multiSelect) {
                            var sel = obj.getSelection();
                            for (var ns = 0; ns &lt; newSel.length; ns++) {
                                if (sel.indexOf(newSel[ns]) == -1) obj.select(newSel[ns]); // add more items
                            }
                            for (var s = 0; s &lt; sel.length; s++) {
                                if (newSel.indexOf(sel[s]) == -1) obj.unselect(sel[s]); // remove items
                            }
                        }
                    }
                }
            }

            function mouseStop(event) {
                var mv = obj.last.move;
                setTimeout(function () {
                    delete obj.last.cancelClick;
                }, 1);
                if ($(event.target).parents().hasClass('.w2ui-head') || $(event.target).hasClass('.w2ui-head')) return;
                if (mv &amp;&amp; ['select', 'select-column'].indexOf(mv.type) != -1) {
                    if (mv.colRange != null &amp;&amp; edataCol.isCancelled !== true) {
                        var tmp = mv.colRange.split('-');
                        var sel = [];
                        for (var i = 0; i &lt; obj.records.length; i++) {
                            var cols = []
                            for (var j = parseInt(tmp[0]); j &lt;= parseInt(tmp[1]); j++) cols.push(j);
                            sel.push({recid: obj.records[i].recid, column: cols});
                        }
                        obj.removeRange('column-selection');
                        obj.trigger($.extend(edataCol, {phase: 'after'}));
                        obj.select.apply(obj, sel);
                    }
                    if (obj.reorderRows == true &amp;&amp; obj.last.move.reorder) {
                        // event
                        var edata = obj.trigger({
                            phase: 'before',
                            target: obj.name,
                            type: 'reorderRow',
                            recid: mv.from,
                            moveAfter: mv.to
                        });
                        if (edata.isCancelled === true) {
                            $('#grid_' + obj.name + '_ghost').remove();
                            obj.refresh();
                            return;
                        }
                        // default behavior
                        var ind1 = obj.get(mv.from, true);
                        var ind2 = obj.get(mv.to, true);
                        var tmp = obj.records[ind1];
                        // swap records
                        if (ind1 != null &amp;&amp; ind2 != null) {
                            obj.records.splice(ind1, 1);
                            if (ind1 > ind2) {
                                obj.records.splice(ind2, 0, tmp);
                            } else {
                                obj.records.splice(ind2 - 1, 0, tmp);
                            }
                        }
                        $('#grid_' + obj.name + '_ghost').remove();
                        obj.refresh();
                        // event after
                        obj.trigger($.extend(edata, {phase: 'after'}));
                    }
                }
                delete obj.last.move;
                $(document).off('mousemove', mouseMove);
                $(document).off('mouseup', mouseStop);
            }
        },

        destroy: function () {
            // event before
            var edata = this.trigger({phase: 'before', target: this.name, type: 'destroy'});
            if (edata.isCancelled === true) return;
            // remove events
            $(window).off('resize.w2ui-' + this.name);
            // clean up
            if (typeof this.toolbar == 'object' &amp;&amp; this.toolbar.destroy) this.toolbar.destroy();
            if ($(this.box).find('#grid_' + this.name + '_body').length > 0) {
                $(this.box)
                    .removeAttr('name')
                    .removeClass('w2ui-reset w2ui-grid')
                    .html('');
            }
            delete w2ui[this.name];
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        // ===========================================
        // --- Internal Functions

        initColumnOnOff: function () {
            if (!this.show.toolbarColumns) return;
            var obj = this;
            // line number
            var col_html = '&lt;div class="w2ui-col-on-off">' +
                '&lt;table>&lt;tbody>' +
                '&lt;tr id="grid_' + this.name + '_column_ln_check" onclick="w2ui[\'' + obj.name + '\'].columnOnOff(event, \'line-numbers\'); event.stopPropagation();">' +
                '   &lt;td style="width: 30px; text-align: center; padding-right: 3px; color: #888;">' +
                '      &lt;span class="w2ui-column-check w2ui-icon-' + (!obj.show.lineNumbers ? 'empty' : 'check') + '">&lt;/span>' +
                '   &lt;/td>' +
                '   &lt;td onclick="jQuery(\'.w2ui-overlay\')[0].hide();">' +
                '      &lt;label>' + w2utils.lang('Line #') + '&lt;/label>' +
                '   &lt;/td>' +
                '&lt;/tr>';
            // columns
            for (var c = 0; c &lt; this.columns.length; c++) {
                var col = this.columns[c];
                var tmp = this.columns[c].caption;
                if (col.hideable === false) continue;
                if (!tmp &amp;&amp; this.columns[c].tooltip) tmp = this.columns[c].tooltip;
                if (!tmp) tmp = '- column ' + (parseInt(c) + 1) + ' -';
                col_html +=
                    '&lt;tr id="grid_' + this.name + '_column_' + c + '_check" ' +
                    '       onclick="w2ui[\'' + obj.name + '\'].columnOnOff(event, \'' + col.field + '\'); event.stopPropagation();">' +
                    '   &lt;td style="width: 30px; text-align: center; padding-right: 3px; color: #888;">' +
                    '      &lt;span class="w2ui-column-check w2ui-icon-' + (col.hidden ? 'empty' : 'check') + '">&lt;/span>' +
                    '   &lt;/td>' +
                    '   &lt;td onclick="jQuery(\'.w2ui-overlay\')[0].hide();">' +
                    '       &lt;label>' + w2utils.stripTags(tmp) + '&lt;/label>' +
                    '   &lt;/td>' +
                    '&lt;/tr>';
            }
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            // devider
            if ((url &amp;&amp; obj.show.skipRecords) || obj.show.saveRestoreState) {
                col_html += '&lt;tr style="pointer-events: none">&lt;td colspan="2">&lt;div style="border-top: 1px solid #ddd;">&lt;/div>&lt;/td>&lt;/tr>';
            }
            // skip records
            if (url &amp;&amp; obj.show.skipRecords) {
                col_html +=
                    '&lt;tr>&lt;td colspan="2" style="padding: 0px">' +
                    '    &lt;div style="cursor: pointer; padding: 2px 8px; cursor: default">' + w2utils.lang('Skip') +
                    '        &lt;input type="text" style="width: 60px" value="' + this.offset + '" ' +
                    '            onkeydown="if ([48,49,50,51,52,53,54,55,56,57,58,13,8,46,37,39].indexOf(event.keyCode) == -1) { event.preventDefault() }"' +
                    '            onkeypress="if (event.keyCode == 13) { ' +
                    '               w2ui[\'' + obj.name + '\'].skip(this.value); ' +
                    '               jQuery(\'.w2ui-overlay\')[0].hide(); ' +
                    '            }"/> ' + w2utils.lang('Records') +
                    '    &lt;/div>' +
                    '&lt;/td>&lt;/tr>';
            }
            // save/restore state
            if (obj.show.saveRestoreState) {
                col_html += '&lt;tr>&lt;td colspan="2" onclick="var obj = w2ui[\'' + obj.name + '\']; obj.toolbar.uncheck(\'w2ui-column-on-off\'); obj.stateSave();">' +
                    '    &lt;div style="cursor: pointer; padding: 4px 8px; cursor: default">' + w2utils.lang('Save Grid State') + '&lt;/div>' +
                    '&lt;/td>&lt;/tr>' +
                    '&lt;tr>&lt;td colspan="2" onclick="var obj = w2ui[\'' + obj.name + '\']; obj.toolbar.uncheck(\'w2ui-column-on-off\'); obj.stateReset();">' +
                    '    &lt;div style="cursor: pointer; padding: 4px 8px; cursor: default">' + w2utils.lang('Restore Default State') + '&lt;/div>' +
                    '&lt;/td>&lt;/tr>';
            }
            col_html += "&lt;/tbody>&lt;/table>&lt;/div>";
            this.toolbar.get('w2ui-column-on-off').html = col_html;
        },

        /**
         *
         * @param box, grid object
         * @returns {{remove: Function}} contains a closure around all events to ensure they are removed from the dom
         */
        initColumnDrag: function (box) {
            //throw error if using column groups
            if (this.columnGroups &amp;&amp; this.columnGroups.length) throw 'Draggable columns are not currently supported with column groups.';

            var obj = this,
                _dragData = {};
            _dragData.lastInt = null;
            _dragData.pressed = false;
            _dragData.timeout = null;
            _dragData.columnHead = null;

            //attach original event listener
            $(obj.box).on('mousedown', dragColStart);
            $(obj.box).on('mouseup', catchMouseup);

            function catchMouseup() {
                _dragData.pressed = false;
                clearTimeout(_dragData.timeout);
            }

            /**
             *
             * @param event, mousedown
             * @returns {boolean} false, preventsDefault
             */
            function dragColStart(event) {
                if (_dragData.timeout) clearTimeout(_dragData.timeout);
                var self = this;
                _dragData.pressed = true;

                _dragData.timeout = setTimeout(function () {
                    if (!_dragData.pressed) return;

                    var edata,
                        columns,
                        selectedCol,
                        origColumn,
                        origColumnNumber,
                        invalidPreColumns = ['w2ui-col-number', 'w2ui-col-expand', 'w2ui-col-select'],
                        invalidPostColumns = ['w2ui-head-last'],
                        invalidColumns = invalidPreColumns.concat(invalidPostColumns),
                        preColumnsSelector = '.w2ui-col-number, .w2ui-col-expand, .w2ui-col-select',
                        preColHeadersSelector = '.w2ui-head.w2ui-col-number, .w2ui-head.w2ui-col-expand, .w2ui-head.w2ui-col-select';

                    // do nothing if it is not a header
                    if (!$(event.originalEvent.target).parents().hasClass('w2ui-head')) return;

                    // do nothing if it is an invalid column
                    for (var i = 0, l = invalidColumns.length; i &lt; l; i++) {
                        if ($(event.originalEvent.target).parents().hasClass(invalidColumns[i])) return;
                    }

                    _dragData.numberPreColumnsPresent = $(obj.box).find(preColHeadersSelector).length;

                    //start event for drag start
                    _dragData.columnHead = origColumn = $(event.originalEvent.target).parents('.w2ui-head');
                    origColumnNumber = parseInt(origColumn.attr('col'), 10);
                    edata = obj.trigger({
                        type: 'columnDragStart',
                        phase: 'before',
                        originalEvent: event,
                        origColumnNumber: origColumnNumber,
                        target: origColumn[0]
                    });
                    if (edata.isCancelled === true) return false;

                    columns = _dragData.columns = $(obj.box).find('.w2ui-head:not(.w2ui-head-last)');

                    //add events
                    $(document).on('mouseup', dragColEnd);
                    $(document).on('mousemove', dragColOver);

                    _dragData.originalPos = parseInt($(event.originalEvent.target).parent('.w2ui-head').attr('col'), 10);
                    //_dragData.columns.css({ overflow: 'visible' }).children( 'div' ).css({ overflow: 'visible' });

                    //configure and style ghost image
                    _dragData.ghost = $(self).clone(true);

                    //hide other elements on ghost except the grid body
                    $(_dragData.ghost).find('[col]:not([col="' + _dragData.originalPos + '"]), .w2ui-toolbar, .w2ui-grid-header').remove();
                    $(_dragData.ghost).find(preColumnsSelector).remove();
                    $(_dragData.ghost).find('.w2ui-grid-body').css({top: 0});

                    selectedCol = $(_dragData.ghost).find('[col="' + _dragData.originalPos + '"]');
                    $(document.body).append(_dragData.ghost);

                    $(_dragData.ghost).css({
                        width: 0,
                        height: 0,
                        margin: 0,
                        position: 'fixed',
                        zIndex: 999999,
                        opacity: 0
                    }).addClass('.w2ui-grid-ghost').animate({
                        width: selectedCol.width(),
                        height: $(obj.box).find('.w2ui-grid-body:first').height(),
                        left: event.pageX,
                        top: event.pageY,
                        opacity: 0.8
                    }, 0);

                    //establish current offsets
                    _dragData.offsets = [];
                    for (var i = 0, l = columns.length; i &lt; l; i++) {
                        _dragData.offsets.push($(columns[i]).offset().left);
                    }

                    //conclude event
                    obj.trigger($.extend(edata, {phase: 'after'}));
                }, 150);//end timeout wrapper
            }

            function dragColOver(event) {
                if (!_dragData.pressed) return;

                var cursorX = event.originalEvent.pageX,
                    cursorY = event.originalEvent.pageY,
                    offsets = _dragData.offsets,
                    lastWidth = $('.w2ui-head:not(.w2ui-head-last)').width();

                _dragData.targetInt = Math.max(_dragData.numberPreColumnsPresent, targetIntersection(cursorX, offsets, lastWidth));

                markIntersection(_dragData.targetInt);
                trackGhost(cursorX, cursorY);
            }

            function dragColEnd(event) {
                _dragData.pressed = false;

                var edata,
                    target,
                    selected,
                    columnConfig,
                    targetColumn,
                    ghosts = $('.w2ui-grid-ghost');

                //start event for drag start
                edata = obj.trigger({
                    type: 'columnDragEnd',
                    phase: 'before',
                    originalEvent: event,
                    target: _dragData.columnHead[0]
                });
                if (edata.isCancelled === true) return false;

                selected = obj.columns[_dragData.originalPos];
                columnConfig = obj.columns;
                targetColumn = $(_dragData.columns[Math.min(_dragData.lastInt, _dragData.columns.length - 1)]);
                target = (_dragData.lastInt &lt; _dragData.columns.length) ? parseInt(targetColumn.attr('col')) : columnConfig.length;

                if (target !== _dragData.originalPos + 1 &amp;&amp; target !== _dragData.originalPos &amp;&amp; targetColumn &amp;&amp; targetColumn.length) {
                    $(_dragData.ghost).animate({
                        top: $(obj.box).offset().top,
                        left: targetColumn.offset().left,
                        width: 0,
                        height: 0,
                        opacity: 0.2
                    }, 300, function () {
                        $(this).remove();
                        ghosts.remove();
                    });

                    columnConfig.splice(target, 0, $.extend({}, selected));
                    columnConfig.splice(columnConfig.indexOf(selected), 1);

                } else {
                    $(_dragData.ghost).remove();
                    ghosts.remove();
                }

                //_dragData.columns.css({ overflow: '' }).children( 'div' ).css({ overflow: '' });

                $(document).off('mouseup', dragColEnd);
                $(document).off('mousemove', dragColOver);
                if (_dragData.marker) _dragData.marker.remove();
                _dragData = {};

                obj.refresh();

                //conclude event
                obj.trigger($.extend(edata, {phase: 'after', targetColumnNumber: target - 1}));
            }

            function markIntersection(intersection) {
                if (!_dragData.marker &amp;&amp; !_dragData.markerLeft) {
                    _dragData.marker = $('&lt;div class="col-intersection-marker">' +
                        '&lt;div class="top-marker">&lt;/div>' +
                        '&lt;div class="bottom-marker">&lt;/div>' +
                        '&lt;/div>');
                    _dragData.markerLeft = $('&lt;div class="col-intersection-marker">' +
                        '&lt;div class="top-marker">&lt;/div>' +
                        '&lt;div class="bottom-marker">&lt;/div>' +
                        '&lt;/div>');
                }

                if (!_dragData.lastInt || _dragData.lastInt !== intersection) {
                    _dragData.lastInt = intersection;
                    _dragData.marker.remove();
                    _dragData.markerLeft.remove();
                    $('.w2ui-head').removeClass('w2ui-col-intersection');

                    //if the current intersection is greater than the number of columns add the marker to the end of the last column only
                    if (intersection >= _dragData.columns.length) {
                        $(_dragData.columns[_dragData.columns.length - 1]).children('div:last').append(_dragData.marker.addClass('right').removeClass('left'));
                        $(_dragData.columns[_dragData.columns.length - 1]).addClass('w2ui-col-intersection');
                    } else if (intersection &lt;= _dragData.numberPreColumnsPresent) {
                        //if the current intersection is on the column numbers place marker on first available column only
                        $(_dragData.columns[_dragData.numberPreColumnsPresent]).prepend(_dragData.marker.addClass('left').removeClass('right')).css({position: 'relative'});
                        $(_dragData.columns[_dragData.numberPreColumnsPresent]).prev().addClass('w2ui-col-intersection');
                    } else {
                        //otherwise prepend the marker to the targeted column and append it to the previous column
                        $(_dragData.columns[intersection]).children('div:last').prepend(_dragData.marker.addClass('left').removeClass('right'));
                        $(_dragData.columns[intersection]).prev().children('div:last').append(_dragData.markerLeft.addClass('right').removeClass('left')).css({position: 'relative'});
                        $(_dragData.columns[intersection - 1]).addClass('w2ui-col-intersection');
                    }
                }
            }

            function targetIntersection(cursorX, offsets, lastWidth) {
                if (cursorX &lt;= offsets[0]) {
                    return 0;
                } else if (cursorX >= offsets[offsets.length - 1] + lastWidth) {
                    return offsets.length;
                } else {
                    for (var i = 0, l = offsets.length; i &lt; l; i++) {
                        var thisOffset = offsets[i];
                        var nextOffset = offsets[i + 1] || offsets[i] + lastWidth;
                        var midpoint = ( nextOffset - offsets[i]) / 2 + offsets[i];

                        if (cursorX > thisOffset &amp;&amp; cursorX &lt;= midpoint) {
                            return i;
                        } else if (cursorX > midpoint &amp;&amp; cursorX &lt;= nextOffset) {
                            return i + 1;
                        }
                    }
                    return intersection;
                }
            }

            function trackGhost(cursorX, cursorY) {
                $(_dragData.ghost).css({
                    left: cursorX - 10,
                    top: cursorY - 10
                });
            }

            //return an object to remove drag if it has ever been enabled
            return {
                remove: function () {
                    $(obj.box).off('mousedown', dragColStart);
                    $(obj.box).off('mouseup', catchMouseup);
                    $(obj.box).find('.w2ui-head').removeAttr('draggable');
                    obj.last.columnDrag = false;
                }
            };
        },

        columnOnOff: function (event, field) {
            var $el = $(event.target).parents('tr').find('.w2ui-column-check');
            // event before
            var edata = this.trigger({
                phase: 'before',
                target: this.name,
                type: 'columnOnOff',
                field: field,
                originalEvent: event
            });
            if (edata.isCancelled === true) return;
            // regular processing
            var obj = this;
            // collapse expanded rows
            var rows = obj.find({'w2ui.expanded': true}, true);
            for (var r = 0; r &lt; rows.length; r++) {
                var tmp = this.records[r].w2ui;
                if (tmp &amp;&amp; !Array.isArray(tmp.children)) {
                    this.records[r].w2ui.expanded = false;
                }
            }
            // show/hide
            if (field == 'line-numbers') {
                this.show.lineNumbers = !this.show.lineNumbers;
                if (this.show.lineNumbers) {
                    $el.addClass('w2ui-icon-check').removeClass('w2ui-icon-empty');
                } else {
                    $el.addClass('w2ui-icon-empty').removeClass('w2ui-icon-check');
                }
                this.refreshBody();
                this.resizeRecords();
            } else {
                var col = this.getColumn(field);
                if (col.hidden) {
                    $el.addClass('w2ui-icon-check').removeClass('w2ui-icon-empty');
                    this.showColumn(col.field);
                } else {
                    $el.addClass('w2ui-icon-empty').removeClass('w2ui-icon-check');
                    this.hideColumn(col.field);
                }
            }
            if (!event.shiftKey &amp;&amp; !event.metaKey &amp;&amp; !event.ctrlKey) {
                // timeout needed for visual delay
                setTimeout(function () {
                    $().w2overlay({name: obj.name + '_toolbar'});
                }, 150);
            }
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        scrollToColumn: function (field) {
            if (field == null)
                return;
            var sWidth = 0;
            var found = false;
            for (var i = 0; i &lt; this.columns.length; i++) {
                var col = this.columns[i];
                if (col.field == field) {
                    found = true;
                    break;
                }
                if (col.frozen || col.hidden)
                    continue;
                var cSize = parseInt(col.sizeCalculated ? col.sizeCalculated : col.size);
                sWidth += cSize;
            }
            if (!found)
                return;
            this.last.scrollLeft = sWidth + 1;
            this.scroll();
        },

        initToolbar: function () {
            var obj = this;
            // -- if toolbar is true
            if (this.toolbar['render'] == null) {
                var tmp_items = this.toolbar.items;
                this.toolbar.items = [];
                this.toolbar = $().w2toolbar($.extend(true, {}, this.toolbar, {
                    name: this.name + '_toolbar',
                    owner: this
                }));

                // =============================================
                // ------ Toolbar Generic buttons

                if (this.show.toolbarReload) {
                    this.toolbar.items.push($.extend(true, {}, this.buttons['reload']));
                }
                if (this.show.toolbarColumns) {
                    this.toolbar.items.push($.extend(true, {}, this.buttons['columns']));
                }
                if (this.show.toolbarReload || this.show.toolbarColumns) {
                    this.toolbar.items.push({type: 'break', id: 'w2ui-break0'});
                }
                if (this.show.toolbarInput) {
                    var html =
                        '&lt;div class="w2ui-toolbar-search">' +
                        '&lt;table cellpadding="0" cellspacing="0">&lt;tbody>&lt;tr>' +
                        '    &lt;td>' + this.buttons['search'].html + '&lt;/td>' +
                        '    &lt;td>' +
                        '        &lt;input type="text" id="grid_' + this.name + '_search_all" class="w2ui-search-all" tabindex="-1" ' +
                        '            placeholder="' + w2utils.lang(this.last.caption) + '" value="' + this.last.search + '"' +
                        '            onfocus="clearTimeout(w2ui[\'' + this.name + '\'].last.kbd_timer);"' +
                        '            onkeydown="if (event.keyCode == 13 &amp;amp;&amp;amp; w2utils.isIE) this.onchange();"' +
                        '            onchange="' +
                        '                var grid = w2ui[\'' + this.name + '\']; ' +
                        '                var val = this.value; ' +
                        '                var sel = jQuery(this).data(\'selected\');' +
                        '                var fld = jQuery(this).data(\'w2field\'); ' +
                        '                if (fld) val = fld.clean(val);' +
                        '                if (fld &amp;amp;&amp;amp; fld.type == \'list\' &amp;amp;&amp;amp; sel &amp;amp;&amp;amp; typeof sel.id == \'undefined\') {' +
                        '                   grid.searchReset();' +
                        '                } else {' +
                        '                   grid.search(grid.last.field, val);' +
                        '                }' +
                        '            "/>' +
                        '    &lt;/td>' +
                        '    &lt;td>' +
                        '        &lt;div class="w2ui-search-clear" id="grid_' + this.name + '_searchClear"  ' +
                        '             onclick="var obj = w2ui[\'' + this.name + '\']; obj.searchReset();" style="display: none"' +
                        '        >&amp;#160;&amp;#160;&lt;/div>' +
                        '    &lt;/td>' +
                        '&lt;/tr>&lt;/tbody>&lt;/table>' +
                        '&lt;/div>';
                    this.toolbar.items.push({type: 'html', id: 'w2ui-search', html: html});
                }
                if (this.show.toolbarSearch &amp;&amp; this.multiSearch &amp;&amp; this.searches.length > 0) {
                    this.toolbar.items.push($.extend(true, {}, this.buttons['search-go']));
                }
                if ((this.show.toolbarSearch || this.show.toolbarInput) &amp;&amp; (this.show.toolbarAdd || this.show.toolbarEdit || this.show.toolbarDelete || this.show.toolbarSave)) {
                    this.toolbar.items.push({type: 'break', id: 'w2ui-break1'});
                }
                if (this.show.toolbarAdd) {
                    this.toolbar.items.push($.extend(true, {}, this.buttons['add']));
                }
                if (this.show.toolbarEdit) {
                    this.toolbar.items.push($.extend(true, {}, this.buttons['edit']));
                }
                if (this.show.toolbarDelete) {
                    this.toolbar.items.push($.extend(true, {}, this.buttons['delete']));
                }
                if (this.show.toolbarSave) {
                    if (this.show.toolbarAdd || this.show.toolbarDelete || this.show.toolbarEdit) {
                        this.toolbar.items.push({type: 'break', id: 'w2ui-break2'});
                    }
                    this.toolbar.items.push($.extend(true, {}, this.buttons['save']));
                }
                // add original buttons
                if (tmp_items) for (var i = 0; i &lt; tmp_items.length; i++) this.toolbar.items.push(tmp_items[i]);

                // =============================================
                // ------ Toolbar onClick processing

                var obj = this;
                this.toolbar.on('click', function (event) {
                    var edata = obj.trigger({
                        phase: 'before',
                        type: 'toolbar',
                        target: event.target,
                        originalEvent: event
                    });
                    if (edata.isCancelled === true) return;
                    var id = event.target;
                    switch (id) {
                        case 'w2ui-reload':
                            var edata2 = obj.trigger({phase: 'before', type: 'reload', target: obj.name});
                            if (edata2.isCancelled === true) return false;
                            obj.reload();
                            obj.trigger($.extend(edata2, {phase: 'after'}));
                            break;
                        case 'w2ui-column-on-off':
                            obj.initColumnOnOff();
                            obj.initResize();
                            obj.resize();
                            break;
                        case 'w2ui-search-advanced':
                            var tb = this;
                            var it = this.get(id);
                            if (it.checked) {
                                obj.searchClose();
                                setTimeout(function () {
                                    tb.uncheck(id);
                                }, 1);
                            } else {
                                obj.searchOpen();
                                event.originalEvent.stopPropagation();
                                function tmp_close() {
                                    if ($('#w2ui-overlay-' + obj.name + '-searchOverlay').data('keepOpen') === true) return;
                                    tb.uncheck(id);
                                    $(document).off('click', 'body', tmp_close);
                                }

                                $(document).on('click', 'body', tmp_close);
                            }
                            break;
                        case 'w2ui-add':
                            // events
                            var edata = obj.trigger({phase: 'before', target: obj.name, type: 'add', recid: null});
                            obj.trigger($.extend(edata, {phase: 'after'}));
                            // hide all tooltips
                            setTimeout(function () {
                                $().w2tag();
                            }, 20);
                            break;
                        case 'w2ui-edit':
                            var sel = obj.getSelection();
                            var recid = null;
                            if (sel.length == 1) recid = sel[0];
                            // events
                            var edata = obj.trigger({phase: 'before', target: obj.name, type: 'edit', recid: recid});
                            obj.trigger($.extend(edata, {phase: 'after'}));
                            // hide all tooltips
                            setTimeout(function () {
                                $().w2tag();
                            }, 20);
                            break;
                        case 'w2ui-delete':
                            obj["delete"]();
                            break;
                        case 'w2ui-save':
                            obj.save();
                            break;
                    }
                    // no default action
                    obj.trigger($.extend(edata, {phase: 'after'}));
                });
            }
        },

        initResize: function () {
            var obj = this;
            //if (obj.resizing === true) return;
            $(this.box).find('.w2ui-resizer')
                .off('click')
                .on('click', function (event) {
                    if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;
                    if (event.preventDefault) event.preventDefault();
                })
                .off('mousedown')
                .on('mousedown', function (event) {
                    if (!event) event = window.event;
                    obj.resizing = true;
                    obj.last.tmp = {
                        x: event.screenX,
                        y: event.screenY,
                        gx: event.screenX,
                        gy: event.screenY,
                        col: parseInt($(this).attr('name'))
                    };
                    if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;
                    if (event.preventDefault) event.preventDefault();
                    // fix sizes
                    for (var c = 0; c &lt; obj.columns.length; c++) {
                        if (obj.columns[c].hidden) continue;
                        if (obj.columns[c].sizeOriginal == null) obj.columns[c].sizeOriginal = obj.columns[c].size;
                        obj.columns[c].size = obj.columns[c].sizeCalculated;
                    }
                    var edata = {
                        phase: 'before',
                        type: 'columnResize',
                        target: obj.name,
                        column: obj.last.tmp.col,
                        field: obj.columns[obj.last.tmp.col].field
                    };
                    edata = obj.trigger($.extend(edata, {resizeBy: 0, originalEvent: event}));
                    // set move event
                    var mouseMove = function (event) {
                        if (obj.resizing != true) return;
                        if (!event) event = window.event;
                        // event before
                        edata = obj.trigger($.extend(edata, {
                            resizeBy: (event.screenX - obj.last.tmp.gx),
                            originalEvent: event
                        }));
                        if (edata.isCancelled === true) {
                            edata.isCancelled = false;
                            return;
                        }
                        // default action
                        obj.last.tmp.x = (event.screenX - obj.last.tmp.x);
                        obj.last.tmp.y = (event.screenY - obj.last.tmp.y);
                        obj.columns[obj.last.tmp.col].size = (parseInt(obj.columns[obj.last.tmp.col].size) + obj.last.tmp.x) + 'px';
                        obj.resizeRecords();
                        obj.scroll();
                        // reset
                        obj.last.tmp.x = event.screenX;
                        obj.last.tmp.y = event.screenY;
                    };
                    var mouseUp = function (event) {
                        delete obj.resizing;
                        $(document).off('mousemove', 'body');
                        $(document).off('mouseup', 'body');
                        obj.resizeRecords();
                        obj.scroll();
                        // event before
                        obj.trigger($.extend(edata, {phase: 'after', originalEvent: event}));
                    };
                    $(document).on('mousemove', 'body', mouseMove);
                    $(document).on('mouseup', 'body', mouseUp);
                })
                .each(function (index, el) {
                    var td = $(el).parent();
                    $(el).css({
                        "height": '25px',
                        "margin-left": (td.width() - 3) + 'px'
                    });
                });
        },

        resizeBoxes: function () {
            // elements
            var header = $('#grid_' + this.name + '_header');
            var toolbar = $('#grid_' + this.name + '_toolbar');
            var fsummary = $('#grid_' + this.name + '_fsummary');
            var summary = $('#grid_' + this.name + '_summary');
            var footer = $('#grid_' + this.name + '_footer');
            var body = $('#grid_' + this.name + '_body');

            if (this.show.header) {
                header.css({
                    top: '0px',
                    left: '0px',
                    right: '0px'
                });
            }

            if (this.show.toolbar) {
                toolbar.css({
                    top: ( 0 + (this.show.header ? w2utils.getSize(header, 'height') : 0) ) + 'px',
                    left: '0px',
                    right: '0px'
                });
            }
            if (this.summary.length > 0) {
                fsummary.css({
                    bottom: ( 0 + (this.show.footer ? w2utils.getSize(footer, 'height') : 0) ) + 'px'
                });
                summary.css({
                    bottom: ( 0 + (this.show.footer ? w2utils.getSize(footer, 'height') : 0) ) + 'px',
                    right: '0px'
                });
            }
            if (this.show.footer) {
                footer.css({
                    bottom: '0px',
                    left: '0px',
                    right: '0px'
                });
            }
            body.css({
                top: ( 0 + (this.show.header ? w2utils.getSize(header, 'height') : 0) + (this.show.toolbar ? w2utils.getSize(toolbar, 'height') : 0) ) + 'px',
                bottom: ( 0 + (this.show.footer ? w2utils.getSize(footer, 'height') : 0) + (this.summary.length > 0 ? w2utils.getSize(summary, 'height') : 0) ) + 'px',
                left: '0px',
                right: '0px'
            });
        },

        resizeRecords: function () {
            var obj = this;
            // remove empty records
            $(this.box).find('.w2ui-empty-record').remove();
            // -- Calculate Column size in PX
            var box = $(this.box);
            var grid = $(this.box).find('> div.w2ui-grid-box');
            var header = $('#grid_' + this.name + '_header');
            var toolbar = $('#grid_' + this.name + '_toolbar');
            var summary = $('#grid_' + this.name + '_summary');
            var fsummary = $('#grid_' + this.name + '_fsummary');
            var footer = $('#grid_' + this.name + '_footer');
            var body = $('#grid_' + this.name + '_body');
            var columns = $('#grid_' + this.name + '_columns');
            var fcolumns = $('#grid_' + this.name + '_fcolumns');
            var records = $('#grid_' + this.name + '_records');
            var frecords = $('#grid_' + this.name + '_frecords');
            var scroll1 = $('#grid_' + this.name + '_scroll1');
            var lineNumberWidth = String(this.total).length * 8 + 10;
            if (lineNumberWidth &lt; 34) lineNumberWidth = 34; // 3 digit width
            if (this.lineNumberWidth != null) lineNumberWidth = this.lineNumberWidth;

            var bodyOverflowX = false;
            var bodyOverflowY = false;
            var sWidth = 0;
            for (var i = 0; i &lt; obj.columns.length; i++) {
                if (obj.columns[i].frozen || obj.columns[i].hidden) continue;
                var cSize = parseInt(obj.columns[i].sizeCalculated ? obj.columns[i].sizeCalculated : obj.columns[i].size);
                sWidth += cSize;
            }
            if (records.width() &lt; sWidth) bodyOverflowX = true;
            if (body.height() - columns.height() &lt; $(records).find('>table').height() + (bodyOverflowX ? w2utils.scrollBarSize() : 0)) bodyOverflowY = true;

            // body might be expanded by data
            if (!this.fixedBody) {
                // allow it to render records, then resize
                var calculatedHeight = w2utils.getSize(columns, 'height')
                    + w2utils.getSize($('#grid_' + obj.name + '_records table'), 'height')
                    + (bodyOverflowX ? w2utils.scrollBarSize() : 0);
                obj.height = calculatedHeight
                    + w2utils.getSize(grid, '+height')
                    + (obj.show.header ? w2utils.getSize(header, 'height') : 0)
                    + (obj.show.toolbar ? w2utils.getSize(toolbar, 'height') : 0)
                    + (summary.css('display') != 'none' ? w2utils.getSize(summary, 'height') : 0)
                    + (obj.show.footer ? w2utils.getSize(footer, 'height') : 0);
                grid.css('height', obj.height);
                body.css('height', calculatedHeight);
                box.css('height', w2utils.getSize(grid, 'height') + w2utils.getSize(box, '+height'));
            } else {
                // fixed body height
                var calculatedHeight = grid.height()
                    - (this.show.header ? w2utils.getSize(header, 'height') : 0)
                    - (this.show.toolbar ? w2utils.getSize(toolbar, 'height') : 0)
                    - (summary.css('display') != 'none' ? w2utils.getSize(summary, 'height') : 0)
                    - (this.show.footer ? w2utils.getSize(footer, 'height') : 0);
                body.css('height', calculatedHeight);
            }

            var buffered = this.records.length;
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (this.searchData.length != 0 &amp;&amp; !url) buffered = this.last.searchIds.length;
            // apply overflow
            if (!this.fixedBody) {
                bodyOverflowY = false;
            }
            if (bodyOverflowX || bodyOverflowY) {
                columns.find('> table > tbody > tr:nth-child(1) td.w2ui-head-last').css('width', w2utils.scrollBarSize()).show();
                records.css({
                    top: ((this.columnGroups.length > 0 &amp;&amp; this.show.columns ? 1 : 0) + w2utils.getSize(columns, 'height')) + 'px',
                    "-webkit-overflow-scrolling": "touch",
                    "overflow-x": (bodyOverflowX ? 'auto' : 'hidden'),
                    "overflow-y": (bodyOverflowY ? 'auto' : 'hidden')
                });
            } else {
                columns.find('> table > tbody > tr:nth-child(1) td.w2ui-head-last').hide();
                records.css({
                    top: ((this.columnGroups.length > 0 &amp;&amp; this.show.columns ? 1 : 0) + w2utils.getSize(columns, 'height')) + 'px',
                    overflow: 'hidden'
                });
                if (records.length > 0) {
                    this.last.scrollTop = 0;
                    this.last.scrollLeft = 0;
                } // if no scrollbars, always show top
            }
            if (bodyOverflowX) {
                frecords.css('margin-bottom', w2utils.scrollBarSize());
                scroll1.show();
            } else {
                frecords.css('margin-bottom', 0);
                scroll1.hide();
            }
            frecords.css({overflow: 'hidden', top: records.css('top')});
            if (this.show.emptyRecords &amp;&amp; !bodyOverflowY) {
                var max = Math.floor(records.height() / this.recordHeight) - 1;
                var leftover = 0;
                if (records[0]) leftover = records[0].scrollHeight - max * this.recordHeight;
                if (leftover >= this.recordHeight) {
                    leftover -= this.recordHeight;
                    max++;
                }
                if (this.fixedBody) {
                    for (var di = buffered; di &lt; max; di++) {
                        addEmptyRow(di, this.recordHeight, this);
                    }
                    addEmptyRow(max, leftover, this);
                }
            }

            function addEmptyRow(row, height, grid) {
                var html1 = '';
                var html2 = '';
                var htmlp = '';
                html1 += '&lt;tr class="' + (row % 2 ? 'w2ui-even' : 'w2ui-odd') + ' w2ui-empty-record" style="height: ' + height + 'px">';
                html2 += '&lt;tr class="' + (row % 2 ? 'w2ui-even' : 'w2ui-odd') + ' w2ui-empty-record" style="height: ' + height + 'px">';
                if (grid.show.lineNumbers) html1 += '&lt;td class="w2ui-col-number">&lt;/td>';
                if (grid.show.selectColumn) html1 += '&lt;td class="w2ui-grid-data w2ui-col-select">&lt;/td>';
                if (grid.show.expandColumn) html1 += '&lt;td class="w2ui-grid-data w2ui-col-expand">&lt;/td>';
                html2 += '&lt;td class="w2ui-grid-data-spacer" col="start" style="border-right: 0">&lt;/td>';
                for (var j = 0; j &lt; grid.columns.length; j++) {
                    var col = grid.columns[j];
                    if ((col.hidden || j &lt; grid.last.colStart || j > grid.last.colEnd) &amp;&amp; !col.frozen) continue;
                    htmlp = '&lt;td class="w2ui-grid-data" ' + (col.attr != null ? col.attr : '') + ' col="' + j + '">&lt;/td>';
                    if (col.frozen) html1 += htmlp; else html2 += htmlp;
                }
                html1 += '&lt;td class="w2ui-grid-data-last">&lt;/td> &lt;/tr>';
                html2 += '&lt;td class="w2ui-grid-data-last" col="end">&lt;/td> &lt;/tr>';
                $('#grid_' + grid.name + '_frecords > table').append(html1);
                $('#grid_' + grid.name + '_records > table').append(html2);
            }

            if (body.length > 0) {
                var width_max = parseInt(body.width())
                    - (bodyOverflowY ? w2utils.scrollBarSize() : 0)
                    - (this.show.lineNumbers ? lineNumberWidth : 0)
                    - (this.show.selectColumn ? 26 : 0)
                    - (this.show.expandColumn ? 26 : 0)
                    - 1; // left is 1xp due to border width
                var width_box = width_max;
                var percent = 0;
                // gridMinWidth processiong
                var restart = false;
                for (var i = 0; i &lt; this.columns.length; i++) {
                    var col = this.columns[i];
                    if (col.gridMinWidth > 0) {
                        if (col.gridMinWidth > width_box &amp;&amp; col.hidden !== true) {
                            col.hidden = true;
                            restart = true;
                        }
                        if (col.gridMinWidth &lt; width_box &amp;&amp; col.hidden === true) {
                            col.hidden = false;
                            restart = true;
                        }
                    }
                }
                if (restart === true) {
                    this.refresh();
                    return;
                }
                // assign PX column s
                for (var i = 0; i &lt; this.columns.length; i++) {
                    var col = this.columns[i];
                    if (col.hidden) continue;
                    if (String(col.size).substr(String(col.size).length - 2).toLowerCase() == 'px') {
                        width_max -= parseFloat(col.size);
                        this.columns[i].sizeCalculated = col.size;
                        this.columns[i].sizeType = 'px';
                    } else {
                        percent += parseFloat(col.size);
                        this.columns[i].sizeType = '%';
                        delete col.sizeCorrected;
                    }
                }
                // if sum != 100% -- reassign proportionally
                if (percent != 100 &amp;&amp; percent > 0) {
                    for (var i = 0; i &lt; this.columns.length; i++) {
                        var col = this.columns[i];
                        if (col.hidden) continue;
                        if (col.sizeType == '%') {
                            col.sizeCorrected = Math.round(parseFloat(col.size) * 100 * 100 / percent) / 100 + '%';
                        }
                    }
                }
                // calculate % columns
                for (var i = 0; i &lt; this.columns.length; i++) {
                    var col = this.columns[i];
                    if (col.hidden) continue;
                    if (col.sizeType == '%') {
                        if (this.columns[i].sizeCorrected != null) {
                            // make it 1px smaller, so margin of error can be calculated correctly
                            this.columns[i].sizeCalculated = Math.floor(width_max * parseFloat(col.sizeCorrected) / 100) - 1 + 'px';
                        } else {
                            // make it 1px smaller, so margin of error can be calculated correctly
                            this.columns[i].sizeCalculated = Math.floor(width_max * parseFloat(col.size) / 100) - 1 + 'px';
                        }
                    }
                }
            }
            // fix margin of error that is due percentage calculations
            var width_cols = 0;
            for (var i = 0; i &lt; this.columns.length; i++) {
                var col = this.columns[i];
                if (col.hidden) continue;
                if (col.min == null) col.min = 20;
                if (parseInt(col.sizeCalculated) &lt; parseInt(col.min)) col.sizeCalculated = col.min + 'px';
                if (parseInt(col.sizeCalculated) > parseInt(col.max)) col.sizeCalculated = col.max + 'px';
                width_cols += parseInt(col.sizeCalculated);
            }
            var width_diff = parseInt(width_box) - parseInt(width_cols);
            if (width_diff > 0 &amp;&amp; percent > 0) {
                var i = 0;
                while (true) {
                    var col = this.columns[i];
                    if (col == null) {
                        i = 0;
                        continue;
                    }
                    if (col.hidden || col.sizeType == 'px') {
                        i++;
                        continue;
                    }
                    col.sizeCalculated = (parseInt(col.sizeCalculated) + 1) + 'px';
                    width_diff--;
                    if (width_diff === 0) break;
                    i++;
                }
            } else if (width_diff > 0) {
                columns.find('> table > tbody > tr:nth-child(1) td.w2ui-head-last').css('width', w2utils.scrollBarSize()).show();
            }

            // find width of frozen columns
            var fwidth = 1;
            if (this.show.lineNumbers) fwidth += lineNumberWidth;
            if (this.show.selectColumn) fwidth += 26;
            if (this.show.expandColumn) fwidth += 26;
            for (var i = 0; i &lt; this.columns.length; i++) {
                if (this.columns[i].hidden) continue;
                if (this.columns[i].frozen) fwidth += parseInt(this.columns[i].sizeCalculated);
            }
            fcolumns.css('width', fwidth);
            frecords.css('width', fwidth);
            fsummary.css('width', fwidth);
            scroll1.css('width', fwidth);
            columns.css('left', fwidth);
            records.css('left', fwidth);
            summary.css('left', fwidth);

            // resize columns
            columns.find('> table > tbody > tr:nth-child(1) td')
                .add(fcolumns.find('> table > tbody > tr:nth-child(1) td'))
                .each(function (index, el) {
                    // line numbers
                    if ($(el).hasClass('w2ui-col-number')) {
                        $(el).css('width', lineNumberWidth);
                    }
                    // records
                    var ind = $(el).attr('col');
                    if (ind != null) {
                        if (ind == 'start') {
                            var width = 0;
                            for (var i = 0; i &lt; obj.last.colStart; i++) {
                                if (!obj.columns[i] || obj.columns[i].frozen || obj.columns[i].hidden) continue;
                                width += parseInt(obj.columns[i].sizeCalculated);
                            }
                            $(el).css('width', width + 'px');
                        }
                        if (obj.columns[ind]) $(el).css('width', obj.columns[ind].sizeCalculated);
                    }
                    // last column
                    if ($(el).hasClass('w2ui-head-last')) {
                        if (obj.last.colEnd + 1 &lt; obj.columns.length) {
                            var width = 0;
                            for (var i = obj.last.colEnd + 1; i &lt; obj.columns.length; i++) {
                                if (!obj.columns[i] || obj.columns[i].frozen || obj.columns[i].hidden) continue;
                                width += parseInt(obj.columns[i].sizeCalculated);
                            }
                            $(el).css('width', width + 'px');
                        } else {
                            $(el).css('width', w2utils.scrollBarSize() + (width_diff > 0 &amp;&amp; percent === 0 ? width_diff : 0) + 'px');
                        }
                    }
                });
            // if there are column groups - hide first row (needed for sizing)
            if (columns.find('> table > tbody > tr').length == 3) {
                columns.find('> table > tbody > tr:nth-child(1) td')
                    .add(fcolumns.find('> table > tbody > tr:nth-child(1) td'))
                    .html('').css({
                    'height': '0px',
                    'border': '0px',
                    'padding': '0px',
                    'margin': '0px'
                });
            }
            // resize records
            records.find('> table > tbody > tr:nth-child(1) td')
                .add(frecords.find('> table > tbody > tr:nth-child(1) td'))
                .each(function (index, el) {
                    // line numbers
                    if ($(el).hasClass('w2ui-col-number')) {
                        $(el).css('width', lineNumberWidth);
                    }
                    // records
                    var ind = $(el).attr('col');
                    if (ind != null) {
                        if (ind == 'start') {
                            var width = 0;
                            for (var i = 0; i &lt; obj.last.colStart; i++) {
                                if (!obj.columns[i] || obj.columns[i].frozen || obj.columns[i].hidden) continue;
                                width += parseInt(obj.columns[i].sizeCalculated);
                            }
                            $(el).css('width', width + 'px');
                        }
                        if (obj.columns[ind]) $(el).css('width', obj.columns[ind].sizeCalculated);
                    }
                    // last column
                    if ($(el).hasClass('w2ui-grid-data-last') &amp;&amp; $(el).parents('.w2ui-grid-frecords').length === 0) { // not in frecords
                        if (obj.last.colEnd + 1 &lt; obj.columns.length) {
                            var width = 0;
                            for (var i = obj.last.colEnd + 1; i &lt; obj.columns.length; i++) {
                                if (!obj.columns[i] || obj.columns[i].frozen || obj.columns[i].hidden) continue;
                                width += parseInt(obj.columns[i].sizeCalculated);
                            }
                            $(el).css('width', width + 'px');
                        } else {
                            $(el).css('width', (width_diff > 0 &amp;&amp; percent === 0 ? width_diff : 0) + 'px');
                        }
                    }
                });
            // resize summary
            summary.find('> table > tbody > tr:nth-child(1) td')
                .add(fsummary.find('> table > tbody > tr:nth-child(1) td'))
                .each(function (index, el) {
                    // line numbers
                    if ($(el).hasClass('w2ui-col-number')) {
                        $(el).css('width', lineNumberWidth);
                    }
                    // records
                    var ind = $(el).attr('col');
                    if (ind != null) {
                        if (ind == 'start') {
                            var width = 0;
                            for (var i = 0; i &lt; obj.last.colStart; i++) {
                                if (!obj.columns[i] || obj.columns[i].frozen || obj.columns[i].hidden) continue;
                                width += parseInt(obj.columns[i].sizeCalculated);
                            }
                            $(el).css('width', width + 'px');
                        }
                        if (obj.columns[ind]) $(el).css('width', obj.columns[ind].sizeCalculated);
                    }
                    // last column
                    if ($(el).hasClass('w2ui-grid-data-last') &amp;&amp; $(el).parents('.w2ui-grid-frecords').length === 0) { // not in frecords
                        $(el).css('width', w2utils.scrollBarSize() + (width_diff > 0 &amp;&amp; percent === 0 ? width_diff : 0) + 'px');
                    }
                });
            this.initResize();
            this.refreshRanges();
            // apply last scroll if any
            if ((this.last.scrollTop || this.last.scrollLeft) &amp;&amp; records.length > 0) {
                columns.prop('scrollLeft', this.last.scrollLeft);
                records.prop('scrollTop', this.last.scrollTop);
                records.prop('scrollLeft', this.last.scrollLeft);
            }
        },

        getSearchesHTML: function () {
            var obj = this;
            var html = '&lt;table cellspacing="0" onclick="event.stopPropagation()">&lt;tbody>';
            var showBtn = false;
            for (var i = 0; i &lt; this.searches.length; i++) {
                var s = this.searches[i];
                s.type = String(s.type).toLowerCase();
                if (s.hidden) continue;
                var btn = '';
                if (showBtn == false) {
                    btn = '&lt;button class="w2ui-btn close-btn" onclick="obj = w2ui[\'' + this.name + '\']; if (obj) obj.searchClose()">X&lt;/button>';
                    showBtn = true;
                }
                if (s.inTag == null) s.inTag = '';
                if (s.outTag == null) s.outTag = '';
                if (s.style == null) s.style = '';
                if (s.type == null) s.type = 'text';

                var operator =
                    '&lt;select id="grid_' + this.name + '_operator_' + i + '" class="w2ui-input" onclick="event.stopPropagation();"' +
                    '   onchange="w2ui[\'' + this.name + '\'].initOperator(this, ' + i + ')">' +
                    getOperators(s.type, s.operators) +
                    '&lt;/select>';

                html += '&lt;tr>' +
                    '    &lt;td class="close-btn">' + btn + '&lt;/td>' +
                    '    &lt;td class="caption">' + (s.caption || '') + '&lt;/td>' +
                    '    &lt;td class="operator">' + operator + '&lt;/td>' +
                    '    &lt;td class="value">';

                switch (s.type) {
                    case 'text':
                    case 'alphanumeric':
                    case 'hex':
                    case 'color':
                    case 'list':
                    case 'combo':
                    case 'enum':
                        var tmpStyle = 'width: 250px;';
                        if (['hex', 'color'].indexOf(s.type) != -1) tmpStyle = 'width: 90px;';
                        html += '&lt;input rel="search" type="text" id="grid_' + this.name + '_field_' + i + '" name="' + s.field + '" ' +
                            '   class="w2ui-input" style="' + tmpStyle + s.style + '" ' + s.inTag + '/>';
                        break;

                    case 'int':
                    case 'float':
                    case 'money':
                    case 'currency':
                    case 'percent':
                    case 'date':
                    case 'time':
                    case 'datetime':
                        var tmpStyle = 'width: 90px';
                        if (s.type == 'datetime') tmpStyle = 'width: 140px;';
                        html += '&lt;input rel="search" type="text" class="w2ui-input" style="' + tmpStyle + s.style + '" id="grid_' + this.name + '_field_' + i + '" name="' + s.field + '" ' + s.inTag + '/>' +
                            '&lt;span id="grid_' + this.name + '_range_' + i + '" style="display: none">&amp;#160;-&amp;#160;&amp;#160;' +
                            '&lt;input rel="search" type="text" class="w2ui-input" style="' + tmpStyle + s.style + '" id="grid_' + this.name + '_field2_' + i + '" name="' + s.field + '" ' + s.inTag + '/>' +
                            '&lt;/span>';
                        break;

                    case 'select':
                        html += '&lt;select rel="search" class="w2ui-input" style="' + s.style + '" id="grid_' + this.name + '_field_' + i + '" ' +
                            ' name="' + s.field + '" ' + s.inTag + '  onclick="event.stopPropagation();">&lt;/select>';
                        break;

                }
                html += s.outTag +
                    '    &lt;/td>' +
                    '&lt;/tr>';
            }
            html += '&lt;tr>' +
                '    &lt;td colspan="4" class="actions">' +
                '        &lt;div>' +
                '        &lt;button class="w2ui-btn" onclick="obj = w2ui[\'' + this.name + '\']; if (obj) { obj.searchReset(); }">' + w2utils.lang('Reset') + '&lt;/button>' +
                '        &lt;button class="w2ui-btn w2ui-btn-blue" onclick="obj = w2ui[\'' + this.name + '\']; if (obj) { obj.search(); }">' + w2utils.lang('Search') + '&lt;/button>' +
                '        &lt;/div>' +
                '    &lt;/td>' +
                '&lt;/tr>&lt;/tbody>&lt;/table>';
            return html;

            function getOperators(type, fieldOperators) {
                var html = '';
                var operators = obj.operators[obj.operatorsMap[type]];
                if (fieldOperators != null) operators = fieldOperators;
                for (var i = 0; i &lt; operators.length; i++) {
                    var oper = operators[i];
                    var text = oper;
                    if (Array.isArray(oper)) {
                        text = oper[1];
                        oper = oper[0];
                        if (text == null) text = oper;
                    } else if ($.isPlainObject(oper)) {
                        text = oper.text;
                        oper = oper.oper;
                    }
                    html += '&lt;option value="' + oper + '">' + w2utils.lang(text) + '&lt;/option>\n';
                }
                return html;
            }
        },

        initOperator: function (el, search_ind) {
            var obj = this;
            var search = obj.searches[search_ind];
            var range = $('#grid_' + obj.name + '_range_' + search_ind);
            var fld1 = $('#grid_' + obj.name + '_field_' + search_ind);
            var fld2 = fld1.parent().find('span input');
            fld1.show();
            range.hide();
            // fld1.w2field(search.type);
            switch ($(el).val()) {
//                case 'in':
//                case 'not in':
//                    fld1.w2field('clear');
//                    break;
                case 'between':
                    range.show();
                    fld2.w2field(search.type, search.options);
                    break;
                case 'not null':
                case 'null':
                    fld1.hide();
                    fld1.val('1'); // need to insert something for search to activate
                    fld1.change();
                    break;
            }
        },

        initSearches: function () {
            var obj = this;
            // init searches
            for (var s = 0; s &lt; this.searches.length; s++) {
                var search = this.searches[s];
                var sdata = this.getSearchData(search.field);
                search.type = String(search.type).toLowerCase();
                var operators = obj.operators[obj.operatorsMap[search.type]];
                if (search.operators) operators = search.operators;
                var operator = operators[0]; // default operator
                if ($.isPlainObject(operator)) operator = operator.oper;
                if (typeof search.options != 'object') search.options = {};
                if (search.type == 'text') operator = 'begins'; // default operator for text
                // only accept search.operator if it is valid
                for (var i = 0; i &lt; operators.length; i++) {
                    var oper = operators[i];
                    if ($.isPlainObject(oper)) oper = oper.oper;
                    if (search.operator == oper) {
                        operator = search.operator;
                        break;
                    }
                }
                // init types
                switch (search.type) {
                    case 'text':
                    case 'alphanumeric':
                        $('#grid_' + this.name + '_field_' + s).w2field(search.type, search.options);
                        break;

                    case 'int':
                    case 'float':
                    case 'hex':
                    case 'color':
                    case 'money':
                    case 'currency':
                    case 'percent':
                    case 'date':
                    case 'time':
                    case 'datetime':
                        $('#grid_' + this.name + '_field_' + s).w2field(search.type, search.options);
                        $('#grid_' + this.name + '_field2_' + s).w2field(search.type, search.options);
                        setTimeout(function () { // convert to date if it is number
                            $('#grid_' + obj.name + '_field_' + s).keydown();
                            $('#grid_' + obj.name + '_field2_' + s).keydown();
                        }, 1);
                        break;

                    case 'list':
                    case 'combo':
                    case 'enum':
                        var options = search.options;
                        if (search.type == 'list') options.selected = {};
                        if (search.type == 'enum') options.selected = [];
                        if (sdata) options.selected = sdata.value;
                        $('#grid_' + this.name + '_field_' + s).w2field(search.type, $.extend({openOnFocus: true}, options));
                        if (sdata &amp;&amp; sdata.text != null) $('#grid_' + this.name + '_field_' + s).data('selected', {
                            id: sdata.value,
                            text: sdata.text
                        });
                        break;

                    case 'select':
                        // build options
                        var options = '&lt;option value="">--&lt;/option>';
                        for (var i = 0; i &lt; search.options.items.length; i++) {
                            var si = search.options.items[i];
                            if ($.isPlainObject(search.options.items[i])) {
                                var val = si.id;
                                var txt = si.text;
                                if (val == null &amp;&amp; si.value != null) val = si.value;
                                if (txt == null &amp;&amp; si.caption != null) txt = si.caption;
                                if (val == null) val = '';
                                options += '&lt;option value="' + val + '">' + txt + '&lt;/option>';
                            } else {
                                options += '&lt;option value="' + si + '">' + si + '&lt;/option>';
                            }
                        }
                        $('#grid_' + this.name + '_field_' + s).html(options);
                        break;
                }
                if (sdata != null) {
                    if (sdata.type == 'int' &amp;&amp; ['in', 'not in'].indexOf(sdata.operator) != -1) {
                        $('#grid_' + this.name + '_field_' + s).w2field('clear').val(sdata.value);
                    }
                    $('#grid_' + this.name + '_operator_' + s).val(sdata.operator).trigger('change');
                    if (!$.isArray(sdata.value)) {
                        if (sdata.value != null) $('#grid_' + this.name + '_field_' + s).val(sdata.value).trigger('change');
                    } else {
                        if (['in', 'not in'].indexOf(sdata.operator) != -1) {
                            $('#grid_' + this.name + '_field_' + s).val(sdata.value).trigger('change');
                        } else {
                            $('#grid_' + this.name + '_field_' + s).val(sdata.value[0]).trigger('change');
                            $('#grid_' + this.name + '_field2_' + s).val(sdata.value[1]).trigger('change');
                        }
                    }
                } else {
                    $('#grid_' + this.name + '_operator_' + s).val(operator).trigger('change');
                }
            }
            // add on change event
            $('#w2ui-overlay-' + this.name + '-searchOverlay .w2ui-grid-searches *[rel=search]').on('keypress', function (evnt) {
                if (evnt.keyCode == 13) {
                    obj.search();
                    $().w2overlay({name: obj.name + '-searchOverlay'});
                }
            });
        },

        getColumnsHTML: function () {
            var obj = this;
            var html1 = '';
            var html2 = '';
            if (this.show.columnHeaders) {
                if (this.columnGroups.length > 0) {
                    var tmp1 = getColumns(true);
                    var tmp2 = getGroups();
                    var tmp3 = getColumns(false);
                    html1 = tmp1[0] + tmp2[0] + tmp3[0];
                    html2 = tmp1[1] + tmp2[1] + tmp3[1];
                } else {
                    var tmp = getColumns(true);
                    html1 = tmp[0];
                    html2 = tmp[1];
                }
            }
            return [html1, html2];

            function getGroups() {
                var html1 = '&lt;tr>';
                var html2 = '&lt;tr>';
                var tmpf = '';
                // add empty group at the end
                if (obj.columnGroups[obj.columnGroups.length - 1].caption != '') obj.columnGroups.push({caption: ''});

                if (obj.show.lineNumbers) {
                    html1 += '&lt;td class="w2ui-head w2ui-col-number">' +
                        '    &lt;div style="height: ' + (obj.recordHeight + 1) + 'px">&amp;#160;&lt;/div>' +
                        '&lt;/td>';
                }
                if (obj.show.selectColumn) {
                    html1 += '&lt;td class="w2ui-head w2ui-col-select">' +
                        '    &lt;div style="height: 25px">&amp;#160;&lt;/div>' +
                        '&lt;/td>';
                }
                if (obj.show.expandColumn) {
                    html1 += '&lt;td class="w2ui-head w2ui-col-expand">' +
                        '    &lt;div style="height: 25px">&amp;#160;&lt;/div>' +
                        '&lt;/td>';
                }
                var ii = 0;
                html2 += '&lt;td id="grid_' + obj.name + '_column_start" class="w2ui-head" col="start" style="border-right: 0">&lt;/td>';
                for (var i = 0; i &lt; obj.columnGroups.length; i++) {
                    var colg = obj.columnGroups[i];
                    var col = obj.columns[ii];
                    if (colg.colspan != null) colg.span = colg.colspan;
                    if (colg.span == null || colg.span != parseInt(colg.span)) colg.span = 1;
                    var colspan = 0;
                    for (var jj = ii; jj &lt; ii + colg.span; jj++) {
                        if (obj.columns[jj] &amp;&amp; !obj.columns[jj].hidden)
                            colspan++;
                    }
                    if (i == obj.columnGroups.length - 1)
                        colspan++;      // XXX
                    if (colspan &lt;= 0) {
                        // do nothing here, all columns in the group are hidden.
                    } else if (colg.master === true) {
                        var sortStyle = '';
                        for (var si = 0; si &lt; obj.sortData.length; si++) {
                            if (obj.sortData[si].field == col.field) {
                                if (new RegExp('asc', 'i').test(obj.sortData[si].direction)) sortStyle = 'w2ui-sort-up';
                                if (new RegExp('desc', 'i').test(obj.sortData[si].direction)) sortStyle = 'w2ui-sort-down';
                            }
                        }
                        var resizer = "";
                        if (col.resizable !== false) {
                            resizer = '&lt;div class="w2ui-resizer" name="' + ii + '">&lt;/div>';
                        }
                        tmpf = '&lt;td id="grid_' + obj.name + '_column_' + ii + '" class="w2ui-head ' + sortStyle + '" col="' + ii + '" ' +
                            '    rowspan="2" colspan="' + colspan + '" ' +
                            '    oncontextmenu = "w2ui[\'' + obj.name + '\'].contextMenu(null, ' + ii + ', event);"' +
                            '    onclick="w2ui[\'' + obj.name + '\'].columnClick(\'' + col.field + '\', event);"' +
                            '    ondblclick="w2ui[\'' + obj.name + '\'].columnDblClick(\'' + col.field + '\', event);">' +
                            resizer +
                            '    &lt;div class="w2ui-col-group w2ui-col-header ' + (sortStyle ? 'w2ui-col-sorted' : '') + '">' +
                            '        &lt;div class="' + sortStyle + '">&lt;/div>' +
                            (!col.caption ? '&amp;#160;' : col.caption) +
                            '    &lt;/div>' +
                            '&lt;/td>';
                        if (col &amp;&amp; col.frozen) html1 += tmpf; else html2 += tmpf;
                    } else {
                        tmpf = '&lt;td id="grid_' + obj.name + '_column_' + ii + '" class="w2ui-head" col="' + ii + '" ' +
                            '        colspan="' + colspan + '">' +
                            '    &lt;div class="w2ui-col-group">' +
                            (!colg.caption ? '&amp;#160;' : colg.caption) +
                            '    &lt;/div>' +
                            '&lt;/td>';
                        if (col &amp;&amp; col.frozen) html1 += tmpf; else html2 += tmpf;
                    }
                    ii += colg.span;
                }
                html1 += '&lt;td>&lt;/td>&lt;/tr>'; // need empty column for border-right
                html2 += '&lt;td id="grid_' + obj.name + '_column_end" class="w2ui-head" col="end">&lt;/td>&lt;/tr>';
                return [html1, html2];
            }

            function getColumns(master) {
                var html1 = '&lt;tr>';
                var html2 = '&lt;tr>';
                if (obj.show.lineNumbers) {
                    html1 += '&lt;td class="w2ui-head w2ui-col-number" ' +
                        '       onclick="w2ui[\'' + obj.name + '\'].columnClick(\'line-number\', event);"' +
                        '       ondblclick="w2ui[\'' + obj.name + '\'].columnDblClick(\'line-number\', event);">' +
                        '    &lt;div>#&lt;/div>' +
                        '&lt;/td>';
                }
                if (obj.show.selectColumn) {
                    html1 += '&lt;td class="w2ui-head w2ui-col-select"' +
                        '       onclick="if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;">' +
                        '    &lt;div>' +
                        '        &lt;input type="checkbox" id="grid_' + obj.name + '_check_all" tabindex="-1"' +
                        '            style="' + (obj.multiSelect == false ? 'display: none;' : '') + '"' +
                        '            onmousedown="if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;"' +
                        '            onclick="var grid = w2ui[\'' + obj.name + '\'];' +
                        '               if (this.checked) grid.selectAll(); else grid.selectNone();' +
                        '               if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;' +
                        '               clearTimeout(grid.last.kbd_timer); /* keep focus */' +
                        '            "/>' +
                        '    &lt;/div>' +
                        '&lt;/td>';
                }
                if (obj.show.expandColumn) {
                    html1 += '&lt;td class="w2ui-head w2ui-col-expand">' +
                        '    &lt;div>&amp;#160;&lt;/div>' +
                        '&lt;/td>';
                }
                var ii = 0;
                var id = 0;
                var colg;
                html2 += '&lt;td id="grid_' + obj.name + '_column_start" class="w2ui-head" col="start" style="border-right: 0">&lt;/td>';
                for (var i = 0; i &lt; obj.columns.length; i++) {
                    var col = obj.columns[i];
                    if (i == id) {      // always true on first iteration
                        colg = obj.columnGroups[ii++] || {};
                        id = id + colg.span;
                    }
                    if ((i &lt; obj.last.colStart || i > obj.last.colEnd) &amp;&amp; !col.frozen)
                        continue;
                    if (col.hidden)
                        continue;
                    if (colg.master !== true || master) { // grouping of columns
                        var colCellHTML = obj.getColumnCellHTML(i);
                        if (col &amp;&amp; col.frozen) html1 += colCellHTML; else html2 += colCellHTML;
                    }
                }
                html1 += '&lt;td class="w2ui-head w2ui-head-last">&lt;div>&amp;#160;&lt;/div>&lt;/td>';
                html2 += '&lt;td class="w2ui-head w2ui-head-last" col="end">&lt;div>&amp;#160;&lt;/div>&lt;/td>';
                html1 += '&lt;/tr>';
                html2 += '&lt;/tr>';
                return [html1, html2];
            }
        },

        getColumnCellHTML: function (i) {
            var col = this.columns[i];
            if (col == null) return '';
            // reorder style
            var reorderCols = (this.reorderColumns &amp;&amp; (!this.columnGroups || !this.columnGroups.length)) ? ' w2ui-reorder-cols-head ' : '';
            // sort style
            var sortStyle = '';
            for (var si = 0; si &lt; this.sortData.length; si++) {
                if (this.sortData[si].field == col.field) {
                    if (new RegExp('asc', 'i').test(this.sortData[si].direction)) sortStyle = 'w2ui-sort-up';
                    if (new RegExp('desc', 'i').test(this.sortData[si].direction)) sortStyle = 'w2ui-sort-down';
                }
            }
            // col selected
            var tmp = this.last.selection.columns;
            var selected = false;
            for (var t in tmp) {
                for (var si = 0; si &lt; tmp[t].length; si++) {
                    if (tmp[t][si] == i) selected = true;
                }
            }
            var html = '&lt;td id="grid_' + this.name + '_column_' + i + '" col="' + i + '" class="w2ui-head ' + sortStyle + reorderCols + '" ' +
                (this.columnTooltip == 'normal' &amp;&amp; col.tooltip ? 'title="' + col.tooltip + '" ' : '') +
                '    onmouseover = "w2ui[\'' + this.name + '\'].columnTooltipShow(\'' + i + '\', event);"' +
                '    onmouseout  = "w2ui[\'' + this.name + '\'].columnTooltipHide(\'' + i + '\', event);"' +
                '    oncontextmenu = "w2ui[\'' + this.name + '\'].contextMenu(null, ' + i + ', event);"' +
                '    onclick="w2ui[\'' + this.name + '\'].columnClick(\'' + col.field + '\', event);"' +
                '    ondblclick="w2ui[\'' + this.name + '\'].columnDblClick(\'' + col.field + '\', event);">' +
                (col.resizable !== false ? '&lt;div class="w2ui-resizer" name="' + i + '">&lt;/div>' : '') +
                '    &lt;div class="w2ui-col-header ' + (sortStyle ? 'w2ui-col-sorted' : '') + ' ' + (selected ? 'w2ui-col-selected' : '') + '">' +
                '        &lt;div class="' + sortStyle + '">&lt;/div>' +
                (!col.caption ? '&amp;#160;' : col.caption) +
                '    &lt;/div>' +
                '&lt;/td>';

            return html
        },

        columnTooltipShow: function (ind) {
            if (this.columnTooltip == 'normal') return;
            var $el = $(this.box).find('#grid_' + this.name + '_column_' + ind);
            var item = this.columns[ind];
            var pos = this.columnTooltip;
            $el.prop('_mouse_over', true);
            setTimeout(function () {
                if ($el.prop('_mouse_over') === true &amp;&amp; $el.prop('_mouse_tooltip') !== true) {
                    $el.prop('_mouse_tooltip', true);
                    // show tooltip
                    $el.w2tag(item.tooltip, {position: pos});
                }
            }, 1);
        },

        columnTooltipHide: function (ind) {
            if (this.columnTooltip == 'normal') return;
            var $el = $(this.box).find('#grid_' + this.name + '_column_' + ind);
            var item = this.columns[ind];
            $el.removeProp('_mouse_over');
            setTimeout(function () {
                if ($el.prop('_mouse_over') !== true &amp;&amp; $el.prop('_mouse_tooltip') === true) {
                    $el.removeProp('_mouse_tooltip');
                    // hide tooltip
                    $el.w2tag();
                }
            }, 1);
        },

        getRecordsHTML: function () {
            var buffered = this.records.length;
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (this.searchData.length != 0 &amp;&amp; !url) buffered = this.last.searchIds.length;
            // larger number works better with chrome, smaller with FF.
            if (buffered > this.vs_start) this.last.show_extra = this.vs_extra; else this.last.show_extra = this.vs_start;
            var records = $('#grid_' + this.name + '_records');
            var limit = Math.floor(records.height() / this.recordHeight) + this.last.show_extra + 1;
            if (!this.fixedBody || limit > buffered) limit = buffered;
            // always need first record for resizing purposes
            var rec_html = this.getRecordHTML(-1, 0);
            var html1 = '&lt;table>&lt;tbody>' + rec_html[0];
            var html2 = '&lt;table>&lt;tbody>' + rec_html[1];
            // first empty row with height
            html1 += '&lt;tr id="grid_' + this.name + '_frec_top" line="top" style="height: ' + 0 + 'px">' +
                '    &lt;td colspan="2000">&lt;/td>' +
                '&lt;/tr>';
            html2 += '&lt;tr id="grid_' + this.name + '_rec_top" line="top" style="height: ' + 0 + 'px">' +
                '    &lt;td colspan="2000">&lt;/td>' +
                '&lt;/tr>';
            for (var i = 0; i &lt; limit; i++) {
                rec_html = this.getRecordHTML(i, i + 1);
                html1 += rec_html[0];
                html2 += rec_html[1];
            }
            html1 += '&lt;tr id="grid_' + this.name + '_frec_bottom" line="bottom" style="height: ' + ((buffered - limit) * this.recordHeight) + 'px">' +
                '    &lt;td colspan="2000" style="border: 0">&lt;/td>' +
                '&lt;/tr>' +
                '&lt;tr id="grid_' + this.name + '_frec_more" style="display: none; visibility: hidden">' +
                '    &lt;td colspan="2000" class="w2ui-load-more">&lt;/td>' +
                '&lt;/tr>' +
                '&lt;/tbody>&lt;/table>';
            html2 += '&lt;tr id="grid_' + this.name + '_rec_bottom" line="bottom" style="height: ' + ((buffered - limit) * this.recordHeight) + 'px">' +
                '    &lt;td colspan="2000" style="border: 0">&lt;/td>' +
                '&lt;/tr>' +
                '&lt;tr id="grid_' + this.name + '_rec_more" style="display: none">' +
                '    &lt;td colspan="2000" class="w2ui-load-more">&lt;/td>' +
                '&lt;/tr>' +
                '&lt;/tbody>&lt;/table>';
            this.last.range_start = 0;
            this.last.range_end = limit;
            return [html1, html2];
        },

        getSummaryHTML: function () {
            if (this.summary.length === 0) return;
            var rec_html = this.getRecordHTML(-1, 0); // need this in summary too for colspan to work properly
            var html1 = '&lt;table>&lt;tbody>' + rec_html[0];
            var html2 = '&lt;table>&lt;tbody>' + rec_html[1];
            for (var i = 0; i &lt; this.summary.length; i++) {
                rec_html = this.getRecordHTML(i, i + 1, true);
                html1 += rec_html[0];
                html2 += rec_html[1];
            }
            html1 += '&lt;/tbody>&lt;/table>';
            html2 += '&lt;/tbody>&lt;/table>';
            return [html1, html2];
        },

        scroll: function (event) {
            var time = (new Date()).getTime();
            var obj = this;
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            var records = $('#grid_' + this.name + '_records');
            var frecords = $('#grid_' + this.name + '_frecords');
            // sync scroll positions
            if (event) {
                var sTop = event.target.scrollTop;
                var sLeft = event.target.scrollLeft;
                obj.last.scrollTop = sTop;
                obj.last.scrollLeft = sLeft;
                $('#grid_' + obj.name + '_columns')[0].scrollLeft = sLeft;
                $('#grid_' + obj.name + '_summary')[0].scrollLeft = sLeft;
                frecords[0].scrollTop = sTop;
            }
            // hide bubble
            if (this.last.bubbleEl) {
                $(this.last.bubbleEl).w2tag();
                this.last.bubbleEl = null;
            }
            // column virtual scroll
            var colStart = null;
            var colEnd = null;
            if (obj.disableCVS || obj.columnGroups.length > 0) {
                // disable virtual scroll
                colStart = 0;
                colEnd = obj.columns.length - 1;
            } else {
                var sWidth = records.width();
                var cLeft = 0;
                for (var i = 0; i &lt; obj.columns.length; i++) {
                    if (obj.columns[i].frozen || obj.columns[i].hidden) continue;
                    var cSize = parseInt(obj.columns[i].sizeCalculated ? obj.columns[i].sizeCalculated : obj.columns[i].size);
                    if (cLeft + cSize + 30 > obj.last.scrollLeft &amp;&amp; colStart == null) colStart = i;
                    if (cLeft + cSize - 30 > obj.last.scrollLeft + sWidth &amp;&amp; colEnd == null) colEnd = i;
                    cLeft += cSize;
                }
                if (colEnd == null) colEnd = obj.columns.length - 1;
            }
            if (colStart != null) {
                if (colStart &lt; 0) colStart = 0;
                if (colEnd &lt; 0) colEnd = 0;
                if (colStart == colEnd) {
                    if (colStart > 0) colStart--; else colEnd++; // show at least one column
                }
                // ---------
                if (colStart != obj.last.colStart || colEnd != obj.last.colEnd) {
                    var $box = $(obj.box);
                    var deltaStart = Math.abs(colStart - obj.last.colStart);
                    var deltaEnd = Math.abs(colEnd - obj.last.colEnd)
                    // add/remove columns for small jumps
                    if (deltaStart &lt; 5 &amp;&amp; deltaEnd &lt; 5) {
                        var $cfirst = $box.find('.w2ui-grid-columns #grid_' + obj.name + '_column_start');
                        var $clast = $box.find('.w2ui-grid-columns .w2ui-head-last');
                        var $rfirst = $box.find('#grid_' + obj.name + '_records .w2ui-grid-data-spacer');
                        var $rlast = $box.find('#grid_' + obj.name + '_records .w2ui-grid-data-last');
                        var $sfirst = $box.find('#grid_' + obj.name + '_summary .w2ui-grid-data-spacer');
                        var $slast = $box.find('#grid_' + obj.name + '_summary .w2ui-grid-data-last');
                        // remove on left
                        if (colStart > obj.last.colStart) {
                            for (var i = obj.last.colStart; i &lt; colStart; i++) {
                                $box.find('#grid_' + obj.name + '_columns #grid_' + obj.name + '_column_' + i).remove(); // column
                                $box.find('#grid_' + obj.name + '_records td[col="' + i + '"]').remove(); // record
                                $box.find('#grid_' + obj.name + '_summary td[col="' + i + '"]').remove(); // summary
                            }
                        }
                        // remove on right
                        if (colEnd &lt; obj.last.colEnd) {
                            for (var i = obj.last.colEnd; i > colEnd; i--) {
                                $box.find('#grid_' + obj.name + '_columns #grid_' + obj.name + '_column_' + i).remove(); // column
                                $box.find('#grid_' + obj.name + '_records td[col="' + i + '"]').remove(); // record
                                $box.find('#grid_' + obj.name + '_summary td[col="' + i + '"]').remove(); // summary
                            }
                        }
                        // add on left
                        if (colStart &lt; obj.last.colStart) {
                            for (var i = obj.last.colStart - 1; i >= colStart; i--) {
                                if (obj.columns[i] &amp;&amp; (obj.columns[i].frozen || obj.columns[i].hidden)) continue;
                                $cfirst.after(obj.getColumnCellHTML(i)); // column
                                // record
                                $rfirst.each(function (ind, el) {
                                    var index = $(el).parent().attr('index');
                                    var td = '&lt;td class="w2ui-grid-data" col="' + i + '" style="height: 0px">&lt;/td>'; // width column
                                    if (index != null) td = obj.getCellHTML(parseInt(index), i, false);
                                    $(el).after(td);
                                });
                                // summary
                                $sfirst.each(function (ind, el) {
                                    var index = $(el).parent().attr('index');
                                    var td = '&lt;td class="w2ui-grid-data" col="' + i + '" style="height: 0px">&lt;/td>'; // width column
                                    if (index != null) td = obj.getCellHTML(parseInt(index), i, true);
                                    $(el).after(td);
                                });
                            }
                        }
                        // add on right
                        if (colEnd > obj.last.colEnd) {
                            for (var i = obj.last.colEnd + 1; i &lt;= colEnd; i++) {
                                if (obj.columns[i] &amp;&amp; (obj.columns[i].frozen || obj.columns[i].hidden)) continue;
                                $clast.before(obj.getColumnCellHTML(i)); // column
                                // record
                                $rlast.each(function (ind, el) {
                                    var index = $(el).parent().attr('index');
                                    var td = '&lt;td class="w2ui-grid-data" col="' + i + '" style="height: 0px">&lt;/td>'; // width column
                                    if (index != null) td = obj.getCellHTML(parseInt(index), i, false);
                                    $(el).before(td);
                                });
                                // summary
                                $slast.each(function (ind, el) {
                                    var index = $(el).parent().attr('index');
                                    var td = obj.getCellHTML(parseInt(index), i, true);
                                    $(el).before(td);
                                });
                            }
                        }
                        obj.last.colStart = colStart;
                        obj.last.colEnd = colEnd;
                        obj.resizeRecords();
                    } else {
                        obj.last.colStart = colStart;
                        obj.last.colEnd = colEnd;
                        // dot not just call obj.refresh();
                        var colHTML = this.getColumnsHTML();
                        var recHTML = this.getRecordsHTML();
                        var sumHTML = this.getSummaryHTML();
                        var $columns = $box.find('#grid_' + this.name + '_columns');
                        var $records = $box.find('#grid_' + this.name + '_records');
                        var $frecords = $box.find('#grid_' + this.name + '_frecords');
                        var $summary = $box.find('#grid_' + this.name + '_summary');
                        $columns.find('tbody').html(colHTML[1]);
                        $frecords.html(recHTML[0]);
                        $records.prepend(recHTML[1]);
                        if (sumHTML != null) $summary.html(sumHTML[1]);
                        // need timeout to clean up (otherwise scroll problem)
                        setTimeout(function () {
                            $records.find('> table').not('table:first-child').remove();
                            if ($summary[0]) $summary[0].scrollLeft = obj.last.scrollLeft;
                        }, 1);
                        obj.resizeRecords();
                    }
                }
            }
            // perform virtual scroll
            var buffered = this.records.length;
            if (this.searchData.length != 0 &amp;&amp; !url) buffered = this.last.searchIds.length;
            if (buffered === 0 || records.length === 0 || records.height() === 0) return;
            if (buffered > this.vs_start) this.last.show_extra = this.vs_extra; else this.last.show_extra = this.vs_start;
            // need this to enable scrolling when this.limit &lt; then a screen can fit
            if (records.height() &lt; buffered * this.recordHeight &amp;&amp; records.css('overflow-y') == 'hidden') {
                // TODO: is this needed?
                // if (this.total > 0) this.refresh();
                return;
            }
            // update footer
            var t1 = Math.round(records[0].scrollTop / this.recordHeight + 1);
            var t2 = t1 + (Math.round(records.height() / this.recordHeight) - 1);
            if (t1 > buffered) t1 = buffered;
            if (t2 >= buffered - 1) t2 = buffered;
            $('#grid_' + this.name + '_footer .w2ui-footer-right').html(
                (obj.show.statusRange ? w2utils.formatNumber(this.offset + t1) + '-' + w2utils.formatNumber(this.offset + t2) +
                    (this.total != -1 ? ' ' + w2utils.lang('of') + ' ' + w2utils.formatNumber(this.total) : '') : '') +
                (url &amp;&amp; obj.show.statusBuffered ? ' (' + w2utils.lang('buffered') + ' ' + w2utils.formatNumber(buffered) +
                    (this.offset > 0 ? ', skip ' + w2utils.formatNumber(this.offset) : '') + ')' : '')
            );
            // only for local data source, else no extra records loaded
            if (!url &amp;&amp; (!this.fixedBody || (this.total != -1 &amp;&amp; this.total &lt;= this.vs_start))) return;
            // regular processing
            var start = Math.floor(records[0].scrollTop / this.recordHeight) - this.last.show_extra;
            var end = start + Math.floor(records.height() / this.recordHeight) + this.last.show_extra * 2 + 1;
            // var div  = start - this.last.range_start;
            if (start &lt; 1) start = 1;
            if (end > this.total &amp;&amp; this.total != -1) end = this.total;
            var tr1 = records.find('#grid_' + this.name + '_rec_top');
            var tr2 = records.find('#grid_' + this.name + '_rec_bottom');
            var tr1f = frecords.find('#grid_' + this.name + '_frec_top');
            var tr2f = frecords.find('#grid_' + this.name + '_frec_bottom');
            // if row is expanded
            if (String(tr1.next().prop('id')).indexOf('_expanded_row') != -1) {
                tr1.next().remove();
                tr1f.next().remove();
            }
            if (this.total > end &amp;&amp; String(tr2.prev().prop('id')).indexOf('_expanded_row') != -1) {
                tr2.prev().remove();
                tr2f.prev().remove();
            }
            var first = parseInt(tr1.next().attr('line'));
            var last = parseInt(tr2.prev().attr('line'));
            //$('#log').html('buffer: '+ this.buffered +' start-end: ' + start + '-'+ end + ' ===> first-last: ' + first + '-' + last);
            if (first &lt; start || first == 1 || this.last.pull_refresh) { // scroll down
                if (end &lt;= last + this.last.show_extra - 2 &amp;&amp; end != this.total) return;
                this.last.pull_refresh = false;
                // remove from top
                while (true) {
                    var tmp1 = frecords.find('#grid_' + this.name + '_frec_top').next();
                    var tmp2 = records.find('#grid_' + this.name + '_rec_top').next();
                    if (tmp2.attr('line') == 'bottom') break;
                    if (parseInt(tmp2.attr('line')) &lt; start) {
                        tmp1.remove();
                        tmp2.remove();
                    } else break;
                }
                // add at bottom
                var tmp = records.find('#grid_' + this.name + '_rec_bottom').prev();
                var rec_start = tmp.attr('line');
                if (rec_start == 'top') rec_start = start;
                for (var i = parseInt(rec_start) + 1; i &lt;= end; i++) {
                    if (!this.records[i - 1]) continue;
                    var tmp2 = this.records[i - 1].w2ui;
                    if (tmp2 &amp;&amp; !Array.isArray(tmp2.children)) {
                        tmp2.expanded = false;
                    }
                    var rec_html = this.getRecordHTML(i - 1, i);
                    tr2.before(rec_html[1]);
                    tr2f.before(rec_html[0]);
                }
                markSearch();
                setTimeout(function () {
                    obj.refreshRanges();
                }, 0);
            } else { // scroll up
                if (start >= first - this.last.show_extra + 2 &amp;&amp; start > 1) return;
                // remove from bottom
                while (true) {
                    var tmp1 = frecords.find('#grid_' + this.name + '_frec_bottom').prev();
                    var tmp2 = records.find('#grid_' + this.name + '_rec_bottom').prev();
                    if (tmp2.attr('line') == 'top') break;
                    if (parseInt(tmp2.attr('line')) > end) {
                        tmp1.remove();
                        tmp2.remove();
                    } else break;
                }
                // add at top
                var tmp = records.find('#grid_' + this.name + '_rec_top').next();
                var rec_start = tmp.attr('line');
                if (rec_start == 'bottom') rec_start = end;
                for (var i = parseInt(rec_start) - 1; i >= start; i--) {
                    if (!this.records[i - 1]) continue;
                    var tmp2 = this.records[i - 1].w2ui;
                    if (tmp2 &amp;&amp; !Array.isArray(tmp2.children)) {
                        tmp2.expanded = false;
                    }
                    var rec_html = this.getRecordHTML(i - 1, i);
                    tr1.after(rec_html[1]);
                    tr1f.after(rec_html[0]);
                }
                markSearch();
                setTimeout(function () {
                    obj.refreshRanges();
                }, 0);
            }
            // first/last row size
            var h1 = (start - 1) * obj.recordHeight;
            var h2 = (buffered - end) * obj.recordHeight;
            if (h2 &lt; 0) h2 = 0;
            tr1.css('height', h1 + 'px');
            tr1f.css('height', h1 + 'px');
            tr2.css('height', h2 + 'px');
            tr2f.css('height', h2 + 'px');
            obj.last.range_start = start;
            obj.last.range_end = end;
            // load more if needed
            var s = Math.floor(records[0].scrollTop / this.recordHeight);
            var e = s + Math.floor(records.height() / this.recordHeight);
            if (e + 10 > buffered &amp;&amp; this.last.pull_more !== true &amp;&amp; (buffered &lt; this.total - this.offset || (this.total == -1 &amp;&amp; this.last.xhr_hasMore))) {
                if (this.autoLoad === true) {
                    this.last.pull_more = true;
                    this.last.xhr_offset += this.limit;
                    this.request('get');
                } else {
                    var more = $('#grid_' + this.name + '_rec_more, #grid_' + this.name + '_frec_more');
                    if (more.css('display') == 'none') {
                        more.show()
                            .on('click', function () {
                                obj.last.pull_more = true;
                                obj.last.xhr_offset += obj.limit;
                                obj.request('get');
                                // show spinner the last
                                $(this).find('td').html('&lt;div>&lt;div style="width: 20px; height: 20px;" class="w2ui-spinner">&lt;/div>&lt;/div>');
                            });
                    }
                    if (more.find('td .w2ui-spinner').length > 0 || more.find('td').text().indexOf('Load') == -1) {
                        more.find('td').html('&lt;div>' + w2utils.lang('Load') + ' ' + obj.limit + ' ' + w2utils.lang('More') + '...&lt;/div>');
                    }
                }
            }
            // check for grid end
            if (buffered >= this.total - this.offset &amp;&amp; this.total != -1) $('#grid_' + this.name + '_rec_more, #grid_' + this.name + '_frec_more').hide();

            function markSearch() {
                // mark search
                if (!obj.markSearch) return;
                clearTimeout(obj.last.marker_timer);
                obj.last.marker_timer = setTimeout(function () {
                    // mark all search strings
                    var str = [];
                    for (var s = 0; s &lt; obj.searchData.length; s++) {
                        var sdata = obj.searchData[s];
                        var fld = obj.getSearch(sdata.field);
                        if (!fld || fld.hidden) continue;
                        if (str.indexOf(sdata.value) == -1) str.push(sdata.value);
                    }
                    if (str.length > 0) $(obj.box).find('.w2ui-grid-data > div').w2marker(str);
                }, 50);
            }
        },

        getRecordHTML: function (ind, lineNum, summary) {
            var tmph = '';
            var rec_html1 = '';
            var rec_html2 = '';
            var sel = this.last.selection;
            var record;
            // first record needs for resize purposes
            if (ind == -1) {
                rec_html1 += '&lt;tr line="0">';
                rec_html2 += '&lt;tr line="0">';
                if (this.show.lineNumbers) rec_html1 += '&lt;td class="w2ui-col-number" style="height: 0px;">&lt;/td>';
                if (this.show.selectColumn) rec_html1 += '&lt;td class="w2ui-col-select" style="height: 0px;">&lt;/td>';
                if (this.show.expandColumn) rec_html1 += '&lt;td class="w2ui-col-expand" style="height: 0px;">&lt;/td>';
                rec_html2 += '&lt;td class="w2ui-grid-data w2ui-grid-data-spacer" col="start" style="height: 0px; width: 0px;">&lt;/td>';
                for (var i = 0; i &lt; this.columns.length; i++) {
                    var col = this.columns[i];
                    tmph = '&lt;td class="w2ui-grid-data" col="' + i + '" style="height: 0px;">&lt;/td>';
                    if (col.frozen &amp;&amp; !col.hidden) {
                        rec_html1 += tmph;
                    } else {
                        if (col.hidden || i &lt; this.last.colStart || i > this.last.colEnd) continue;
                        rec_html2 += tmph;
                    }
                }
                rec_html1 += '&lt;td class="w2ui-grid-data-last" style="height: 0px">&lt;/td>';
                rec_html2 += '&lt;td class="w2ui-grid-data-last" col="end" style="height: 0px">&lt;/td>';
                rec_html1 += '&lt;/tr>';
                rec_html2 += '&lt;/tr>';
                return [rec_html1, rec_html2];
            }
            // regular record
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (summary !== true) {
                if (this.searchData.length > 0 &amp;&amp; !url) {
                    if (ind >= this.last.searchIds.length) return '';
                    ind = this.last.searchIds[ind];
                    record = this.records[ind];
                } else {
                    if (ind >= this.records.length) return '';
                    record = this.records[ind];
                }
            } else {
                if (ind >= this.summary.length) return '';
                record = this.summary[ind];
            }
            if (!record) return '';
            if (record.recid == null &amp;&amp; this.recid != null &amp;&amp; record[this.recid] != null) record.recid = record[this.recid];
            var id = w2utils.escapeId(record.recid);
            var isRowSelected = false;
            if (sel.indexes.indexOf(ind) != -1) isRowSelected = true;
            var rec_style = (record.w2ui ? record.w2ui.style : '');
            if (rec_style == null || typeof rec_style != 'string') rec_style = '';
            var rec_class = (record.w2ui ? record.w2ui.class : '');
            if (rec_class == null || typeof rec_class != 'string') rec_class = '';
            // render TR
            rec_html1 += '&lt;tr id="grid_' + this.name + '_frec_' + record.recid + '" recid="' + record.recid + '" line="' + lineNum + '" index="' + ind + '" ' +
                ' class="' + (lineNum % 2 === 0 ? 'w2ui-even' : 'w2ui-odd') + ' ' + rec_class +
                (isRowSelected &amp;&amp; this.selectType == 'row' ? ' w2ui-selected' : '') +
                (record.w2ui &amp;&amp; record.w2ui.editable === false ? ' w2ui-no-edit' : '') +
                (record.w2ui &amp;&amp; record.w2ui.expanded === true ? ' w2ui-expanded' : '') + '" ' +
                (summary !== true ?
                        (w2utils.isIOS ?
                                '    onclick  = "w2ui[\'' + this.name + '\'].dblClick(jQuery(this).attr(\'recid\'), event);"'
                                :
                                '    onclick  = "w2ui[\'' + this.name + '\'].click(jQuery(this).attr(\'recid\'), event);"' +
                                '    oncontextmenu = "w2ui[\'' + this.name + '\'].contextMenu(jQuery(this).attr(\'recid\'), null, event);"'
                        )
                        : ''
                ) +
                (this.selectType == 'row' ?
                    ' onmouseover="jQuery(\'#grid_' + this.name + '_rec_\'+ w2utils.escapeId(jQuery(this).attr(\'recid\'))).addClass(\'w2ui-record-hover\')"' +
                    ' onmouseout ="jQuery(\'#grid_' + this.name + '_rec_\'+ w2utils.escapeId(jQuery(this).attr(\'recid\'))).removeClass(\'w2ui-record-hover\')"'
                    :
                    '') +
                ' style="height: ' + this.recordHeight + 'px; ' + (!isRowSelected &amp;&amp; rec_style != '' ? rec_style : rec_style.replace('background-color', 'none')) + '" ' +
                (rec_style != '' ? 'custom_style="' + rec_style + '"' : '') +
                '>';
            rec_html2 += '&lt;tr id="grid_' + this.name + '_rec_' + record.recid + '" recid="' + record.recid + '" line="' + lineNum + '" index="' + ind + '" ' +
                ' class="' + (lineNum % 2 === 0 ? 'w2ui-even' : 'w2ui-odd') + ' ' + rec_class +
                (isRowSelected &amp;&amp; this.selectType == 'row' ? ' w2ui-selected' : '') +
                (record.w2ui &amp;&amp; record.w2ui.editable === false ? ' w2ui-no-edit' : '') +
                (record.w2ui &amp;&amp; record.w2ui.expanded === true ? ' w2ui-expanded' : '') + '" ' +
                (summary !== true ?
                        (w2utils.isIOS ?
                                '    onclick  = "var obj = w2ui[\'' + this.name + '\']; obj.dblClick(jQuery(this).attr(\'recid\'), event);"'
                                :
                                '    onclick  = "var obj = w2ui[\'' + this.name + '\']; obj.click(jQuery(this).attr(\'recid\'), event);"' +
                                '    oncontextmenu = "var obj = w2ui[\'' + this.name + '\']; obj.contextMenu(jQuery(this).attr(\'recid\'), null, event);"'
                        )
                        : ''
                ) +
                (this.selectType == 'row' ?
                    ' onmouseover="jQuery(\'#grid_' + this.name + '_frec_\' + w2utils.escapeId(jQuery(this).attr(\'recid\'))).addClass(\'w2ui-record-hover\')"' +
                    ' onmouseout ="jQuery(\'#grid_' + this.name + '_frec_\' + w2utils.escapeId(jQuery(this).attr(\'recid\'))).removeClass(\'w2ui-record-hover\')"'
                    :
                    '') +
                ' style="height: ' + this.recordHeight + 'px; ' + (!isRowSelected &amp;&amp; rec_style != '' ? rec_style : rec_style.replace('background-color', 'none')) + '" ' +
                (rec_style != '' ? 'custom_style="' + rec_style + '"' : '') +
                '>';
            if (this.show.lineNumbers) {
                rec_html1 += '&lt;td id="grid_' + this.name + '_cell_' + ind + '_number' + (summary ? '_s' : '') + '" ' +
                    '   class="w2ui-col-number ' + (isRowSelected ? ' w2ui-row-selected' : '') + '"' +
                    (this.reorderRows ? ' style="cursor: move"' : '') + '>' +
                    (summary !== true ? this.getLineHTML(lineNum, record) : '') +
                    '&lt;/td>';
            }
            if (this.show.selectColumn) {
                rec_html1 +=
                    '&lt;td id="grid_' + this.name + '_cell_' + ind + '_select' + (summary ? '_s' : '') + '" class="w2ui-grid-data w2ui-col-select">' +
                    (summary !== true ?
                        '    &lt;div>' +
                        '        &lt;input class="w2ui-grid-select-check" type="checkbox" tabindex="-1" ' +
                        (isRowSelected ? 'checked="checked"' : '') + ' style="pointer-events: none"/>' +
                        '    &lt;/div>'
                        :
                        '' ) +
                    '&lt;/td>';
            }
            if (this.show.expandColumn) {
                var tmp_img = '';
                if (record.w2ui &amp;&amp; record.w2ui.expanded === true) tmp_img = '-'; else tmp_img = '+';
                if (record.w2ui &amp;&amp; record.w2ui.expanded == 'none') tmp_img = '';
                if (record.w2ui &amp;&amp; record.w2ui.expanded == 'spinner') tmp_img = '&lt;div class="w2ui-spinner" style="width: 16px; margin: -2px 2px;">&lt;/div>';
                rec_html1 +=
                    '&lt;td id="grid_' + this.name + '_cell_' + ind + '_expand' + (summary ? '_s' : '') + '" class="w2ui-grid-data w2ui-col-expand">' +
                    (summary !== true ?
                        '    &lt;div ondblclick="if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;" ' +
                        '            onclick="w2ui[\'' + this.name + '\'].toggle(jQuery(this).parents(\'tr\').attr(\'recid\')); ' +
                        '                if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;">' +
                        '        ' + tmp_img + ' &lt;/div>'
                        :
                        '' ) +
                    '&lt;/td>';
            }
            // insert empty first column
            rec_html2 += '&lt;td class="w2ui-grid-data-spacer" col="start" style="border-right: 0">&lt;/td>';
            var col_ind = 0;
            var col_skip = 0;
            while (true) {
                var col_span = 1;
                var col = this.columns[col_ind];
                if (col == null) break;
                if (col.hidden) {
                    col_ind++;
                    if (col_skip > 0) col_skip--;
                    continue;
                }
                if (col_skip > 0) {
                    col_ind++;
                    if (this.columns[col_ind] == null) break;
                    record.w2ui.colspan[this.columns[col_ind - 1].field] = 0; // need it for other methods
                    col_skip--;
                    continue;
                } else if (record.w2ui) {
                    var tmp1 = record.w2ui.colspan;
                    var tmp2 = this.columns[col_ind].field;
                    if (tmp1 &amp;&amp; tmp1[tmp2] === 0) {
                        delete tmp1[tmp2]; // if no longer colspan then remove 0
                    }
                }
                // column virtual scroll
                if ((col_ind &lt; this.last.colStart || col_ind > this.last.colEnd) &amp;&amp; !col.frozen) {
                    col_ind++;
                    continue;
                }
                if (record.w2ui) {
                    if (typeof record.w2ui.colspan == 'object') {
                        var span = parseInt(record.w2ui.colspan[col.field]) || null;
                        if (span > 1) {
                            // if there are hidden columns, then no colspan on them
                            var hcnt = 0;
                            for (var i = col_ind; i &lt; col_ind + span; i++) {
                                if (i >= this.columns.length) break;
                                if (this.columns[i].hidden) hcnt++;
                            }
                            col_span = span - hcnt;
                            col_skip = span - 1;
                        }
                    }
                }
                var rec_cell = this.getCellHTML(ind, col_ind, summary, col_span);
                if (col.frozen) rec_html1 += rec_cell; else rec_html2 += rec_cell;
                col_ind++;
            }
            rec_html1 += '&lt;td class="w2ui-grid-data-last">&lt;/td>';
            rec_html2 += '&lt;td class="w2ui-grid-data-last" col="end">&lt;/td>';
            rec_html1 += '&lt;/tr>';
            rec_html2 += '&lt;/tr>';
            return [rec_html1, rec_html2];
        },

        getLineHTML: function (lineNum) {
            return '&lt;div>' + lineNum + '&lt;/div>';
        },

        getCellHTML: function (ind, col_ind, summary, col_span) {
            var col = this.columns[col_ind];
            if (col == null) return '';
            var record = (summary !== true ? this.records[ind] : this.summary[ind]);
            var data = this.getCellValue(ind, col_ind, summary);
            var edit = this.getCellEditable(ind, col_ind);
            var style = 'max-height: ' + parseInt(this.recordHeight) + 'px;';
            var isChanged = !summary &amp;&amp; record &amp;&amp; record.w2ui &amp;&amp; record.w2ui.changes &amp;&amp; record.w2ui.changes[col.field] != null;
            var addStyle = '';
            var addClass = '';
            var sel = this.last.selection;
            var isRowSelected = false;
            var infoBubble = '';
            if (sel.indexes.indexOf(ind) != -1) isRowSelected = true;
            if (col_span == null) {
                if (record &amp;&amp; record.w2ui &amp;&amp; record.w2ui.colspan &amp;&amp; record.w2ui.colspan[col.field]) {
                    col_span = record.w2ui.colspan[col.field];
                } else {
                    col_span = 1;
                }
            }
            // expand icon
            if (col_ind === 0 &amp;&amp; record &amp;&amp; record.w2ui &amp;&amp; Array.isArray(record.w2ui.children)) {
                var level = 0;
                var subrec = this.get(record.w2ui.parent_recid, true);
                while (true) {
                    if (subrec != null) {
                        level++
                        var tmp = this.records[subrec].w2ui;
                        if (tmp != null &amp;&amp; tmp.parent_recid != null) {
                            subrec = this.get(tmp.parent_recid, true);
                        } else {
                            break;
                        }
                    } else {
                        break;
                    }
                }
                var onclick = 'event.stopPropagation(); w2ui[\'' + this.name + '\'].toggle(jQuery(this).parents(\'tr\').attr(\'recid\'));';
                if (record.w2ui.children.length > 0) {
                    if (!record.w2ui.expanded &amp;&amp; this.onTreeExpand !== null) {
                        onclick = 'w2ui[\'' + this.name + '\'].onTreeExpand(\'' + this.name + '\',\'' + record.recid + '\')';
                    }
                }
                if (record.w2ui.parent_recid) {
                    for (var i = 0; i &lt; level; i++) {
                        infoBubble += '&lt;span class="w2ui-show-children w2ui-icon-empty">&lt;/span>';
                    }
                }
                infoBubble += '&lt;span class="w2ui-show-children ' +
                    (record.w2ui.children.length > 0
                            ? (record.w2ui.expanded ? 'w2ui-icon-collapse' : 'w2ui-icon-expand')
                            : 'w2ui-icon-empty'
                    ) + '" ' +
                    ' onclick="' + onclick + '" id="arrowC' +
                    record.recid + '">&lt;/span>';
            }
            // info bubble
            if (col.info === true) col.info = {};
            if (col.info != null) {
                if (!col.info.icon) col.info.icon = 'w2ui-icon-info';
                infoBubble += '&lt;span class="w2ui-info ' + col.info.icon + '" style="' + (col.info.style || '') + '" ' +
                    ' onclick="event.stopPropagation(); w2ui[\'' + this.name + '\'].showBubble(' + ind + ', ' + col_ind + ')">&lt;/span>';
            }
            // various renderers
            if (col.render != null) {
                if (typeof col.render == 'function') {
                    data = $.trim(col.render.call(this, record, ind, col_ind, data));
                    if (data.length &lt; 4 || data.substr(0, 4).toLowerCase() != '&lt;div') {
                        data = '&lt;div style="' + style + '">' + infoBubble + String(data) + '&lt;/div>';
                    }
                }
                if (typeof col.render == 'object') {
                    data = '&lt;div style="' + style + '">' + infoBubble + (col.render[data] || '') + '&lt;/div>';
                }
                if (typeof col.render == 'string') {
                    var t = col.render.toLowerCase().indexOf(':');
                    var tmp = [];
                    if (t == -1) {
                        tmp[0] = col.render.toLowerCase();
                        tmp[1] = '';
                    } else {
                        tmp[0] = col.render.toLowerCase().substr(0, t);
                        tmp[1] = col.render.toLowerCase().substr(t + 1);
                    }
                    // formatters
                    var func = w2utils.formatters[tmp[0]];
                    data = '&lt;div style="' + style + '">' + infoBubble + (typeof func == 'function' ? func(data, tmp[1]) : '') + '&lt;/div>';
                }
            } else {
                // if editable checkbox
                if (edit &amp;&amp; ['checkbox', 'check'].indexOf(edit.type) != -1) {
                    var changeInd = summary ? -(ind + 1) : ind;
                    style += 'text-align: center;';
                    data = '&lt;input tabindex="-1" type="checkbox" ' + (data ? 'checked="checked"' : '') + ' onclick="' +
                        '    var obj = w2ui[\'' + this.name + '\']; ' +
                        '    obj.editChange.call(obj, this, ' + changeInd + ', ' + col_ind + ', event); ' +
                        '"/>';
                    infoBubble = '';
                }
                if (this.show.recordTitles) {
                    // title overwrite
                    var title = w2utils.stripTags(String(data).replace(/"/g, "''"));
                    if (col.title != null) {
                        if (typeof col.title == 'function') title = col.title.call(this, record, ind, col_ind);
                        if (typeof col.title == 'string') title = col.title;
                    }
                }
                data = '&lt;div style="' + style + '" title="' + (title || '') + '">' + infoBubble + String(data) + '&lt;/div>';
            }
            if (data == null) data = '';
            // --> cell TD
            if (typeof col.render == 'string') {
                var tmp = col.render.toLowerCase().split(':');
                if (['number', 'int', 'float', 'money', 'currency', 'percent', 'size'].indexOf(tmp[0]) != -1) addStyle += 'text-align: right;';
            }
            if (record &amp;&amp; record.w2ui) {
                if (typeof record.w2ui.style == 'object') {
                    if (typeof record.w2ui.style[col_ind] == 'string') addStyle += record.w2ui.style[col_ind] + ';';
                    if (typeof record.w2ui.style[col.field] == 'string') addStyle += record.w2ui.style[col.field] + ';';
                }
                if (typeof record.w2ui.class == 'object') {
                    if (typeof record.w2ui.class[col_ind] == 'string') addClass += record.w2ui.class[col_ind] + ' ';
                    if (typeof record.w2ui.class[col.field] == 'string') addClass += record.w2ui.class[col.field] + ' ';
                }
            }
            var isCellSelected = false;
            if (isRowSelected &amp;&amp; $.inArray(col_ind, sel.columns[ind]) != -1) isCellSelected = true;
            // data
            data = '&lt;td class="w2ui-grid-data' + (isCellSelected ? ' w2ui-selected' : '') + ' ' + addClass +
                (isChanged ? ' w2ui-changed' : '') +
                '" ' +
                '   id="grid_' + this.name + '_data_' + ind + '_' + col_ind + '" col="' + col_ind + '" ' +
                '   style="' + addStyle + (col.style != null ? col.style : '') + '" ' +
                (col.attr != null ? col.attr : '') +
                (col_span > 1 ? 'colspan="' + col_span + '"' : '') +
                '>' + data + '&lt;/td>';

            return data;
        },

        showBubble: function (ind, col_ind) {
            var html = '';
            var info = this.columns[col_ind].info;
            var rec = this.records[ind];
            var el = $(this.box).find('#grid_' + this.name + '_data_' + ind + '_' + col_ind + ' .w2ui-info');
            if (this.last.bubbleEl) $(this.last.bubbleEl).w2tag();
            this.last.bubbleEl = el;
            // if no fields defined - show all
            if (info.fields == null) {
                info.fields = [];
                for (var i = 0; i &lt; this.columns.length; i++) {
                    var col = this.columns[i];
                    info.fields.push(col.field + (typeof col.render == 'string' ? ':' + col.render : ''));
                }
            }
            var fields = info.fields;
            if (typeof fields == 'function') {
                fields = fields(rec, ind, col_ind); // custom renderer
            }
            // generate html
            if (typeof info.render == 'function') {
                html = info.render(rec, ind, col_ind);

            } else if ($.isArray(fields)) {
                // display mentioned fields
                html = '&lt;table cellpadding="0" cellspacing="0">';
                for (var i = 0; i &lt; fields.length; i++) {
                    var tmp = String(fields[i]).split(':');
                    if (tmp[0] == '' || tmp[0] == '-' || tmp[0] == '--' || tmp[0] == '---') {
                        html += '&lt;tr>&lt;td colspan=2>&lt;div style="border-top: ' + (tmp[0] == '' ? '0' : '1') + 'px solid #C1BEBE; margin: 6px 0px;">&lt;/div>&lt;/td>&lt;/tr>';
                        continue;
                    }
                    var col = this.getColumn(tmp[0]);
                    if (col == null) col = {field: tmp[0], caption: tmp[0]}; // if not found in columns
                    var val = (col ? this.parseField(rec, col.field) : '');
                    if (tmp.length > 1) {
                        if (w2utils.formatters[tmp[1]]) {
                            val = w2utils.formatters[tmp[1]](val, tmp[2] || null);
                        } else {
                            console.log('ERROR: w2utils.formatters["' + tmp[1] + '"] does not exists.')
                        }
                    }
                    if (info.showEmpty !== true &amp;&amp; (val == null || val == '')) continue;
                    if (info.maxLength != null &amp;&amp; typeof val == 'string' &amp;&amp; val.length > info.maxLength) val = val.substr(0, info.maxLength) + '...';
                    html += '&lt;tr>&lt;td>' + col.caption + '&lt;/td>&lt;td>' + ((val === 0 ? '0' : val) || '') + '&lt;/td>&lt;/tr>';
                }
                html += '&lt;/table>';
            } else if ($.isPlainObject(fields)) {
                // display some fields
                html = '&lt;table cellpadding="0" cellspacing="0">';
                for (var caption in fields) {
                    var fld = fields[caption];
                    if (fld == '' || fld == '-' || fld == '--' || fld == '---') {
                        html += '&lt;tr>&lt;td colspan=2>&lt;div style="border-top: ' + (fld == '' ? '0' : '1') + 'px solid #C1BEBE; margin: 6px 0px;">&lt;/div>&lt;/td>&lt;/tr>';
                        continue;
                    }
                    var tmp = String(fld).split(':');
                    var col = this.getColumn(tmp[0]);
                    if (col == null) col = {field: tmp[0], caption: tmp[0]}; // if not found in columns
                    var val = (col ? this.parseField(rec, col.field) : '');
                    if (tmp.length > 1) {
                        if (w2utils.formatters[tmp[1]]) {
                            val = w2utils.formatters[tmp[1]](val, tmp[2] || null);
                        } else {
                            console.log('ERROR: w2utils.formatters["' + tmp[1] + '"] does not exists.')
                        }
                    }
                    if (typeof fld == 'function') {
                        val = fld(rec, ind, col_ind);
                    }
                    if (info.showEmpty !== true &amp;&amp; (val == null || val == '')) continue;
                    if (info.maxLength != null &amp;&amp; typeof val == 'string' &amp;&amp; val.length > info.maxLength) val = val.substr(0, info.maxLength) + '...';
                    html += '&lt;tr>&lt;td>' + caption + '&lt;/td>&lt;td>' + (val || '') + '&lt;/td>&lt;/tr>';
                }
                html += '&lt;/table>';
            }
            $(el).w2tag($.extend({
                html: html,
                left: -4,
                position: 'bottom|top',
                className: 'w2ui-info-bubble',
                style: '',
                hideOnClick: true
            }, info.options || {}));
        },

        // return null or the editable object if the given cell is editable
        getCellEditable: function (ind, col_ind) {
            var col = this.columns[col_ind];
            var rec = this.records[ind];
            if (!rec || !col) return null;
            var edit = (rec.w2ui ? rec.w2ui.editable : null);
            if (edit === false) return null;
            if (edit == null || edit === true) {
                edit = (col ? col.editable : null);
                if (typeof(edit) === 'function') {
                    var data = this.getCellValue(ind, col_ind, false);
                    // same arguments as col.render()
                    edit = edit.call(this, rec, ind, col_ind, data);
                }
            }
            return edit;
        },

        getCellValue: function (ind, col_ind, summary) {
            var col = this.columns[col_ind];
            var record = (summary !== true ? this.records[ind] : this.summary[ind]);
            var data = this.parseField(record, col.field);
            if (record &amp;&amp; record.w2ui &amp;&amp; record.w2ui.changes &amp;&amp; record.w2ui.changes[col.field] != null) {
                data = record.w2ui.changes[col.field];
            }
            if ($.isPlainObject(data) &amp;&amp; col.editable) {
                if (data.text != null) data = data.text;
                if (data.id != null) data = data.id;
            }
            if (data == null) data = '';
            return data;
        },

        getFooterHTML: function () {
            return '&lt;div>' +
                '    &lt;div class="w2ui-footer-left">&lt;/div>' +
                '    &lt;div class="w2ui-footer-right">&lt;/div>' +
                '    &lt;div class="w2ui-footer-center">&lt;/div>' +
                '&lt;/div>';
        },

        status: function (msg) {
            if (msg != null) {
                $('#grid_' + this.name + '_footer').find('.w2ui-footer-left').html(msg);
            } else {
                // show number of selected
                var msgLeft = '';
                var sel = this.getSelection();
                if (sel.length > 0) {
                    if (this.show.statusSelection &amp;&amp; sel.length > 1) {
                        msgLeft = String(sel.length).replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,") + ' ' + w2utils.lang('selected');
                    }
                    if (this.show.statusRecordID &amp;&amp; sel.length == 1) {
                        var tmp = sel[0];
                        if (typeof tmp == 'object') tmp = tmp.recid + ', ' + w2utils.lang('Column') + ': ' + tmp.column;
                        msgLeft = w2utils.lang('Record ID') + ': ' + tmp + ' ';
                    }
                }
                $('#grid_' + this.name + '_footer .w2ui-footer-left').html(msgLeft);
                // toolbar
                if (sel.length == 1) this.toolbar.enable('w2ui-edit'); else this.toolbar.disable('w2ui-edit');
                if (sel.length >= 1) this.toolbar.enable('w2ui-delete'); else this.toolbar.disable('w2ui-delete');
            }
        },

        lock: function (msg, showSpinner) {
            var obj = this;
            var args = Array.prototype.slice.call(arguments, 0);
            args.unshift(this.box);
            setTimeout(function () {
                // hide empty msg if any
                $(obj.box).find('#grid_' + obj.name + '_empty_msg').remove();
                w2utils.lock.apply(window, args);
            }, 10);
        },

        unlock: function (speed) {
            var box = this.box;
            setTimeout(function () {
                // do not unlock if there is a message
                if ($(box).find('.w2ui-message').not('.w2ui-closing').length > 0) return;
                w2utils.unlock(box, speed);
            }, 25); // needed timer so if server fast, it will not flash
        },

        stateSave: function (returnOnly) {
            var obj = this;
            if (!w2utils.hasLocalStorage) return null;
            var state = {
                columns: [],
                show: $.extend({}, this.show),
                last: {
                    search: this.last.search,
                    multi: this.last.multi,
                    logic: this.last.logic,
                    caption: this.last.caption,
                    field: this.last.field,
                    scrollTop: this.last.scrollTop,
                    scrollLeft: this.last.scrollLeft
                },
                sortData: [],
                searchData: []
            };
            for (var i = 0; i &lt; this.columns.length; i++) {
                var col = this.columns[i];
                state.columns.push({
                    field: col.field,
                    hidden: col.hidden ? true : false,
                    frozen: col.frozen ? true : false,
                    size: col.size ? col.size : null,
                    sizeCalculated: col.sizeCalculated ? col.sizeCalculated : null,
                    sizeOriginal: col.sizeOriginal ? col.sizeOriginal : null,
                    sizeType: col.sizeType ? col.sizeType : null
                });
            }
            for (var i = 0; i &lt; this.sortData.length; i++) state.sortData.push($.extend({}, this.sortData[i]));
            for (var i = 0; i &lt; this.searchData.length; i++) state.searchData.push($.extend({}, this.searchData[i]));
            // save into local storage
            if (returnOnly !== true) {
                // event before
                var edata = this.trigger({phase: 'before', type: 'stateSave', target: this.name, state: state});
                if (edata.isCancelled === true) {
                    if (typeof callBack == 'function') callBack({status: 'error', message: 'Request aborted.'});
                    return;
                }
                try {
                    var savedState = $.parseJSON(localStorage.w2ui || '{}');
                    if (!savedState) savedState = {};
                    if (!savedState.states) savedState.states = {};
                    savedState.states[(this.stateId || this.name)] = state;
                    localStorage.w2ui = JSON.stringify(savedState);
                } catch (e) {
                    delete localStorage.w2ui;
                    return null;
                }
                // event after
                this.trigger($.extend(edata, {phase: 'after'}));
            }
            return state;
        },

        stateRestore: function (newState) {
            var obj = this;
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (!newState) {
                // read it from local storage
                try {
                    if (!w2utils.hasLocalStorage) return false;
                    var tmp = $.parseJSON(localStorage.w2ui || '{}');
                    if (!tmp) tmp = {};
                    if (!tmp.states) tmp.states = {};
                    newState = tmp.states[(this.stateId || this.name)];
                } catch (e) {
                    delete localStorage.w2ui;
                    return null;
                }
            }
            // event before
            var edata = this.trigger({phase: 'before', type: 'stateRestore', target: this.name, state: newState});
            if (edata.isCancelled === true) {
                if (typeof callBack == 'function') callBack({status: 'error', message: 'Request aborted.'});
                return;
            }
            // default behavior
            if ($.isPlainObject(newState)) {
                $.extend(this.show, newState.show);
                $.extend(this.last, newState.last);
                var sTop = this.last.scrollTop;
                var sLeft = this.last.scrollLeft;
                for (var c = 0; c &lt; newState.columns.length; c++) {
                    var tmp = newState.columns[c];
                    var col_index = this.getColumn(tmp.field, true);
                    if (col_index !== null) {
                        $.extend(this.columns[col_index], tmp);
                        // restore column order from saved state
                        if (c !== col_index) this.columns.splice(c, 0, this.columns.splice(col_index, 1)[0]);
                    }
                }
                this.sortData.splice(0, this.sortData.length);
                for (var c = 0; c &lt; newState.sortData.length; c++) this.sortData.push(newState.sortData[c]);
                this.searchData.splice(0, this.searchData.length);
                for (var c = 0; c &lt; newState.searchData.length; c++) this.searchData.push(newState.searchData[c]);
                // apply sort and search
                setTimeout(function () {
                    // needs timeout as records need to be populated
                    // ez 10.09.2014 this -->
                    if (!url) {
                        if (obj.sortData.length > 0) obj.localSort();
                        if (obj.searchData.length > 0) obj.localSearch();
                    }
                    obj.last.scrollTop = sTop;
                    obj.last.scrollLeft = sLeft;
                    obj.refresh();
                }, 1);
            }
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            return true;
        },

        stateReset: function () {
            var obj = this;
            this.stateRestore(this.last.state);
            // remove from local storage
            if (w2utils.hasLocalStorage) {
                try {
                    var tmp = $.parseJSON(localStorage.w2ui || '{}');
                    if (tmp.states &amp;&amp; tmp.states[(this.stateId || this.name)]) {
                        delete tmp.states[(this.stateId || this.name)];
                    }
                    localStorage.w2ui = JSON.stringify(tmp);
                } catch (e) {
                    delete localStorage.w2ui;
                    return null;
                }
            }
        },

        parseField: function (obj, field) {
            var val = '';
            try { // need this to make sure no error in fields
                val = obj;
                var tmp = String(field).split('.');
                for (var i = 0; i &lt; tmp.length; i++) {
                    val = val[tmp[i]];
                }
            } catch (event) {
                val = '';
            }
            return val;
        },

        prepareData: function () {
            var obj = this;

            // loops thru records and prepares date and time objects
            for (var r = 0; r &lt; this.records.length; r++) {
                var rec = this.records[r];
                prepareRecord(rec);
            }

            // prepare date and time objects for the 'rec' record and its closed children
            function prepareRecord(rec) {
                for (var c = 0; c &lt; obj.columns.length; c++) {
                    var column = obj.columns[c];
                    if (rec[column.field] == null || typeof column.render != 'string') continue;
                    // number
                    if (['number', 'int', 'float', 'money', 'currency', 'percent'].indexOf(column.render.split(':')[0]) != -1) {
                        if (typeof rec[column.field] != 'number') rec[column.field] = parseFloat(rec[column.field]);
                    }
                    // date
                    if (['date', 'age'].indexOf(column.render.split(':')[0]) != -1) {
                        if (!rec[column.field + '_']) {
                            var dt = rec[column.field];
                            if (w2utils.isInt(dt)) dt = parseInt(dt);
                            rec[column.field + '_'] = new Date(dt);
                        }
                    }
                    // time
                    if (['time'].indexOf(column.render) != -1) {
                        if (w2utils.isTime(rec[column.field])) { // if string
                            var tmp = w2utils.isTime(rec[column.field], true);
                            var dt = new Date();
                            dt.setHours(tmp.hours, tmp.minutes, (tmp.seconds ? tmp.seconds : 0), 0); // sets hours, min, sec, mills
                            if (!rec[column.field + '_']) rec[column.field + '_'] = dt;
                        } else { // if date object
                            var tmp = rec[column.field];
                            if (w2utils.isInt(tmp)) tmp = parseInt(tmp);
                            var tmp = (tmp != null ? new Date(tmp) : new Date());
                            var dt = new Date();
                            dt.setHours(tmp.getHours(), tmp.getMinutes(), tmp.getSeconds(), 0); // sets hours, min, sec, mills
                            if (!rec[column.field + '_']) rec[column.field + '_'] = dt;
                        }
                    }
                }

                if (rec.w2ui &amp;&amp; rec.w2ui.children &amp;&amp; rec.w2ui.expanded !== true) {
                    // there are closed children, prepare them too.
                    for (var r = 0; r &lt; rec.w2ui.children.length; r++) {
                        var subRec = rec.w2ui.children[r];
                        prepareRecord(subRec);
                    }
                }
            }
        },

        nextCell: function (index, col_ind, editable) {
            var check = col_ind + 1;
            if (check >= this.columns.length) return null;
            var tmp = this.records[index].w2ui;
            var ccol = this.columns[col_ind];
            // if (tmp &amp;&amp; tmp.colspan[ccol.field]) check += parseInt(tmp.colspan[ccol.field]) -1; // colspan of a column
            var col = this.columns[check];
            var span = (tmp &amp;&amp; tmp.colspan &amp;&amp; !isNaN(tmp.colspan[col.field]) ? parseInt(tmp.colspan[col.field]) : 1);
            if (col == null) return null;
            if (col &amp;&amp; col.hidden || span === 0) return this.nextCell(index, check, editable);
            if (editable) {
                var edit = this.getCellEditable(index, col_ind);
                if (edit == null || ['checkbox', 'check'].indexOf(edit.type) != -1) {
                    return this.nextCell(index, check, editable);
                }
            }
            return check;
        },

        prevCell: function (index, col_ind, editable) {
            var check = col_ind - 1;
            if (check &lt; 0) return null;
            var tmp = this.records[index].w2ui;
            var col = this.columns[check];
            var span = (tmp &amp;&amp; tmp.colspan &amp;&amp; !isNaN(tmp.colspan[col.field]) ? parseInt(tmp.colspan[col.field]) : 1);
            if (col == null) return null;
            if (col &amp;&amp; col.hidden || span === 0) return this.prevCell(index, check, editable);
            if (editable) {
                var edit = this.getCellEditable(index, col_ind);
                if (edit == null || ['checkbox', 'check'].indexOf(edit.type) != -1) {
                    return this.prevCell(index, check, editable);
                }
            }
            return check;
        },

        nextRow: function (ind, col_ind) {
            var sids = this.last.searchIds;
            var ret = null;
            if ((ind + 1 &lt; this.records.length &amp;&amp; sids.length === 0) // if there are more records
                || (sids.length > 0 &amp;&amp; ind &lt; sids[sids.length - 1])) {
                ind++;
                if (sids.length > 0) while (true) {
                    if ($.inArray(ind, sids) != -1 || ind > this.records.length) break;
                    ind++;
                }
                // colspan
                var tmp = this.records[ind].w2ui;
                var col = this.columns[col_ind];
                var span = (tmp &amp;&amp; tmp.colspan &amp;&amp; col != null &amp;&amp; !isNaN(tmp.colspan[col.field]) ? parseInt(tmp.colspan[col.field]) : 1);
                if (span === 0) {
                    ret = this.nextRow(ind, col_ind);
                } else {
                    ret = ind;
                }
            }
            return ret;
        },

        prevRow: function (ind, col_ind) {
            var sids = this.last.searchIds;
            var ret = null;
            if ((ind > 0 &amp;&amp; sids.length === 0)  // if there are more records
                || (sids.length > 0 &amp;&amp; ind > sids[0])) {
                ind--;
                if (sids.length > 0) while (true) {
                    if ($.inArray(ind, sids) != -1 || ind &lt; 0) break;
                    ind--;
                }
                // colspan
                var tmp = this.records[ind].w2ui;
                var col = this.columns[col_ind];
                var span = (tmp &amp;&amp; tmp.colspan &amp;&amp; col != null &amp;&amp; !isNaN(tmp.colspan[col.field]) ? parseInt(tmp.colspan[col.field]) : 1);
                if (span === 0) {
                    ret = this.prevRow(ind, col_ind);
                } else {
                    ret = ind;
                }
            }
            return ret;
        },

        selectionSave: function () {
            this.last._selection = this.getSelection();
            return this.last._selection;
        },

        selectionRestore: function (noRefresh) {
            var time = (new Date()).getTime();
            this.last.selection = {indexes: [], columns: {}};
            var sel = this.last.selection;
            var lst = this.last._selection;
            for (var i = 0; i &lt; lst.length; i++) {
                if ($.isPlainObject(lst[i])) {
                    // selectType: cell
                    var tmp = this.get(lst[i].recid, true);
                    if (tmp != null) {
                        if (sel.indexes.indexOf(tmp) == -1) sel.indexes.push(tmp);
                        if (!sel.columns[tmp]) sel.columns[tmp] = [];
                        sel.columns[tmp].push(lst[i].column);
                    }
                } else {
                    // selectType: row
                    var tmp = this.get(lst[i], true);
                    if (tmp != null) sel.indexes.push(tmp);
                }
            }
            delete this.last._selection;
            if (noRefresh !== true) this.refresh();
            return (new Date()).getTime() - time;
        },

        message: function (options, callBack) {
            if (typeof options == 'string') {
                options = {
                    width: (options.length &lt; 300 ? 350 : 550),
                    height: (options.length &lt; 300 ? 170 : 250),
                    body: '&lt;div class="w2ui-centered">' + options + '&lt;/div>',
                    buttons: '&lt;button class="w2ui-btn" onclick="w2ui[\'' + this.name + '\'].message()">Ok&lt;/button>',
                    onOpen: function (event) {
                        setTimeout(function () {
                            $(this.box).find('.w2ui-btn').focus();
                        }, 25);
                    },
                    onClose: function (even) {
                        if (typeof callBack == 'function') callBack();
                    }
                };
            }
            w2utils.message.call(this, {
                box: this.box,
                path: 'w2ui.' + this.name,
                title: '.w2ui-grid-header:visible',
                body: '.w2ui-grid-box'
            }, options);
        }
    };

    $.extend(w2grid.prototype, w2utils.event);
    w2obj.grid = w2grid;
})(jQuery);

/************************************************************************
 *   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
 *   - Following objects defined
 *        - w2layout        - layout widget
 *        - $().w2layout    - jQuery wrapper
 *   - Dependencies: jQuery, w2utils, w2toolbar, w2tabs
 *
 * == NICE TO HAVE ==
 *   - onResize for the panel
 *   - add more panel title positions (left=rotated, right=rotated, bottom)
 *   - bug: when you assign content before previous transition completed.
 *
 ************************************************************************/

(function ($) {
    var w2layout = function (options) {
        this.box = null;     // DOM Element that holds the element
        this.name = null;     // unique name for w2ui
        this.panels = [];
        this.tmp = {};
        this.padding = 1;        // panel padding
        this.resizer = 4;        // resizer width or height
        this.style = '';

        $.extend(true, this, w2obj.layout, options);
    };

    var w2panels = ['top', 'left', 'main', 'preview', 'right', 'bottom'];

    // ====================================================
    // -- Registers as a jQuery plugin

    $.fn.w2layout = function (method) {
        if ($.isPlainObject(method)) {
            // check name parameter
            if (!w2utils.checkName(method, 'w2layout')) return;
            var panels = method.panels || [];
            var object = new w2layout(method);
            $.extend(object, {handlers: [], panels: []});
            // add defined panels
            for (var p = 0, len = panels.length; p &lt; len; p++) {
                object.panels[p] = $.extend(true, {}, w2layout.prototype.panel, panels[p]);
                if ($.isPlainObject(object.panels[p].tabs) || $.isArray(object.panels[p].tabs)) initTabs(object, panels[p].type);
                if ($.isPlainObject(object.panels[p].toolbar) || $.isArray(object.panels[p].toolbar)) initToolbar(object, panels[p].type);
            }
            // add all other panels
            for (var p1 = 0; p1 &lt; w2panels.length; p1++) {
                if (object.get(w2panels[p1]) != null) continue;
                object.panels.push($.extend(true, {}, w2layout.prototype.panel, {
                    type: w2panels[p1],
                    hidden: (w2panels[p1] !== 'main'),
                    size: 50
                }));
            }
            if ($(this).length > 0) {
                object.render($(this)[0]);
            }
            w2ui[object.name] = object;
            return object;

        } else {
            var obj = w2ui[$(this).attr('name')];
            if (!obj) return null;
            if (arguments.length > 0) {
                if (obj[method]) obj[method].apply(obj, Array.prototype.slice.call(arguments, 1));
                return this;
            } else {
                return obj;
            }
        }

        function initTabs(object, panel, tabs) {
            var pan = object.get(panel);
            if (pan != null &amp;&amp; tabs == null) tabs = pan.tabs;
            if (pan == null || tabs == null) return false;
            // instanciate tabs
            if ($.isArray(tabs)) tabs = {tabs: tabs};
            $().w2destroy(object.name + '_' + panel + '_tabs'); // destroy if existed
            pan.tabs = $().w2tabs($.extend({}, tabs, {owner: object, name: object.name + '_' + panel + '_tabs'}));
            pan.show.tabs = true;
            return true;
        }

        function initToolbar(object, panel, toolbar) {
            var pan = object.get(panel);
            if (pan != null &amp;&amp; toolbar == null) toolbar = pan.toolbar;
            if (pan == null || toolbar == null) return false;
            // instanciate toolbar
            if ($.isArray(toolbar)) toolbar = {items: toolbar};
            $().w2destroy(object.name + '_' + panel + '_toolbar'); // destroy if existed
            pan.toolbar = $().w2toolbar($.extend({}, toolbar, {
                owner: object,
                name: object.name + '_' + panel + '_toolbar'
            }));
            pan.show.toolbar = true;
            return true;
        }
    };

    // ====================================================
    // -- Implementation of core functionality

    w2layout.prototype = {
        onShow: null,
        onHide: null,
        onResizing: null,
        onResizerClick: null,
        onRender: null,
        onRefresh: null,
        onContent: null,
        onResize: null,
        onDestroy: null,

        // default setting for a panel
        panel: {
            type: null,       // left, right, top, bottom
            title: '',
            size: 100,        // width or height depending on panel name
            minSize: 20,
            maxSize: false,
            hidden: false,
            resizable: false,
            overflow: 'auto',
            style: '',
            content: '',         // can be String or Object with .render(box) method
            tabs: null,
            toolbar: null,
            width: null,       // read only
            height: null,       // read only
            show: {
                toolbar: false,
                tabs: false
            },
            onRefresh: null,
            onShow: null,
            onHide: null
        },

        // alias for content
        html: function (panel, data, transition) {
            return this.content(panel, data, transition);
        },

        content: function (panel, data, transition) {
            var obj = this;
            var p = this.get(panel);
            // if it is CSS panel
            if (panel == 'css') {
                $('#layout_' + obj.name + '_panel_css').html('&lt;style>' + data + '&lt;/style>');
                return true;
            }
            if (p == null) return false;
            if (data == null) {
                return p.content;
            }
            // event before
            var edata = this.trigger({
                phase: 'before',
                type: 'content',
                target: panel,
                object: p,
                content: data,
                transition: transition
            });
            if (edata.isCancelled === true) return;

            if (data instanceof jQuery) {
                console.log('ERROR: You can not pass jQuery object to w2layout.content() method');
                return false;
            }
            var pname = '#layout_' + this.name + '_panel_' + p.type;
            var current = $(pname + '> .w2ui-panel-content');
            var panelTop = 0;
            if (current.length > 0) {
                $(pname).scrollTop(0);
                panelTop = $(current).position().top;
            }
            if (p.content === '') {
                p.content = data;
                this.refresh(panel);
            } else {
                p.content = data;
                if (!p.hidden) {
                    if (transition != null &amp;&amp; transition !== '') {
                        // apply transition
                        var div1 = $(pname + '> .w2ui-panel-content');
                        div1.after('&lt;div class="w2ui-panel-content new-panel" style="' + div1[0].style.cssText + '">&lt;/div>');
                        var div2 = $(pname + '> .w2ui-panel-content.new-panel');
                        div1.css('top', panelTop);
                        div2.css('top', panelTop);
                        if (typeof data == 'object') {
                            data.box = div2[0]; // do not do .render(box);
                            data.render();
                        } else {
                            div2.html(data);
                        }
                        w2utils.transition(div1[0], div2[0], transition, function () {
                            div1.remove();
                            div2.removeClass('new-panel');
                            div2.css('overflow', p.overflow);
                            // IE Hack
                            obj.resize();
                            if (window.navigator.userAgent.indexOf('MSIE') != -1) setTimeout(function () {
                                obj.resize();
                            }, 100);
                        });
                    }
                }
                this.refresh(panel);
            }
            // event after
            obj.trigger($.extend(edata, {phase: 'after'}));
            // IE Hack
            obj.resize();
            if (window.navigator.userAgent.indexOf('MSIE') != -1) setTimeout(function () {
                obj.resize();
            }, 100);
            return true;
        },

        message: function (panel, options) {
            var obj = this;
            if (typeof options == 'string') {
                options = {
                    width: (options.length &lt; 300 ? 350 : 550),
                    height: (options.length &lt; 300 ? 170 : 250),
                    body: '&lt;div class="w2ui-centered">' + options + '&lt;/div>',
                    buttons: '&lt;button class="w2ui-btn" onclick="w2ui[\'' + this.name + '\'].message(\'' + panel + '\')">Ok&lt;/button>',
                    onOpen: function (event) {
                        setTimeout(function () {
                            $(this.box).find('.w2ui-btn').focus();
                        }, 25);
                    }
                };
            }
            var p = this.get(panel);
            var $el = $('#layout_' + this.name + '_panel_' + p.type);
            var oldOverflow = $el.css('overflow');
            var oldOnClose;
            if (options) {
                if (options.onClose) oldOnClose = options.onClose;
                options.onClose = function (event) {
                    if (typeof oldOnClose == 'function') oldOnClose(event);
                    event.done(function () {
                        $('#layout_' + obj.name + '_panel_' + p.type).css('overflow', oldOverflow);
                    });
                };
            }
            $('#layout_' + this.name + '_panel_' + p.type).css('overflow', 'hidden');
            w2utils.message.call(this, {
                box: $('#layout_' + this.name + '_panel_' + p.type),
                param: panel,
                path: 'w2ui.' + this.name,
                title: '.w2ui-panel-title:visible',
                body: '.w2ui-panel-content'
            }, options);
        },

        load: function (panel, url, transition, onLoad) {
            var obj = this;
            if (panel == 'css') {
                $.get(url, function (data, status, xhr) { // should always be $.get as it is template
                    obj.content(panel, xhr.responseText);
                    if (onLoad) onLoad();
                });
                return true;
            }
            if (this.get(panel) != null) {
                $.get(url, function (data, status, xhr) { // should always be $.get as it is template
                    obj.content(panel, xhr.responseText, transition);
                    if (onLoad) onLoad();
                    // IE Hack
                    obj.resize();
                    if (window.navigator.userAgent.indexOf('MSIE') != -1) setTimeout(function () {
                        obj.resize();
                    }, 100);
                });
                return true;
            }
            return false;
        },

        sizeTo: function (panel, size, instant) {
            var obj = this;
            var pan = obj.get(panel);
            if (pan == null) return false;
            // resize
            $(obj.box).find(' > div > .w2ui-panel')
                .css(w2utils.cssPrefix('transition', (instant !== true ? '.2s' : '0s')));
            setTimeout(function () {
                obj.set(panel, {size: size});
            }, 1);
            // clean
            setTimeout(function () {
                $(obj.box).find(' > div > .w2ui-panel').css(w2utils.cssPrefix('transition', '0s'));
                obj.resize();
            }, 500);
            return true;
        },

        show: function (panel, immediate) {
            var obj = this;
            // event before
            var edata = this.trigger({
                phase: 'before',
                type: 'show',
                target: panel,
                object: this.get(panel),
                immediate: immediate
            });
            if (edata.isCancelled === true) return;

            var p = obj.get(panel);
            if (p == null) return false;
            p.hidden = false;
            if (immediate === true) {
                $('#layout_' + obj.name + '_panel_' + panel).css({'opacity': '1'});
                obj.trigger($.extend(edata, {phase: 'after'}));
                obj.resize();
            } else {
                // resize
                $('#layout_' + obj.name + '_panel_' + panel).css({'opacity': '0'});
                $(obj.box).find(' > div > .w2ui-panel').css(w2utils.cssPrefix('transition', '.2s'));
                setTimeout(function () {
                    obj.resize();
                }, 1);
                // show
                setTimeout(function () {
                    $('#layout_' + obj.name + '_panel_' + panel).css({'opacity': '1'});
                }, 250);
                // clean
                setTimeout(function () {
                    $(obj.box).find(' > div > .w2ui-panel').css(w2utils.cssPrefix('transition', '0s'));
                    obj.trigger($.extend(edata, {phase: 'after'}));
                    obj.resize();
                }, 500);
            }
            return true;
        },

        hide: function (panel, immediate) {
            var obj = this;
            // event before
            var edata = this.trigger({
                phase: 'before',
                type: 'hide',
                target: panel,
                object: this.get(panel),
                immediate: immediate
            });
            if (edata.isCancelled === true) return;

            var p = obj.get(panel);
            if (p == null) return false;
            p.hidden = true;
            if (immediate === true) {
                $('#layout_' + obj.name + '_panel_' + panel).css({'opacity': '0'});
                obj.trigger($.extend(edata, {phase: 'after'}));
                obj.resize();
            } else {
                // hide
                $(obj.box).find(' > div > .w2ui-panel').css(w2utils.cssPrefix('transition', '.2s'));
                $('#layout_' + obj.name + '_panel_' + panel).css({'opacity': '0'});
                setTimeout(function () {
                    obj.resize();
                }, 1);
                // clean
                setTimeout(function () {
                    $(obj.box).find(' > div > .w2ui-panel').css(w2utils.cssPrefix('transition', '0s'));
                    obj.trigger($.extend(edata, {phase: 'after'}));
                    obj.resize();
                }, 500);
            }
            return true;
        },

        toggle: function (panel, immediate) {
            var p = this.get(panel);
            if (p == null) return false;
            if (p.hidden) return this.show(panel, immediate); else return this.hide(panel, immediate);
        },

        set: function (panel, options) {
            var ind = this.get(panel, true);
            if (ind == null) return false;
            $.extend(this.panels[ind], options);
            // refresh only when content changed
            if (options.content != null || options.resizable != null) {
                this.refresh(panel);
            }
            // show/hide resizer
            this.resize(); // resize is needed when panel size is changed
            return true;
        },

        get: function (panel, returnIndex) {
            for (var p = 0; p &lt; this.panels.length; p++) {
                if (this.panels[p].type == panel) {
                    if (returnIndex === true) return p; else return this.panels[p];
                }
            }
            return null;
        },

        el: function (panel) {
            var el = $('#layout_' + this.name + '_panel_' + panel + '> .w2ui-panel-content');
            if (el.length != 1) return null;
            return el[0];
        },

        hideToolbar: function (panel) {
            var pan = this.get(panel);
            if (!pan) return;
            pan.show.toolbar = false;
            $('#layout_' + this.name + '_panel_' + panel + '> .w2ui-panel-toolbar').hide();
            this.resize();
        },

        showToolbar: function (panel) {
            var pan = this.get(panel);
            if (!pan) return;
            pan.show.toolbar = true;
            $('#layout_' + this.name + '_panel_' + panel + '> .w2ui-panel-toolbar').show();
            this.resize();
        },

        toggleToolbar: function (panel) {
            var pan = this.get(panel);
            if (!pan) return;
            if (pan.show.toolbar) this.hideToolbar(panel); else this.showToolbar(panel);
        },

        assignToolbar: function (panel, toolbar) {
            if (typeof toolbar == 'string' &amp;&amp; w2ui[toolbar] != null) toolbar = w2ui[toolbar];
            var pan = this.get(panel);
            pan.toolbar = toolbar;
            var tmp = $(this.box).find(panel + '> .w2ui-panel-toolbar');
            if (pan.toolbar != null) {
                if (tmp.find('[name=' + pan.toolbar.name + ']').length === 0) {
                    tmp.w2render(pan.toolbar);
                } else if (pan.toolbar != null) {
                    pan.toolbar.refresh();
                }
                this.showToolbar(panel);
                this.refresh('main');
            } else {
                tmp.html('');
                this.hideToolbar(panel);
            }
        },

        hideTabs: function (panel) {
            var pan = this.get(panel);
            if (!pan) return;
            pan.show.tabs = false;
            $('#layout_' + this.name + '_panel_' + panel + '> .w2ui-panel-tabs').hide();
            this.resize();
        },

        showTabs: function (panel) {
            var pan = this.get(panel);
            if (!pan) return;
            pan.show.tabs = true;
            $('#layout_' + this.name + '_panel_' + panel + '> .w2ui-panel-tabs').show();
            this.resize();
        },

        toggleTabs: function (panel) {
            var pan = this.get(panel);
            if (!pan) return;
            if (pan.show.tabs) this.hideTabs(panel); else this.showTabs(panel);
        },

        render: function (box) {
            var obj = this;
            // if (window.getSelection) window.getSelection().removeAllRanges(); // clear selection
            var time = (new Date()).getTime();
            // event before
            var edata = obj.trigger({phase: 'before', type: 'render', target: obj.name, box: box});
            if (edata.isCancelled === true) return;

            if (box != null) {
                if ($(obj.box).find('#layout_' + obj.name + '_panel_main').length > 0) {
                    $(obj.box)
                        .removeAttr('name')
                        .removeClass('w2ui-layout')
                        .html('');
                }
                obj.box = box;
            }
            if (!obj.box) return false;
            $(obj.box)
                .attr('name', obj.name)
                .addClass('w2ui-layout')
                .html('&lt;div>&lt;/div>');
            if ($(obj.box).length > 0) $(obj.box)[0].style.cssText += obj.style;
            // create all panels
            for (var p1 = 0; p1 &lt; w2panels.length; p1++) {
                var pan = obj.get(w2panels[p1]);
                var html = '&lt;div id="layout_' + obj.name + '_panel_' + w2panels[p1] + '" class="w2ui-panel">' +
                    '    &lt;div class="w2ui-panel-title">&lt;/div>' +
                    '    &lt;div class="w2ui-panel-tabs">&lt;/div>' +
                    '    &lt;div class="w2ui-panel-toolbar">&lt;/div>' +
                    '    &lt;div class="w2ui-panel-content">&lt;/div>' +
                    '&lt;/div>' +
                    '&lt;div id="layout_' + obj.name + '_resizer_' + w2panels[p1] + '" class="w2ui-resizer">&lt;/div>';
                $(obj.box).find(' > div').append(html);
                // tabs are rendered in refresh()
            }
            $(obj.box).find(' > div')
                .append('&lt;div id="layout_' + obj.name + '_panel_css" style="position: absolute; top: 10000px;">&lt;/div>');
            obj.refresh(); // if refresh is not called here, the layout will not be available right after initialization
            // process event
            obj.trigger($.extend(edata, {phase: 'after'}));
            // reinit events
            setTimeout(function () { // needed this timeout to allow browser to render first if there are tabs or toolbar
                initEvents();
                obj.resize();
            }, 0);
            return (new Date()).getTime() - time;

            function initEvents() {
                obj.tmp.events = {
                    resize: function (event) {
                        w2ui[obj.name].resize();
                    },
                    resizeStart: resizeStart,
                    mouseMove: resizeMove,
                    mouseUp: resizeStop
                };
                $(window).on('resize', obj.tmp.events.resize);
            }

            function resizeStart(type, evnt) {
                if (!obj.box) return;
                if (!evnt) evnt = window.event;
                $(document).off('mousemove', obj.tmp.events.mouseMove).on('mousemove', obj.tmp.events.mouseMove);
                $(document).off('mouseup', obj.tmp.events.mouseUp).on('mouseup', obj.tmp.events.mouseUp);
                obj.tmp.resize = {
                    type: type,
                    x: evnt.screenX,
                    y: evnt.screenY,
                    diff_x: 0,
                    diff_y: 0,
                    value: 0
                };
                // lock all panels
                for (var p1 = 0; p1 &lt; w2panels.length; p1++) {
                    var $tmp = $(obj.el(w2panels[p1])).parent().find('.w2ui-lock');
                    if ($tmp.length > 0) {
                        $tmp.attr('locked', 'previous');
                    } else {
                        obj.lock(w2panels[p1], {opacity: 0});
                    }
                }
                if (type == 'left' || type == 'right') {
                    obj.tmp.resize.value = parseInt($('#layout_' + obj.name + '_resizer_' + type)[0].style.left);
                }
                if (type == 'top' || type == 'preview' || type == 'bottom') {
                    obj.tmp.resize.value = parseInt($('#layout_' + obj.name + '_resizer_' + type)[0].style.top);
                }
            }

            function resizeStop(evnt) {
                if (!obj.box) return;
                if (!evnt) evnt = window.event;
                $(document).off('mousemove', obj.tmp.events.mouseMove);
                $(document).off('mouseup', obj.tmp.events.mouseUp);
                if (obj.tmp.resize == null) return;
                // unlock all panels
                for (var p1 = 0; p1 &lt; w2panels.length; p1++) {
                    var $tmp = $(obj.el(w2panels[p1])).parent().find('.w2ui-lock');
                    if ($tmp.attr('locked') == 'previous') {
                        $tmp.removeAttr('locked');
                    } else {
                        obj.unlock(w2panels[p1]);
                    }
                }
                // set new size
                if (obj.tmp.diff_x !== 0 || obj.tmp.resize.diff_y !== 0) { // only recalculate if changed
                    var ptop = obj.get('top');
                    var pbottom = obj.get('bottom');
                    var panel = obj.get(obj.tmp.resize.type);
                    var height = parseInt($(obj.box).height());
                    var width = parseInt($(obj.box).width());
                    var str = String(panel.size);
                    var ns, nd;
                    switch (obj.tmp.resize.type) {
                        case 'top':
                            ns = parseInt(panel.sizeCalculated) + obj.tmp.resize.diff_y;
                            nd = 0;
                            break;
                        case 'bottom':
                            ns = parseInt(panel.sizeCalculated) - obj.tmp.resize.diff_y;
                            nd = 0;
                            break;
                        case 'preview':
                            ns = parseInt(panel.sizeCalculated) - obj.tmp.resize.diff_y;
                            nd = (ptop &amp;&amp; !ptop.hidden ? ptop.sizeCalculated : 0) +
                                (pbottom &amp;&amp; !pbottom.hidden ? pbottom.sizeCalculated : 0);
                            break;
                        case 'left':
                            ns = parseInt(panel.sizeCalculated) + obj.tmp.resize.diff_x;
                            nd = 0;
                            break;
                        case 'right':
                            ns = parseInt(panel.sizeCalculated) - obj.tmp.resize.diff_x;
                            nd = 0;
                            break;
                    }
                    // set size
                    if (str.substr(str.length - 1) == '%') {
                        panel.size = Math.floor(ns * 100 / (panel.type == 'left' || panel.type == 'right' ? width : height - nd) * 100) / 100 + '%';
                    } else {
                        if (String(panel.size).substr(0, 1) == '-') {
                            panel.size = parseInt(panel.size) - panel.sizeCalculated + ns;
                        } else {
                            panel.size = ns;
                        }
                    }
                    obj.resize();
                }
                $('#layout_' + obj.name + '_resizer_' + obj.tmp.resize.type).removeClass('active');
                delete obj.tmp.resize;
            }

            function resizeMove(evnt) {
                if (!obj.box) return;
                if (!evnt) evnt = window.event;
                if (obj.tmp.resize == null) return;
                var panel = obj.get(obj.tmp.resize.type);
                // event before
                var tmp = obj.tmp.resize;
                var edata = obj.trigger({
                    phase: 'before', type: 'resizing', target: obj.name, object: panel, originalEvent: evnt,
                    panel: tmp ? tmp.type : 'all', diff_x: tmp ? tmp.diff_x : 0, diff_y: tmp ? tmp.diff_y : 0
                });
                if (edata.isCancelled === true) return;

                var p = $('#layout_' + obj.name + '_resizer_' + tmp.type);
                var resize_x = (evnt.screenX - tmp.x);
                var resize_y = (evnt.screenY - tmp.y);
                var mainPanel = obj.get('main');

                if (!p.hasClass('active')) p.addClass('active');

                switch (tmp.type) {
                    case 'left':
                        if (panel.minSize - resize_x > panel.width) {
                            resize_x = panel.minSize - panel.width;
                        }
                        if (panel.maxSize &amp;&amp; (panel.width + resize_x > panel.maxSize)) {
                            resize_x = panel.maxSize - panel.width;
                        }
                        if (mainPanel.minSize + resize_x > mainPanel.width) {
                            resize_x = mainPanel.width - mainPanel.minSize;
                        }
                        break;

                    case 'right':
                        if (panel.minSize + resize_x > panel.width) {
                            resize_x = panel.width - panel.minSize;
                        }
                        if (panel.maxSize &amp;&amp; (panel.width - resize_x > panel.maxSize)) {
                            resize_x = panel.width - panel.maxSize;
                        }
                        if (mainPanel.minSize - resize_x > mainPanel.width) {
                            resize_x = mainPanel.minSize - mainPanel.width;
                        }
                        break;

                    case 'top':
                        if (panel.minSize - resize_y > panel.height) {
                            resize_y = panel.minSize - panel.height;
                        }
                        if (panel.maxSize &amp;&amp; (panel.height + resize_y > panel.maxSize)) {
                            resize_y = panel.maxSize - panel.height;
                        }
                        if (mainPanel.minSize + resize_y > mainPanel.height) {
                            resize_y = mainPanel.height - mainPanel.minSize;
                        }
                        break;

                    case 'preview':
                    case 'bottom':
                        if (panel.minSize + resize_y > panel.height) {
                            resize_y = panel.height - panel.minSize;
                        }
                        if (panel.maxSize &amp;&amp; (panel.height - resize_y > panel.maxSize)) {
                            resize_y = panel.height - panel.maxSize;
                        }
                        if (mainPanel.minSize - resize_y > mainPanel.height) {
                            resize_y = mainPanel.minSize - mainPanel.height;
                        }
                        break;
                }
                tmp.diff_x = resize_x;
                tmp.diff_y = resize_y;

                switch (tmp.type) {
                    case 'top':
                    case 'preview':
                    case 'bottom':
                        tmp.diff_x = 0;
                        if (p.length > 0) p[0].style.top = (tmp.value + tmp.diff_y) + 'px';
                        break;

                    case 'left':
                    case 'right':
                        tmp.diff_y = 0;
                        if (p.length > 0) p[0].style.left = (tmp.value + tmp.diff_x) + 'px';
                        break;
                }
                // event after
                obj.trigger($.extend(edata, {phase: 'after'}));
            }
        },

        refresh: function (panel) {
            var obj = this;
            // if (window.getSelection) window.getSelection().removeAllRanges(); // clear selection
            if (panel == null) panel = null;
            var time = (new Date()).getTime();
            // event before
            var edata = obj.trigger({
                phase: 'before',
                type: 'refresh',
                target: (panel != null ? panel : obj.name),
                object: obj.get(panel)
            });
            if (edata.isCancelled === true) return;
            // obj.unlock(panel);
            if (typeof panel == 'string') {
                var p = obj.get(panel);
                if (p == null) return;
                var pname = '#layout_' + obj.name + '_panel_' + p.type;
                var rname = '#layout_' + obj.name + '_resizer_' + p.type;
                // apply properties to the panel
                $(pname).css({display: p.hidden ? 'none' : 'block'});
                if (p.resizable) $(rname).show(); else $(rname).hide();
                // insert content
                if (typeof p.content == 'object' &amp;&amp; typeof p.content.render === 'function') {
                    p.content.box = $(pname + '> .w2ui-panel-content')[0];
                    setTimeout(function () {
                        // need to remove unnecessary classes
                        if ($(pname + '> .w2ui-panel-content').length > 0) {
                            $(pname + '> .w2ui-panel-content')
                                .removeClass()
                                .removeAttr('name')
                                .addClass('w2ui-panel-content')
                                .css('overflow', p.overflow)[0].style.cssText += ';' + p.style;
                        }
                        if (p.content &amp;&amp; typeof p.content.render == 'function') {
                            p.content.render(); // do not do .render(box);
                        }
                    }, 1);
                } else {
                    // need to remove unnecessary classes
                    if ($(pname + '> .w2ui-panel-content').length > 0) {
                        $(pname + '> .w2ui-panel-content')
                            .removeClass()
                            .removeAttr('name')
                            .addClass('w2ui-panel-content')
                            .html(p.content)
                            .css('overflow', p.overflow)[0].style.cssText += ';' + p.style;
                    }
                }
                // if there are tabs and/or toolbar - render it
                var tmp = $(obj.box).find(pname + '> .w2ui-panel-tabs');
                if (p.show.tabs) {
                    if (tmp.find('[name=' + p.tabs.name + ']').length === 0 &amp;&amp; p.tabs != null) tmp.w2render(p.tabs); else p.tabs.refresh();
                } else {
                    tmp.html('').removeClass('w2ui-tabs').hide();
                }
                tmp = $(obj.box).find(pname + '> .w2ui-panel-toolbar');
                if (p.show.toolbar) {
                    if (tmp.find('[name=' + p.toolbar.name + ']').length === 0 &amp;&amp; p.toolbar != null) tmp.w2render(p.toolbar); else p.toolbar.refresh();
                } else {
                    tmp.html('').removeClass('w2ui-toolbar').hide();
                }
                // show title
                tmp = $(obj.box).find(pname + '> .w2ui-panel-title');
                if (p.title) {
                    tmp.html(p.title).show();
                } else {
                    tmp.html('').hide();
                }
            } else {
                if ($('#layout_' + obj.name + '_panel_main').length === 0) {
                    obj.render();
                    return;
                }
                obj.resize();
                // refresh all of them
                for (var p1 = 0; p1 &lt; this.panels.length; p1++) {
                    obj.refresh(this.panels[p1].type);
                }
            }
            obj.trigger($.extend(edata, {phase: 'after'}));
            return (new Date()).getTime() - time;
        },

        resize: function () {
            // if (window.getSelection) window.getSelection().removeAllRanges();    // clear selection
            if (!this.box) return false;
            var time = (new Date()).getTime();
            // event before
            var tmp = this.tmp.resize;
            var edata = this.trigger({
                phase: 'before', type: 'resize', target: this.name,
                panel: tmp ? tmp.type : 'all', diff_x: tmp ? tmp.diff_x : 0, diff_y: tmp ? tmp.diff_y : 0
            });
            if (edata.isCancelled === true) return;
            if (this.padding &lt; 0) this.padding = 0;

            // layout itself
            var width = parseInt($(this.box).width());
            var height = parseInt($(this.box).height());
            $(this.box).find(' > div').css({
                width: width + 'px',
                height: height + 'px'
            });
            var obj = this;
            // panels
            var pmain = this.get('main');
            var pprev = this.get('preview');
            var pleft = this.get('left');
            var pright = this.get('right');
            var ptop = this.get('top');
            var pbottom = this.get('bottom');
            var smain = true; // main always on
            var sprev = (pprev != null &amp;&amp; pprev.hidden !== true ? true : false);
            var sleft = (pleft != null &amp;&amp; pleft.hidden !== true ? true : false);
            var sright = (pright != null &amp;&amp; pright.hidden !== true ? true : false);
            var stop = (ptop != null &amp;&amp; ptop.hidden !== true ? true : false);
            var sbottom = (pbottom != null &amp;&amp; pbottom.hidden !== true ? true : false);
            var l, t, w, h, e;
            // calculate %
            for (var p = 0; p &lt; w2panels.length; p++) {
                if (w2panels[p] === 'main') continue;
                tmp = this.get(w2panels[p]);
                if (!tmp) continue;
                var str = String(tmp.size || 0);
                if (str.substr(str.length - 1) == '%') {
                    var tmph = height;
                    if (tmp.type == 'preview') {
                        tmph = tmph -
                            (ptop &amp;&amp; !ptop.hidden ? ptop.sizeCalculated : 0) -
                            (pbottom &amp;&amp; !pbottom.hidden ? pbottom.sizeCalculated : 0);
                    }
                    tmp.sizeCalculated = parseInt((tmp.type == 'left' || tmp.type == 'right' ? width : tmph) * parseFloat(tmp.size) / 100);
                } else {
                    tmp.sizeCalculated = parseInt(tmp.size);
                }
                tmp.sizeCalculated = Math.max(tmp.sizeCalculated, parseInt(tmp.minSize));
            }
            // negative size
            if (String(pright.size).substr(0, 1) == '-') {
                if (sleft &amp;&amp; pleft.size.substr(0, 1) == '-') {
                    console.log('ERROR: you cannot have both left panel.size and right panel.size be negative.');
                } else {
                    pright.sizeCalculated = width - (sleft ? pleft.sizeCalculated : 0) + parseInt(pright.size);
                }
            }
            if (String(pleft.size).substr(0, 1) == '-') {
                if (sright &amp;&amp; pright.size.substr(0, 1) == '-') {
                    console.log('ERROR: you cannot have both left panel.size and right panel.size be negative.');
                } else {
                    pleft.sizeCalculated = width - (sright ? pright.sizeCalculated : 0) + parseInt(pleft.size);
                }
            }
            // top if any
            if (ptop != null &amp;&amp; ptop.hidden !== true) {
                l = 0;
                t = 0;
                w = width;
                h = ptop.sizeCalculated;
                $('#layout_' + this.name + '_panel_top').css({
                    'display': 'block',
                    'left': l + 'px',
                    'top': t + 'px',
                    'width': w + 'px',
                    'height': h + 'px'
                }).show();
                ptop.width = w;
                ptop.height = h;
                // resizer
                if (ptop.resizable) {
                    t = ptop.sizeCalculated - (this.padding === 0 ? this.resizer : 0);
                    h = (this.resizer > this.padding ? this.resizer : this.padding);
                    $('#layout_' + this.name + '_resizer_top').show().css({
                        'display': 'block',
                        'left': l + 'px',
                        'top': t + 'px',
                        'width': w + 'px',
                        'height': h + 'px',
                        'cursor': 'ns-resize'
                    }).off('mousedown').on('mousedown', function (event) {
                        // event before
                        var edata = obj.trigger({
                            phase: 'before',
                            type: 'resizerClick',
                            target: 'top',
                            originalEvent: event
                        });
                        if (edata.isCancelled === true) return;
                        // default action
                        w2ui[obj.name].tmp.events.resizeStart('top', event);
                        // event after
                        obj.trigger($.extend(edata, {phase: 'after'}));
                        return false;
                    });
                }
            } else {
                $('#layout_' + this.name + '_panel_top').hide();
                $('#layout_' + this.name + '_resizer_top').hide();
            }
            // left if any
            if (pleft != null &amp;&amp; pleft.hidden !== true) {
                l = 0;
                t = 0 + (stop ? ptop.sizeCalculated + this.padding : 0);
                w = pleft.sizeCalculated;
                h = height - (stop ? ptop.sizeCalculated + this.padding : 0) -
                    (sbottom ? pbottom.sizeCalculated + this.padding : 0);
                e = $('#layout_' + this.name + '_panel_left');
                if (window.navigator.userAgent.indexOf('MSIE') != -1 &amp;&amp; e.length > 0 &amp;&amp; e[0].clientHeight &lt; e[0].scrollHeight) w += 17; // IE hack
                e.css({
                    'display': 'block',
                    'left': l + 'px',
                    'top': t + 'px',
                    'width': w + 'px',
                    'height': h + 'px'
                }).show();
                pleft.width = w;
                pleft.height = h;
                // resizer
                if (pleft.resizable) {
                    l = pleft.sizeCalculated - (this.padding === 0 ? this.resizer : 0);
                    w = (this.resizer > this.padding ? this.resizer : this.padding);
                    $('#layout_' + this.name + '_resizer_left').show().css({
                        'display': 'block',
                        'left': l + 'px',
                        'top': t + 'px',
                        'width': w + 'px',
                        'height': h + 'px',
                        'cursor': 'ew-resize'
                    }).off('mousedown').on('mousedown', function (event) {
                        // event before
                        var edata = obj.trigger({
                            phase: 'before',
                            type: 'resizerClick',
                            target: 'left',
                            originalEvent: event
                        });
                        if (edata.isCancelled === true) return;
                        // default action
                        w2ui[obj.name].tmp.events.resizeStart('left', event);
                        // event after
                        obj.trigger($.extend(edata, {phase: 'after'}));
                        return false;
                    });
                }
            } else {
                $('#layout_' + this.name + '_panel_left').hide();
                $('#layout_' + this.name + '_resizer_left').hide();
            }
            // right if any
            if (pright != null &amp;&amp; pright.hidden !== true) {
                l = width - pright.sizeCalculated;
                t = 0 + (stop ? ptop.sizeCalculated + this.padding : 0);
                w = pright.sizeCalculated;
                h = height - (stop ? ptop.sizeCalculated + this.padding : 0) -
                    (sbottom ? pbottom.sizeCalculated + this.padding : 0);
                $('#layout_' + this.name + '_panel_right').css({
                    'display': 'block',
                    'left': l + 'px',
                    'top': t + 'px',
                    'width': w + 'px',
                    'height': h + 'px'
                }).show();
                pright.width = w;
                pright.height = h;
                // resizer
                if (pright.resizable) {
                    l = l - this.padding;
                    w = (this.resizer > this.padding ? this.resizer : this.padding);
                    $('#layout_' + this.name + '_resizer_right').show().css({
                        'display': 'block',
                        'left': l + 'px',
                        'top': t + 'px',
                        'width': w + 'px',
                        'height': h + 'px',
                        'cursor': 'ew-resize'
                    }).off('mousedown').on('mousedown', function (event) {
                        // event before
                        var edata = obj.trigger({
                            phase: 'before',
                            type: 'resizerClick',
                            target: 'right',
                            originalEvent: event
                        });
                        if (edata.isCancelled === true) return;
                        // default action
                        w2ui[obj.name].tmp.events.resizeStart('right', event);
                        // event after
                        obj.trigger($.extend(edata, {phase: 'after'}));
                        return false;
                    });
                }
            } else {
                $('#layout_' + this.name + '_panel_right').hide();
                $('#layout_' + this.name + '_resizer_right').hide();
            }
            // bottom if any
            if (pbottom != null &amp;&amp; pbottom.hidden !== true) {
                l = 0;
                t = height - pbottom.sizeCalculated;
                w = width;
                h = pbottom.sizeCalculated;
                $('#layout_' + this.name + '_panel_bottom').css({
                    'display': 'block',
                    'left': l + 'px',
                    'top': t + 'px',
                    'width': w + 'px',
                    'height': h + 'px'
                }).show();
                pbottom.width = w;
                pbottom.height = h;
                // resizer
                if (pbottom.resizable) {
                    t = t - (this.padding === 0 ? 0 : this.padding);
                    h = (this.resizer > this.padding ? this.resizer : this.padding);
                    $('#layout_' + this.name + '_resizer_bottom').show().css({
                        'display': 'block',
                        'left': l + 'px',
                        'top': t + 'px',
                        'width': w + 'px',
                        'height': h + 'px',
                        'cursor': 'ns-resize'
                    }).off('mousedown').on('mousedown', function (event) {
                        // event before
                        var edata = obj.trigger({
                            phase: 'before',
                            type: 'resizerClick',
                            target: 'bottom',
                            originalEvent: event
                        });
                        if (edata.isCancelled === true) return;
                        // default action
                        w2ui[obj.name].tmp.events.resizeStart('bottom', event);
                        // event after
                        obj.trigger($.extend(edata, {phase: 'after'}));
                        return false;
                    });
                }
            } else {
                $('#layout_' + this.name + '_panel_bottom').hide();
                $('#layout_' + this.name + '_resizer_bottom').hide();
            }
            // main - always there
            l = 0 + (sleft ? pleft.sizeCalculated + this.padding : 0);
            t = 0 + (stop ? ptop.sizeCalculated + this.padding : 0);
            w = width - (sleft ? pleft.sizeCalculated + this.padding : 0) -
                (sright ? pright.sizeCalculated + this.padding : 0);
            h = height - (stop ? ptop.sizeCalculated + this.padding : 0) -
                (sbottom ? pbottom.sizeCalculated + this.padding : 0) -
                (sprev ? pprev.sizeCalculated + this.padding : 0);
            e = $('#layout_' + this.name + '_panel_main');
            if (window.navigator.userAgent.indexOf('MSIE') != -1 &amp;&amp; e.length > 0 &amp;&amp; e[0].clientHeight &lt; e[0].scrollHeight) w += 17; // IE hack
            e.css({
                'display': 'block',
                'left': l + 'px',
                'top': t + 'px',
                'width': w + 'px',
                'height': h + 'px'
            });
            pmain.width = w;
            pmain.height = h;

            // preview if any
            if (pprev != null &amp;&amp; pprev.hidden !== true) {
                l = 0 + (sleft ? pleft.sizeCalculated + this.padding : 0);
                t = height - (sbottom ? pbottom.sizeCalculated + this.padding : 0) - pprev.sizeCalculated;
                w = width - (sleft ? pleft.sizeCalculated + this.padding : 0) -
                    (sright ? pright.sizeCalculated + this.padding : 0);
                h = pprev.sizeCalculated;
                e = $('#layout_' + this.name + '_panel_preview');
                if (window.navigator.userAgent.indexOf('MSIE') != -1 &amp;&amp; e.length > 0 &amp;&amp; e[0].clientHeight &lt; e[0].scrollHeight) w += 17; // IE hack
                e.css({
                    'display': 'block',
                    'left': l + 'px',
                    'top': t + 'px',
                    'width': w + 'px',
                    'height': h + 'px'
                }).show();
                pprev.width = w;
                pprev.height = h;
                // resizer
                if (pprev.resizable) {
                    t = t - (this.padding === 0 ? 0 : this.padding);
                    h = (this.resizer > this.padding ? this.resizer : this.padding);
                    $('#layout_' + this.name + '_resizer_preview').show().css({
                        'display': 'block',
                        'left': l + 'px',
                        'top': t + 'px',
                        'width': w + 'px',
                        'height': h + 'px',
                        'cursor': 'ns-resize'
                    }).off('mousedown').on('mousedown', function (event) {
                        // event before
                        var edata = obj.trigger({
                            phase: 'before',
                            type: 'resizerClick',
                            target: 'preview',
                            originalEvent: event
                        });
                        if (edata.isCancelled === true) return;
                        // default action
                        w2ui[obj.name].tmp.events.resizeStart('preview', event);
                        // event after
                        obj.trigger($.extend(edata, {phase: 'after'}));
                        return false;
                    });
                }
            } else {
                $('#layout_' + this.name + '_panel_preview').hide();
                $('#layout_' + this.name + '_resizer_preview').hide();
            }

            // display tabs and toolbar if needed
            for (var p1 = 0; p1 &lt; w2panels.length; p1++) {
                var pan = this.get(w2panels[p1]);
                var tmp2 = '#layout_' + this.name + '_panel_' + w2panels[p1] + ' > .w2ui-panel-';
                var tabHeight = 0;
                if (pan) {
                    if (pan.title) {
                        tabHeight += w2utils.getSize($(tmp2 + 'title').css({
                            top: tabHeight + 'px',
                            display: 'block'
                        }), 'height');
                    }
                    if (pan.show.tabs) {
                        if (pan.tabs != null &amp;&amp; w2ui[this.name + '_' + w2panels[p1] + '_tabs']) w2ui[this.name + '_' + w2panels[p1] + '_tabs'].resize();
                        tabHeight += w2utils.getSize($(tmp2 + 'tabs').css({
                            top: tabHeight + 'px',
                            display: 'block'
                        }), 'height');
                    }
                    if (pan.show.toolbar) {
                        if (pan.toolbar != null &amp;&amp; w2ui[this.name + '_' + w2panels[p1] + '_toolbar']) w2ui[this.name + '_' + w2panels[p1] + '_toolbar'].resize();
                        tabHeight += w2utils.getSize($(tmp2 + 'toolbar').css({
                            top: tabHeight + 'px',
                            display: 'block'
                        }), 'height');
                    }
                }
                $(tmp2 + 'content').css({display: 'block'}).css({top: tabHeight + 'px'});
            }
            // send resize to all objects
            clearTimeout(this._resize_timer);
            this._resize_timer = setTimeout(function () {
                for (var e in w2ui) {
                    if (typeof w2ui[e].resize == 'function') {
                        // sent to all none-layouts
                        if (w2ui[e].panels == null) w2ui[e].resize();
                        // only send to nested layouts
                        var parent = $(w2ui[e].box).parents('.w2ui-layout');
                        if (parent.length > 0 &amp;&amp; parent.attr('name') == obj.name) w2ui[e].resize();
                    }
                }
            }, 100);
            this.trigger($.extend(edata, {phase: 'after'}));
            return (new Date()).getTime() - time;
        },

        destroy: function () {
            // event before
            var edata = this.trigger({phase: 'before', type: 'destroy', target: this.name});
            if (edata.isCancelled === true) return;
            if (w2ui[this.name] == null) return false;
            // clean up
            if ($(this.box).find('#layout_' + this.name + '_panel_main').length > 0) {
                $(this.box)
                    .removeAttr('name')
                    .removeClass('w2ui-layout')
                    .html('');
            }
            delete w2ui[this.name];
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            if (this.tmp.events &amp;&amp; this.tmp.events.resize) $(window).off('resize', this.tmp.events.resize);
            return true;
        },

        lock: function (panel, msg, showSpinner) {
            if (w2panels.indexOf(panel) == -1) {
                console.log('ERROR: First parameter needs to be the a valid panel name.');
                return;
            }
            var args = Array.prototype.slice.call(arguments, 0);
            args[0] = '#layout_' + this.name + '_panel_' + panel;
            w2utils.lock.apply(window, args);
        },

        unlock: function (panel, speed) {
            if (w2panels.indexOf(panel) == -1) {
                console.log('ERROR: First parameter needs to be the a valid panel name.');
                return;
            }
            var nm = '#layout_' + this.name + '_panel_' + panel;
            w2utils.unlock(nm, speed);
        }
    };

    $.extend(w2layout.prototype, w2utils.event);
    w2obj.layout = w2layout;
})(jQuery);

/************************************************************************
 *   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
 *   - Following objects defined
 *        - w2popup      - popup widget
 *        - $().w2popup  - jQuery wrapper
 *   - Dependencies: jQuery, w2utils
 *
 * == NICE TO HAVE ==
 *   - hide overlay on esc
 *   - make popup width/height in %
 *
 ************************************************************************/

var w2popup = {};

(function ($) {

    // ====================================================
    // -- Registers as a jQuery plugin

    $.fn.w2popup = function (method, options) {
        if (method == null) {
            options = {};
            method = 'open';
        }
        if ($.isPlainObject(method)) {
            options = method;
            method = 'open';
        }
        method = method.toLowerCase();
        if (method === 'load' &amp;&amp; typeof options === 'string') {
            options = $.extend({url: options}, arguments.length > 2 ? arguments[2] : {});
        }
        if (method === 'open' &amp;&amp; options.url != null) method = 'load';
        options = options || {};
        // load options from markup
        var dlgOptions = {};
        if ($(this).length > 0 &amp;&amp; method == 'open') {
            if ($(this).find('div[rel=title], div[rel=body], div[rel=buttons]').length > 0) {
                // remember previous tempalte
                if ($('#w2ui-popup').length > 0) {
                    var tmp = $('#w2ui-popup').data('options');
                    w2popup._prev = {
                        template: w2popup._template,
                        title: tmp.title,
                        body: tmp.body,
                        buttons: tmp.buttons
                    };
                }
                w2popup._template = this;

                if ($(this).find('div[rel=title]').length > 0) {
                    dlgOptions['title'] = $(this).find('div[rel=title]');
                }
                if ($(this).find('div[rel=body]').length > 0) {
                    dlgOptions['body'] = $(this).find('div[rel=body]');
                    dlgOptions['style'] = $(this).find('div[rel=body]')[0].style.cssText;
                }
                if ($(this).find('div[rel=buttons]').length > 0) {
                    dlgOptions['buttons'] = $(this).find('div[rel=buttons]');
                }
            } else {
                dlgOptions['title'] = '&amp;#160;';
                dlgOptions['body'] = $(this).html();
            }
            if (parseInt($(this).css('width')) !== 0) dlgOptions['width'] = parseInt($(this).css('width'));
            if (parseInt($(this).css('height')) !== 0) dlgOptions['height'] = parseInt($(this).css('height'));
        }
        // show popup
        return w2popup[method]($.extend({}, dlgOptions, options));
    };

    // ====================================================
    // -- Implementation of core functionality (SINGLETON)

    w2popup = {
        defaults: {
            title: '',
            body: '',
            buttons: '',
            style: '',
            color: '#000',
            opacity: 0.4,
            speed: 0.3,
            modal: false,
            maximized: false,
            keyboard: true,     // will close popup on esc if not modal
            width: 500,
            height: 300,
            showClose: true,
            showMax: false,
            transition: null
        },
        status: 'closed',     // string that describes current status
        handlers: [],
        onOpen: null,
        onClose: null,
        onMax: null,
        onMin: null,
        onToggle: null,
        onKeydown: null,

        open: function (options) {
            var obj = this;
            if (w2popup.status == 'closing') {
                setTimeout(function () {
                    obj.open.call(obj, options);
                }, 100);
                return;
            }
            // get old options and merge them
            var old_options = $('#w2ui-popup').data('options');
            var options = $.extend({}, this.defaults, old_options, {
                title: '',
                body: '',
                buttons: ''
            }, options, {maximized: false});
            // need timer because popup might not be open
            setTimeout(function () {
                $('#w2ui-popup').data('options', options);
            }, 100);
            // if new - reset event handlers
            if ($('#w2ui-popup').length === 0) {
                // w2popup.handlers  = []; // if commented, allows to add w2popup.on() for all
                w2popup.onMax = null;
                w2popup.onMin = null;
                w2popup.onToggle = null;
                w2popup.onOpen = null;
                w2popup.onClose = null;
                w2popup.onKeydown = null;
            }
            if (options.onOpen) w2popup.onOpen = options.onOpen;
            if (options.onClose) w2popup.onClose = options.onClose;
            if (options.onMax) w2popup.onMax = options.onMax;
            if (options.onMin) w2popup.onMin = options.onMin;
            if (options.onToggle) w2popup.onToggle = options.onToggle;
            if (options.onKeydown) w2popup.onKeydown = options.onKeydown;
            options.width = parseInt(options.width);
            options.height = parseInt(options.height);

            var maxW, maxH;
            if (window.innerHeight == undefined) {
                maxW = parseInt(document.documentElement.offsetWidth);
                maxH = parseInt(document.documentElement.offsetHeight);
                if (w2utils.engine === 'IE7') {
                    maxW += 21;
                    maxH += 4;
                }
            } else {
                maxW = parseInt(window.innerWidth);
                maxH = parseInt(window.innerHeight);
            }
            if (maxW - 10 &lt; options.width) options.width = maxW - 10;
            if (maxH - 10 &lt; options.height) options.height = maxH - 10;
            var top = (maxH - options.height) / 2 * 0.6;
            var left = (maxW - options.width) / 2;

            // check if message is already displayed
            if ($('#w2ui-popup').length === 0) {
                // trigger event
                var edata = this.trigger({
                    phase: 'before',
                    type: 'open',
                    target: 'popup',
                    options: options,
                    present: false
                });
                if (edata.isCancelled === true) return;
                w2popup.status = 'opening';
                // output message
                w2popup.lockScreen(options);
                var btn = '';
                if (options.showClose) {
                    btn += '&lt;div class="w2ui-popup-button w2ui-popup-close" onmousedown="event.stopPropagation()" onclick="w2popup.close()">Close&lt;/div>';
                }
                if (options.showMax) {
                    btn += '&lt;div class="w2ui-popup-button w2ui-popup-max" onmousedown="event.stopPropagation()" onclick="w2popup.toggle()">Max&lt;/div>';
                }
                // first insert just body
                var msg = '&lt;div id="w2ui-popup" class="w2ui-popup" style="opacity: 0; left: ' + left + 'px; top: ' + top + 'px;' +
                    '     width: ' + parseInt(options.width) + 'px; height: ' + parseInt(options.height) + 'px; ' +
                    w2utils.cssPrefix('transform', 'scale(0.8)', true) + '">&lt;/div>';
                $('body').append(msg);
                // parse rel=*
                var parts = $('#w2ui-popup');
                if (parts.find('div[rel=title], div[rel=body], div[rel=buttons]').length > 0) {
                    // title
                    var tmp = parts.find('div[rel=title]');
                    if (tmp.length > 0) {
                        options.title = tmp.html();
                        tmp.remove();
                    }
                    // buttons
                    var tmp = parts.find('div[rel=buttons]');
                    if (tmp.length > 0) {
                        options.buttons = tmp.html();
                        tmp.remove();
                    }
                    // body
                    var tmp = parts.find('div[rel=body]');
                    if (tmp.length > 0) options.body = tmp.html(); else options.body = parts.html();
                }
                // then content
                var msg = '&lt;div class="w2ui-popup-title" style="' + (!options.title ? 'display: none' : '') + '">' + btn + '&lt;/div>' +
                    '&lt;div class="w2ui-box" style="' + (!options.title ? 'top: 0px !important;' : '') +
                    (!options.buttons ? 'bottom: 0px !important;' : '') + '">' +
                    '    &lt;div class="w2ui-popup-body' + (!options.title !== '' ? ' w2ui-popup-no-title' : '') +
                    (!options.buttons ? ' w2ui-popup-no-buttons' : '') + '" style="' + options.style + '">' +
                    '    &lt;/div>' +
                    '&lt;/div>' +
                    '&lt;div class="w2ui-popup-buttons" style="' + (!options.buttons ? 'display: none' : '') + '">&lt;/div>' +
                    '&lt;input class="w2ui-popup-hidden" style="position: absolute; top: -100px"/>'; // this is needed to keep focus in popup
                $('#w2ui-popup').html(msg);

                if (options.title) $('#w2ui-popup .w2ui-popup-title').append(options.title);
                if (options.buttons) $('#w2ui-popup .w2ui-popup-buttons').append(options.buttons);
                if (options.body) $('#w2ui-popup .w2ui-popup-body').append(options.body);

                // allow element to render
                setTimeout(function () {
                    $('#w2ui-popup')
                        .css('opacity', '1')
                        .css(w2utils.cssPrefix({
                            'transition': options.speed + 's opacity, ' + options.speed + 's -webkit-transform',
                            'transform': 'scale(1)'
                        }));
                    obj.focus();
                }, 1);
                // clean transform
                setTimeout(function () {
                    $('#w2ui-popup').css(w2utils.cssPrefix('transform', ''));
                    // event after
                    w2popup.status = 'open';
                    setTimeout(function () {
                        obj.trigger($.extend(edata, {phase: 'after'}));
                    }, 100);
                }, options.speed * 1000);

            } else {
                // if was from template and now not
                if (w2popup._prev == null &amp;&amp; w2popup._template != null) obj.restoreTemplate();

                // trigger event
                var edata = this.trigger({
                    phase: 'before',
                    type: 'open',
                    target: 'popup',
                    options: options,
                    present: true
                });
                if (edata.isCancelled === true) return;
                // check if size changed
                w2popup.status = 'opening';
                if (old_options != null) {
                    if (!old_options.maximized &amp;&amp; (old_options['width'] != options['width'] || old_options['height'] != options['height'])) {
                        w2popup.resize(options.width, options.height);
                    }
                    options.prevSize = options.width + 'px:' + options.height + 'px';
                    options.maximized = old_options.maximized;
                }
                // show new items
                var cloned = $('#w2ui-popup .w2ui-box').clone();
                cloned.removeClass('w2ui-box').addClass('w2ui-box-temp').find('.w2ui-popup-body').empty().append(options.body);
                // parse rel=*
                if (typeof options.body == 'string' &amp;&amp; cloned.find('div[rel=title], div[rel=body], div[rel=buttons]').length > 0) {
                    // title
                    var tmp = cloned.find('div[rel=title]');
                    if (tmp.length > 0) {
                        options['title'] = tmp.html();
                        tmp.remove();
                    }
                    // buttons
                    var tmp = cloned.find('div[rel=buttons]');
                    if (tmp.length > 0) {
                        options['buttons'] = tmp.html();
                        tmp.remove();
                    }
                    // body
                    var tmp = cloned.find('div[rel=body]');
                    if (tmp.length > 0) options['body'] = tmp.html(); else options['body'] = cloned.html();
                    // set proper body
                    cloned.html(options.body);
                }
                $('#w2ui-popup .w2ui-box').after(cloned);

                if (options.buttons) {
                    $('#w2ui-popup .w2ui-popup-buttons').show().html('').append(options.buttons);
                    $('#w2ui-popup .w2ui-popup-body').removeClass('w2ui-popup-no-buttons');
                    $('#w2ui-popup .w2ui-box, #w2ui-popup .w2ui-box-temp').css('bottom', '');
                } else {
                    $('#w2ui-popup .w2ui-popup-buttons').hide().html('');
                    $('#w2ui-popup .w2ui-popup-body').addClass('w2ui-popup-no-buttons');
                    $('#w2ui-popup .w2ui-box, #w2ui-popup .w2ui-box-temp').css('bottom', '0px');
                }
                if (options.title) {
                    $('#w2ui-popup .w2ui-popup-title')
                        .show()
                        .html((options.showClose ? '&lt;div class="w2ui-popup-button w2ui-popup-close" onmousedown="event.stopPropagation()" onclick="w2popup.close()">Close&lt;/div>' : '') +
                            (options.showMax ? '&lt;div class="w2ui-popup-button w2ui-popup-max" onmousedown="event.stopPropagation()" onclick="w2popup.toggle()">Max&lt;/div>' : ''))
                        .append(options.title);
                    $('#w2ui-popup .w2ui-popup-body').removeClass('w2ui-popup-no-title');
                    $('#w2ui-popup .w2ui-box, #w2ui-popup .w2ui-box-temp').css('top', '');
                } else {
                    $('#w2ui-popup .w2ui-popup-title').hide().html('');
                    $('#w2ui-popup .w2ui-popup-body').addClass('w2ui-popup-no-title');
                    $('#w2ui-popup .w2ui-box, #w2ui-popup .w2ui-box-temp').css('top', '0px');
                }
                // transition
                var div_old = $('#w2ui-popup .w2ui-box')[0];
                var div_new = $('#w2ui-popup .w2ui-box-temp')[0];
                w2utils.transition(div_old, div_new, options.transition, function () {
                    // clean up
                    obj.restoreTemplate();
                    $(div_old).remove();
                    $(div_new).removeClass('w2ui-box-temp').addClass('w2ui-box');
                    var $body = $(div_new).find('.w2ui-popup-body');
                    if ($body.length == 1) $body[0].style.cssText = options.style;
                    // remove max state
                    $('#w2ui-popup').data('prev-size', null);
                    // focus on first button
                    obj.focus();
                    // call event onChange
                    w2popup.status = 'open';
                    obj.trigger($.extend(edata, {phase: 'after'}));
                });
            }

            // save new options
            options._last_focus = $(':focus');
            // keyboard events
            if (options.keyboard) $(document).on('keydown', this.keydown);

            // initialize move
            var tmp = {
                resizing: false,
                mvMove: mvMove,
                mvStop: mvStop
            };
            $('#w2ui-popup .w2ui-popup-title').on('mousedown', function (event) {
                if (!w2popup.get().maximized) mvStart(event);
            });

            // handlers
            function mvStart(evnt) {
                if (!evnt) evnt = window.event;
                w2popup.status = 'moving';
                tmp.resizing = true;
                tmp.isLocked = $('#w2ui-popup > .w2ui-lock').length == 1 ? true : false;
                tmp.x = evnt.screenX;
                tmp.y = evnt.screenY;
                tmp.pos_x = $('#w2ui-popup').position().left;
                tmp.pos_y = $('#w2ui-popup').position().top;
                if (!tmp.isLocked) w2popup.lock({opacity: 0});
                $(document).on('mousemove', tmp.mvMove);
                $(document).on('mouseup', tmp.mvStop);
                if (evnt.stopPropagation) evnt.stopPropagation(); else evnt.cancelBubble = true;
                if (evnt.preventDefault) evnt.preventDefault(); else return false;
            }

            function mvMove(evnt) {
                if (tmp.resizing != true) return;
                if (!evnt) evnt = window.event;
                tmp.div_x = evnt.screenX - tmp.x;
                tmp.div_y = evnt.screenY - tmp.y;
                $('#w2ui-popup').css(w2utils.cssPrefix({
                    'transition': 'none',
                    'transform': 'translate3d(' + tmp.div_x + 'px, ' + tmp.div_y + 'px, 0px)'
                }));
            }

            function mvStop(evnt) {
                if (tmp.resizing != true) return;
                if (!evnt) evnt = window.event;
                w2popup.status = 'open';
                tmp.div_x = (evnt.screenX - tmp.x);
                tmp.div_y = (evnt.screenY - tmp.y);
                $('#w2ui-popup').css({
                    'left': (tmp.pos_x + tmp.div_x) + 'px',
                    'top': (tmp.pos_y + tmp.div_y) + 'px'
                }).css(w2utils.cssPrefix({
                    'transition': 'none',
                    'transform': 'translate3d(0px, 0px, 0px)'
                }));
                tmp.resizing = false;
                $(document).off('mousemove', tmp.mvMove);
                $(document).off('mouseup', tmp.mvStop);
                if (!tmp.isLocked) w2popup.unlock();
            }

            return this;
        },

        keydown: function (event) {
            var options = $('#w2ui-popup').data('options');
            if (options &amp;&amp; !options.keyboard) return;
            // trigger event
            var edata = w2popup.trigger({
                phase: 'before',
                type: 'keydown',
                target: 'popup',
                options: options,
                originalEvent: event
            });
            if (edata.isCancelled === true) return;
            // default behavior
            switch (event.keyCode) {
                case 27:
                    event.preventDefault();
                    if ($('#w2ui-popup .w2ui-message').length > 0) w2popup.message(); else w2popup.close();
                    break;
            }
            // event after
            w2popup.trigger($.extend(edata, {phase: 'after'}));
        },

        close: function (options) {
            var obj = this;
            var options = $.extend({}, $('#w2ui-popup').data('options'), options);
            if ($('#w2ui-popup').length === 0 || this.status == 'closed') return;
            if (this.status == 'opening') {
                setTimeout(function () {
                    w2popup.close();
                }, 100);
                return;
            }
            // trigger event
            var edata = this.trigger({phase: 'before', type: 'close', target: 'popup', options: options});
            if (edata.isCancelled === true) return;
            // default behavior
            w2popup.status = 'closing';
            $('#w2ui-popup')
                .css('opacity', '0')
                .css(w2utils.cssPrefix({
                    'transition': options.speed + 's opacity, ' + options.speed + 's -webkit-transform',
                    'transform': 'scale(0.9)'
                }));
            w2popup.unlockScreen(options);
            setTimeout(function () {
                // return template
                obj.restoreTemplate();
                $('#w2ui-popup').remove();
                w2popup.status = 'closed';
                // restore active
                if (options._last_focus.length > 0) options._last_focus.focus();
                // event after
                obj.trigger($.extend(edata, {phase: 'after'}));
            }, options.speed * 1000);
            // remove keyboard events
            if (options.keyboard) $(document).off('keydown', this.keydown);
        },

        toggle: function () {
            var obj = this;
            var options = $('#w2ui-popup').data('options');
            // trigger event
            var edata = this.trigger({phase: 'before', type: 'toggle', target: 'popup', options: options});
            if (edata.isCancelled === true) return;
            // defatul action
            if (options.maximized === true) w2popup.min(); else w2popup.max();
            // event after
            setTimeout(function () {
                obj.trigger($.extend(edata, {phase: 'after'}));
            }, (options.speed * 1000) + 50);
        },

        max: function () {
            var obj = this;
            var options = $('#w2ui-popup').data('options');
            if (options.maximized === true) return;
            // trigger event
            var edata = this.trigger({phase: 'before', type: 'max', target: 'popup', options: options});
            if (edata.isCancelled === true) return;
            // default behavior
            w2popup.status = 'resizing';
            options.prevSize = $('#w2ui-popup').css('width') + ':' + $('#w2ui-popup').css('height');
            // do resize
            w2popup.resize(10000, 10000, function () {
                w2popup.status = 'open';
                options.maximized = true;
                obj.trigger($.extend(edata, {phase: 'after'}));
                // resize gird, form, layout inside popup
                $('#w2ui-popup .w2ui-grid, #w2ui-popup .w2ui-form, #w2ui-popup .w2ui-layout').each(function () {
                    var name = $(this).attr('name');
                    if (w2ui[name] &amp;&amp; w2ui[name].resize) w2ui[name].resize();
                })
            });
        },

        min: function () {
            var obj = this;
            var options = $('#w2ui-popup').data('options');
            if (options.maximized !== true) return;
            var size = options.prevSize.split(':');
            // trigger event
            var edata = this.trigger({phase: 'before', type: 'min', target: 'popup', options: options});
            if (edata.isCancelled === true) return;
            // default behavior
            w2popup.status = 'resizing';
            // do resize
            w2popup.resize(parseInt(size[0]), parseInt(size[1]), function () {
                w2popup.status = 'open';
                options.maximized = false;
                options.prevSize = null;
                obj.trigger($.extend(edata, {phase: 'after'}));
                // resize gird, form, layout inside popup
                $('#w2ui-popup .w2ui-grid, #w2ui-popup .w2ui-form, #w2ui-popup .w2ui-layout').each(function () {
                    var name = $(this).attr('name');
                    if (w2ui[name] &amp;&amp; w2ui[name].resize) w2ui[name].resize();
                })
            });
        },

        get: function () {
            return $('#w2ui-popup').data('options');
        },

        set: function (options) {
            w2popup.open(options);
        },

        clear: function () {
            $('#w2ui-popup .w2ui-popup-title').html('');
            $('#w2ui-popup .w2ui-popup-body').html('');
            $('#w2ui-popup .w2ui-popup-buttons').html('');
        },

        reset: function () {
            w2popup.open(w2popup.defaults);
        },

        load: function (options) {
            w2popup.status = 'loading';
            if (options.url == null) {
                console.log('ERROR: The url parameter is empty.');
                return;
            }
            var tmp = String(options.url).split('#');
            var url = tmp[0];
            var selector = tmp[1];
            if (options == null) options = {};
            // load url
            var html = $('#w2ui-popup').data(url);
            if (html != null) {
                popup(html, selector);
            } else {
                $.get(url, function (data, status, obj) { // should always be $.get as it is template
                    popup(obj.responseText, selector);
                    $('#w2ui-popup').data(url, obj.responseText); // remember for possible future purposes
                });
            }
            function popup(html, selector) {
                delete options.url;
                $('body').append('&lt;div id="w2ui-tmp" style="display: none">' + html + '&lt;/div>');
                if (selector != null &amp;&amp; $('#w2ui-tmp #' + selector).length > 0) {
                    $('#w2ui-tmp #' + selector).w2popup(options);
                } else {
                    $('#w2ui-tmp > div').w2popup(options);
                }
                // link styles
                if ($('#w2ui-tmp > style').length > 0) {
                    var style = $('&lt;div>').append($('#w2ui-tmp > style').clone()).html();
                    if ($('#w2ui-popup #div-style').length === 0) {
                        $('#w2ui-popup').append('&lt;div id="div-style" style="position: absolute; left: -100; width: 1px">&lt;/div>');
                    }
                    $('#w2ui-popup #div-style').html(style);
                }
                $('#w2ui-tmp').remove();
            }
        },

        message: function (options) {
            var obj = this;
            $().w2tag(); // hide all tags
            if (!options) options = {width: 200, height: 100};
            var pWidth = parseInt($('#w2ui-popup').width());
            var pHeight = parseInt($('#w2ui-popup').height());
            options.originalWidth = options.width;
            options.originalHeight = options.height;
            if (parseInt(options.width) &lt; 10) options.width = 10;
            if (parseInt(options.height) &lt; 10) options.height = 10;
            if (options.hideOnClick == null) options.hideOnClick = false;
            var poptions = $('#w2ui-popup').data('options') || {};
            var titleHeight = parseInt($('#w2ui-popup > .w2ui-popup-title').css('height'));
            if (options.width == null || options.width > poptions.width - 10) {
                options.width = poptions.width - 10;
            }
            if (options.height == null || options.height > poptions.height - titleHeight - 5) {
                options.height = poptions.height - titleHeight - 5; // need margin from bottom only
            }
            // negative value means margin
            if (options.originalHeight &lt; 0) options.height = pHeight + options.originalHeight - titleHeight;
            if (options.originalWidth &lt; 0) options.width = pWidth + options.originalWidth * 2; // x 2 because there is left and right margin

            var head = $('#w2ui-popup .w2ui-popup-title');
            var msgCount = $('#w2ui-popup .w2ui-message').length;
            // remove message
            if ($.trim(options.html) === '' &amp;&amp; $.trim(options.body) === '' &amp;&amp; $.trim(options.buttons) === '') {
                var $msg = $('#w2ui-popup #w2ui-message' + (msgCount - 1));
                var options = $msg.data('options') || {};
                $msg.css(w2utils.cssPrefix({
                    'transition': '0.15s',
                    'transform': 'translateY(-' + options.height + 'px)'
                }));
                if (msgCount == 1) {
                    w2popup.unlock(150);
                } else {
                    $('#w2ui-popup #w2ui-message' + (msgCount - 2)).css('z-index', 1500);
                }
                setTimeout(function () {
                    var $focus = $msg.data('prev_focus');
                    $msg.remove();
                    if ($focus &amp;&amp; $focus.length > 0) {
                        $focus.focus();
                    } else {
                        obj.focus();
                    }
                    if (typeof options.onClose == 'function') options.onClose();
                }, 150);
            } else {
                if ($.trim(options.body) !== '' || $.trim(options.buttons) !== '') {
                    options.html = '&lt;div class="w2ui-message-body">' + options.body + '&lt;/div>' +
                        '&lt;div class="w2ui-message-buttons">' + options.buttons + '&lt;/div>';
                }
                // hide previous messages
                $('#w2ui-popup .w2ui-message').css('z-index', 1390);
                head.css('z-index', 1501);
                // add message
                $('#w2ui-popup .w2ui-box')
                    .before('&lt;div id="w2ui-message' + msgCount + '" class="w2ui-message" style="display: none; z-index: 1500; ' +
                        (head.length === 0 ? 'top: 0px;' : 'top: ' + w2utils.getSize(head, 'height') + 'px;') +
                        (options.width != null ? 'width: ' + options.width + 'px; left: ' + ((pWidth - options.width) / 2) + 'px;' : 'left: 10px; right: 10px;') +
                        (options.height != null ? 'height: ' + options.height + 'px;' : 'bottom: 6px;') +
                        w2utils.cssPrefix('transition', '.3s', true) + '"' +
                        (options.hideOnClick === true ? 'onclick="w2popup.message();"' : '') + '>' +
                        '&lt;/div>');
                $('#w2ui-popup #w2ui-message' + msgCount).data('options', options).data('prev_focus', $(':focus'));
                var display = $('#w2ui-popup #w2ui-message' + msgCount).css('display');
                $('#w2ui-popup #w2ui-message' + msgCount).css(w2utils.cssPrefix({
                    'transform': (display == 'none' ? 'translateY(-' + options.height + 'px)' : 'translateY(0px)')
                }));
                if (display == 'none') {
                    $('#w2ui-popup #w2ui-message' + msgCount).show().html(options.html);
                    // timer needs to animation
                    setTimeout(function () {
                        $('#w2ui-popup #w2ui-message' + msgCount).css(w2utils.cssPrefix({
                            'transform': (display == 'none' ? 'translateY(0px)' : 'translateY(-' + options.height + 'px)')
                        }));
                    }, 1);
                    // timer for lock
                    if (msgCount === 0) w2popup.lock();
                    setTimeout(function () {
                        obj.focus();
                        // has to be on top of lock
                        $('#w2ui-popup #w2ui-message' + msgCount).css(w2utils.cssPrefix({'transition': '0s'}));
                        if (typeof options.onOpen == 'function') options.onOpen();
                    }, 350);
                }
            }
        },

        focus: function () {
            var tmp = null;
            var pop = $('#w2ui-popup');
            var sel = 'input:visible, button:visible, select:visible, textarea:visible';
            // clear previous blur
            $(pop).find(sel).off('.keep-focus');
            // in message or popup
            var cnt = $('#w2ui-popup .w2ui-message').length - 1;
            var msg = $('#w2ui-popup #w2ui-message' + cnt);
            if (msg.length > 0) {
                var btn = $(msg[msg.length - 1]).find('button');
                if (btn.length > 0) btn[0].focus();
                tmp = msg;
            } else if (pop.length > 0) {
                var btn = pop.find('.w2ui-popup-buttons button');
                if (btn.length > 0) btn[0].focus();
                tmp = pop;
            }
            // keep focus/blur inside popup
            $(tmp).find(sel)
                .on('blur.keep-focus', function (event) {
                    setTimeout(function () {
                        var focus = $(':focus');
                        if ((focus.length > 0 &amp;&amp; !$(tmp).find(sel).is(focus)) || focus.hasClass('w2ui-popup-hidden')) {
                            var el = $(tmp).find(sel);
                            if (el.length > 0) el[0].focus();
                        }
                    }, 1);
                });
        },

        lock: function (msg, showSpinner) {
            var args = Array.prototype.slice.call(arguments, 0);
            args.unshift($('#w2ui-popup'));
            w2utils.lock.apply(window, args);
        },

        unlock: function (speed) {
            w2utils.unlock($('#w2ui-popup'), speed);
        },

        // --- INTERNAL FUNCTIONS

        lockScreen: function (options) {
            if ($('#w2ui-lock').length > 0) return false;
            if (options == null) options = $('#w2ui-popup').data('options');
            if (options == null) options = {};
            options = $.extend({}, w2popup.defaults, options);
            // show element
            $('body').append('&lt;div id="w2ui-lock" ' +
                '    onmousewheel="if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true; if (event.preventDefault) event.preventDefault(); else return false;"' +
                '    style="position: ' + (w2utils.engine == 'IE5' ? 'absolute' : 'fixed') + '; z-Index: 1199; left: 0px; top: 0px; ' +
                '           padding: 0px; margin: 0px; background-color: ' + options.color + '; width: 100%; height: 100%; opacity: 0;">&lt;/div>');
            // lock screen
            setTimeout(function () {
                $('#w2ui-lock')
                    .css('opacity', options.opacity)
                    .css(w2utils.cssPrefix('transition', options.speed + 's opacity'));
            }, 1);
            // add events
            if (options.modal == true) {
                $('#w2ui-lock').on('mousedown', function () {
                    $('#w2ui-lock')
                        .css('opacity', '0.6')
                        .css(w2utils.cssPrefix('transition', '.1s'));
                });
                $('#w2ui-lock').on('mouseup', function () {
                    setTimeout(function () {
                        $('#w2ui-lock')
                            .css('opacity', options.opacity)
                            .css(w2utils.cssPrefix('transition', '.1s'));
                    }, 100);
                });
            } else {
                $('#w2ui-lock').on('mousedown', function () {
                    w2popup.close();
                });
            }
            return true;
        },

        unlockScreen: function (options) {
            if ($('#w2ui-lock').length === 0) return false;
            if (options == null) options = $('#w2ui-popup').data('options');
            if (options == null) options = {};
            options = $.extend({}, w2popup.defaults, options);
            $('#w2ui-lock')
                .css('opacity', '0')
                .css(w2utils.cssPrefix('transition', options.speed + 's opacity'));
            setTimeout(function () {
                $('#w2ui-lock').remove();
            }, options.speed * 1000);
            return true;
        },

        resizeMessages: function () {
            var obj = this;
            var options = $('#w2ui-popup').data('options');
            // see if there are messages and resize them
            $('#w2ui-popup .w2ui-message').each(function () {
                var moptions = $(this).data('options');
                var $popup = $('#w2ui-popup');
                if (parseInt(moptions.width) &lt; 10) moptions.width = 10;
                if (parseInt(moptions.height) &lt; 10) moptions.height = 10;
                var titleHeight = parseInt($popup.find('> .w2ui-popup-title').css('height'));
                var pWidth = parseInt($popup.width());
                var pHeight = parseInt($popup.height());
                // recalc width
                moptions.width = moptions.originalWidth;
                if (moptions.width > pWidth - 10) {
                    moptions.width = pWidth - 10;
                }
                // recalc height
                moptions.height = moptions.originalHeight;
                if (moptions.height > pHeight - titleHeight - 5) {
                    moptions.height = pHeight - titleHeight - 5;
                }
                if (moptions.originalHeight &lt; 0) moptions.height = pHeight + moptions.originalHeight - titleHeight;
                if (moptions.originalWidth &lt; 0) moptions.width = pWidth + moptions.originalWidth * 2; // x 2 because there is left and right margin
                $(this).css({
                    left: ((pWidth - moptions.width) / 2) + 'px',
                    width: moptions.width + 'px',
                    height: moptions.height + 'px'
                });
            });
        },

        resize: function (width, height, callBack) {
            var obj = this;
            var options = $('#w2ui-popup').data('options');
            width = parseInt(width);
            height = parseInt(height);
            // calculate new position
            var maxW, maxH;
            if (window.innerHeight == undefined) {
                maxW = parseInt(document.documentElement.offsetWidth);
                maxH = parseInt(document.documentElement.offsetHeight);
                if (w2utils.engine === 'IE7') {
                    maxW += 21;
                    maxH += 4;
                }
            } else {
                maxW = parseInt(window.innerWidth);
                maxH = parseInt(window.innerHeight);
            }
            if (maxW - 10 &lt; width) width = maxW - 10;
            if (maxH - 10 &lt; height) height = maxH - 10;
            var top = (maxH - height) / 2 * 0.6;
            var left = (maxW - width) / 2;
            // resize there
            $('#w2ui-popup')
                .css(w2utils.cssPrefix({
                    'transition': options.speed + 's width, ' + options.speed + 's height, ' + options.speed + 's left, ' + options.speed + 's top'
                }))
                .css({
                    'top': top,
                    'left': left,
                    'width': width,
                    'height': height
                });
            var tmp_int = setInterval(function () {
                obj.resizeMessages();
            }, 10); // then messages resize nicely
            setTimeout(function () {
                clearInterval(tmp_int);
                options.width = width;
                options.height = height;
                obj.resizeMessages();
                if (typeof callBack == 'function') callBack();
            }, (options.speed * 1000) + 50); // give extra 50 ms
        },

        /***********************
         *  Internal
         **/

        // restores template
        restoreTemplate: function () {
            var options = $('#w2ui-popup').data('options');
            if (options == null) return;
            var template = w2popup._template;
            var title = options.title;
            var body = options.body;
            var buttons = options.buttons;
            if (w2popup._prev) {
                template = w2popup._prev.template;
                title = w2popup._prev.title;
                body = w2popup._prev.body;
                buttons = w2popup._prev.buttons;
                delete w2popup._prev;
            } else {
                delete w2popup._template;
            }
            if (template != null) {
                var $tmp = $(template);
                if ($tmp.length === 0) return;
                if ($(body).attr('rel') == 'body') {
                    if (title) $tmp.append(title);
                    if (body) $tmp.append(body);
                    if (buttons) $tmp.append(buttons);
                } else {
                    $tmp.append(body);
                }
            }
        }
    };

    // merge in event handling
    $.extend(w2popup, w2utils.event);

})(jQuery);

// ============================================
// --- Common dialogs

var w2alert = function (msg, title, callBack) {
    var $ = jQuery;
    if (title == null) title = w2utils.lang('Notification');
    if ($('#w2ui-popup').length > 0 &amp;&amp; w2popup.status != 'closing') {
        w2popup.message({
            width: 400,
            height: 170,
            body: '&lt;div class="w2ui-centered w2ui-alert-msg" style="font-size: 13px;">' + msg + '&lt;/div>',
            buttons: '&lt;button onclick="w2popup.message();" class="w2ui-popup-btn w2ui-btn">' + w2utils.lang('Ok') + '&lt;/button>',
            onOpen: function () {
                $('#w2ui-popup .w2ui-message .w2ui-popup-btn').focus();
            },
            onClose: function () {
                if (typeof callBack == 'function') callBack();
            }
        });
    } else {
        w2popup.open({
            width: 450,
            height: 220,
            showMax: false,
            showClose: false,
            title: title,
            body: '&lt;div class="w2ui-centered w2ui-alert-msg" style="font-size: 13px;">' + msg + '&lt;/div>',
            buttons: '&lt;button onclick="w2popup.close();" class="w2ui-popup-btn w2ui-btn">' + w2utils.lang('Ok') + '&lt;/button>',
            onOpen: function (event) {
                // do not use onComplete as it is slower
                setTimeout(function () {
                    $('#w2ui-popup .w2ui-popup-btn').focus();
                }, 1);
            },
            onKeydown: function (event) {
                $('#w2ui-popup .w2ui-popup-btn').focus().addClass('clicked');
            },
            onClose: function () {
                if (typeof callBack == 'function') callBack();
            }
        });
    }
    return {
        ok: function (fun) {
            callBack = fun;
            return this;
        },
        done: function (fun) {
            callBack = fun;
            return this;
        }
    };
};

var w2confirm = function (msg, title, callBack) {
    var $ = jQuery;
    var options = {};
    var defaults = {
        msg: '',
        title: w2utils.lang('Confirmation'),
        width: ($('#w2ui-popup').length > 0 ? 400 : 450),
        height: ($('#w2ui-popup').length > 0 ? 170 : 220),
        yes_text: 'Yes',
        yes_class: '',
        yes_style: '',
        yes_callBack: null,
        no_text: 'No',
        no_class: '',
        no_style: '',
        no_callBack: null,
        callBack: null
    };
    if (arguments.length == 1 &amp;&amp; typeof msg == 'object') {
        $.extend(options, defaults, msg);
    } else {
        if (typeof title == 'function') {
            $.extend(options, defaults, {
                msg: msg,
                callBack: title
            })
        } else {
            $.extend(options, defaults, {
                msg: msg,
                title: title,
                callBack: callBack
            })
        }
    }
    // if there is a yes/no button object
    if (typeof options.btn_yes == 'object') {
        options.yes_text = options.btn_yes.text || options.yes_text;
        options.yes_class = options.btn_yes["class"] || options.yes_class;
        options.yes_style = options.btn_yes.style || options.yes_style;
        options.yes_callBack = options.btn_yes.callBack || options.yes_callBack;
    }
    if (typeof options.btn_no == 'object') {
        options.no_text = options.btn_no.text || options.no_text;
        options.no_class = options.btn_no["class"] || options.no_class;
        options.no_style = options.btn_no.style || options.no_style;
        options.no_callBack = options.btn_no.callBack || options.no_callBack;
    }
    if ($('#w2ui-popup').length > 0 &amp;&amp; w2popup.status != 'closing' &amp;&amp; w2popup.get()) {
        if (options.width > w2popup.get().width) options.width = w2popup.get().width;
        if (options.height > (w2popup.get().height - 50)) options.height = w2popup.get().height - 50;
        w2popup.message({
            width: options.width,
            height: options.height,
            body: '&lt;div class="w2ui-centered w2ui-confirm-msg" style="font-size: 13px;">' + options.msg + '&lt;/div>',
            buttons: '&lt;button id="Yes" class="w2ui-popup-btn w2ui-btn ' + options.yes_class + '" style="' + options.yes_style + '">' + w2utils.lang(options.yes_text) + '&lt;/button>' +
            '&lt;button id="No" class="w2ui-popup-btn w2ui-btn ' + options.no_class + '" style="' + options.no_style + '">' + w2utils.lang(options.no_text) + '&lt;/button>',
            onOpen: function () {
                $('#w2ui-popup .w2ui-message .w2ui-btn').on('click.w2confirm', function (event) {
                    w2popup._confirm_btn = event.target.id;
                    w2popup.message();
                });
            },
            onClose: function () {
                // needed this because there might be other messages
                $('#w2ui-popup .w2ui-message .w2ui-btn').off('click.w2confirm');
                // need to wait for message to slide up
                setTimeout(function () {
                    if (typeof options.callBack == 'function') options.callBack(w2popup._confirm_btn);
                    if (w2popup._confirm_btn == 'Yes' &amp;&amp; typeof options.yes_callBack == 'function') options.yes_callBack();
                    if (w2popup._confirm_btn == 'No' &amp;&amp; typeof options.no_callBack == 'function') options.no_callBack();
                }, 300);
            }
            // onKeydown will not work here
        });

    } else {

        if (!w2utils.isInt(options.height)) options.height = options.height + 50;
        w2popup.open({
            width: options.width,
            height: options.height,
            title: options.title,
            modal: true,
            showClose: false,
            body: '&lt;div class="w2ui-centered w2ui-confirm-msg" style="font-size: 13px;">' + options.msg + '&lt;/div>',
            buttons: '&lt;button id="Yes" class="w2ui-popup-btn w2ui-btn ' + options.yes_class + '" style="' + options.yes_style + '">' + w2utils.lang(options.yes_text) + '&lt;/button>' +
            '&lt;button id="No" class="w2ui-popup-btn w2ui-btn ' + options.no_class + '" style="' + options.no_style + '">' + w2utils.lang(options.no_text) + '&lt;/button>',
            onOpen: function (event) {
                // do not use onComplete as it is slower
                setTimeout(function () {
                    $('#w2ui-popup .w2ui-popup-btn').on('click', function (event) {
                        w2popup.close();
                        if (typeof options.callBack == 'function') options.callBack(event.target.id);
                        if (event.target.id == 'Yes' &amp;&amp; typeof options.yes_callBack == 'function') options.yes_callBack();
                        if (event.target.id == 'No' &amp;&amp; typeof options.no_callBack == 'function') options.no_callBack();
                    });
                    $('#w2ui-popup .w2ui-popup-btn#Yes').focus();
                }, 1);
            },
            onKeydown: function (event) {
                // if there are no messages
                if ($('#w2ui-popup .w2ui-message').length === 0) {
                    switch (event.originalEvent.keyCode) {
                        case 13: // enter
                            $('#w2ui-popup .w2ui-popup-btn#Yes').focus().addClass('clicked'); // no need fo click as enter will do click
                            w2popup.close();
                            break;
                        case 27: // esc
                            $('#w2ui-popup .w2ui-popup-btn#No').focus().click();
                            w2popup.close();
                            break;
                    }
                }
            }
        });
    }

    return {
        yes: function (fun) {
            options.yes_callBack = fun;
            return this;
        },
        no: function (fun) {
            options.no_callBack = fun;
            return this;
        }
    };
};

var w2prompt = function (label, title, callBack) {
    var $ = jQuery;

    var options = {};
    var defaults = {
        label: '',
        value: '',
        attrs: '',
        title: w2utils.lang('Notification'),
        ok_text: w2utils.lang('Ok'),
        cancel_text: w2utils.lang('Cancel'),
        width: ($('#w2ui-popup').length > 0 ? 400 : 450),
        height: ($('#w2ui-popup').length > 0 ? 170 : 220),
        callBack: null
    }

    if (arguments.length == 1 &amp;&amp; typeof label == 'object') {
        $.extend(options, defaults, label);
    } else {
        if (typeof title == 'function') {
            $.extend(options, defaults, {
                label: label,
                callBack: title
            })
        } else {
            $.extend(options, defaults, {
                label: label,
                title: title,
                callBack: callBack
            })
        }
    }

    if ($('#w2ui-popup').length > 0 &amp;&amp; w2popup.status != 'closing' &amp;&amp; w2popup.get()) {
        if (options.width > w2popup.get().width) options.width = w2popup.get().width;
        if (options.height > (w2popup.get().height - 50)) options.height = w2popup.get().height - 50;
        w2popup.message({
            width: options.width,
            height: options.height,
            body: '&lt;div class="w2ui-centered" style="font-size: 13px;">' +
            '   &lt;label style="margin-right: 10px;">' + options.label + ':&lt;/label>' +
            '   &lt;input id="w2prompt" ' + options.attrs + '>' +
            '&lt;/div>',
            buttons: '&lt;button id="Ok" class="w2ui-popup-btn w2ui-btn">' + options.ok_text + '&lt;/button>&lt;button id="Cancel" class="w2ui-popup-btn w2ui-btn">' + options.cancel_text + '&lt;/button>',
            onOpen: function () {
                $('#w2prompt').val(options.value);
                $('#w2ui-popup .w2ui-message .w2ui-btn#Ok').on('click.w2prompt', function (event) {
                    w2popup._prompt_value = $('#w2prompt').val();
                    w2popup.message();
                });
                $('#w2ui-popup .w2ui-message .w2ui-btn#Cancel').on('click.w2prompt', function (event) {
                    w2popup._prompt_value = null;
                    w2popup.message();
                });
                // set focus
                setTimeout(function () {
                    $('#w2prompt').focus();
                }, 100);
            },
            onClose: function () {
                // needed this because there might be other messages
                $('#w2ui-popup .w2ui-message .w2ui-btn').off('click.w2prompt');
                // need to wait for message to slide up
                setTimeout(function () {
                    if (typeof options.callBack == 'function' &amp;&amp; w2popup._prompt_value != null) {
                        options.callBack(w2popup._prompt_value);
                    }
                }, 300);
            }
            // onKeydown will not work here
        });

    } else {

        if (!w2utils.isInt(options.height)) options.height = options.height + 50;
        w2popup.open({
            width: options.width,
            height: options.height,
            title: options.title,
            modal: true,
            showClose: false,
            body: '&lt;div class="w2ui-centered" style="font-size: 13px;">&lt;label style="margin-right: 10px;">' + options.label + ':&lt;/label>&lt;input id="w2prompt">&lt;/div>',
            buttons: '&lt;button id="Ok" class="w2ui-popup-btn w2ui-btn">' + options.ok_text + '&lt;/button>&lt;button id="Cancel" class="w2ui-popup-btn w2ui-btn">' + options.cancel_text + '&lt;/button>',
            onOpen: function (event) {
                // do not use onComplete as it is slower
                setTimeout(function () {
                    $('#w2prompt').val(options.value);
                    $('#w2prompt').w2field('text');
                    $('#w2ui-popup .w2ui-popup-btn#Ok').on('click', function (event) {
                        w2popup._prompt_value = $('#w2prompt').val();
                        w2popup.close();
                        if (typeof options.callBack == 'function') options.callBack(w2popup._prompt_value);
                    });
                    $('#w2ui-popup .w2ui-popup-btn#Cancel').on('click', function (event) {
                        w2popup._prompt_value = null;
                        w2popup.close();
                    });
                    $('#w2ui-popup .w2ui-popup-btn#Ok');
                    // set focus
                    setTimeout(function () {
                        $('#w2prompt').focus();
                    }, 100);
                }, 1);
            },
            onKeydown: function (event) {
                // if there are no messages
                if ($('#w2ui-popup .w2ui-message').length === 0) {
                    switch (event.originalEvent.keyCode) {
                        case 13: // enter
                            $('#w2ui-popup .w2ui-popup-btn#Ok').focus().addClass('clicked'); // no need fo click as enter will do click
                            w2popup.close();
                            break;
                        case 27: // esc
                            w2popup.close();
                            break;
                    }
                }
            }
        });
    }
    return {
        change: function (fun) {
            $('#w2prompt').on('keyup', fun).keyup();
            return this;
        },
        ok: function (fun) {
            options.callBack = fun;
            return this;
        }
    };
};

/************************************************************************
 *   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
 *   - Following objects defined
 *        - w2tabs        - tabs widget
 *        - $().w2tabs    - jQuery wrapper
 *   - Dependencies: jQuery, w2utils
 *
 * == NICE TO HAVE ==
 *   - align = left, right, center ??
 *
 ************************************************************************/

(function ($) {
    var w2tabs = function (options) {
        this.box = null;      // DOM Element that holds the element
        this.name = null;      // unique name for w2ui
        this.active = null;
        this.flow = 'down';    // can be down or up
        this.tooltip = 'top|left';     // can be top, bottom, left, right
        this.tabs = [];
        this.routeData = {};        // data for dynamic routes
        this.right = '';
        this.style = '';

        $.extend(this, {handlers: []});
        $.extend(true, this, w2obj.tabs, options);
    };

    // ====================================================
    // -- Registers as a jQuery plugin

    $.fn.w2tabs = function (method) {
        if ($.isPlainObject(method)) {
            // check name parameter
            if (!w2utils.checkName(method, 'w2tabs')) return;
            // extend tabs
            var tabs = method.tabs || [];
            var object = new w2tabs(method);
            for (var i = 0; i &lt; tabs.length; i++) {
                object.tabs[i] = $.extend({}, w2tabs.prototype.tab, tabs[i]);
            }
            if ($(this).length !== 0) {
                object.render($(this)[0]);
            }
            // register new object
            w2ui[object.name] = object;
            return object;
        } else {
            var obj = w2ui[$(this).attr('name')];
            if (!obj) return null;
            if (arguments.length > 0) {
                if (obj[method]) obj[method].apply(obj, Array.prototype.slice.call(arguments, 1));
                return this;
            } else {
                return obj;
            }
        }
    };

    // ====================================================
    // -- Implementation of core functionality

    w2tabs.prototype = {
        onClick: null,
        onClose: null,
        onRender: null,
        onRefresh: null,
        onResize: null,
        onDestroy: null,

        tab: {
            id: null,        // command to be sent to all event handlers
            text: null,
            route: null,
            hidden: false,
            disabled: false,
            closable: false,
            tooltip: null,
            style: '',
            onClick: null,
            onRefresh: null,
            onClose: null
        },

        add: function (tab) {
            return this.insert(null, tab);
        },

        insert: function (id, tab) {
            if (!$.isArray(tab)) tab = [tab];
            // assume it is array
            for (var i = 0; i &lt; tab.length; i++) {
                // checks
                if (tab[i].id == null) {
                    console.log('ERROR: The parameter "id" is required but not supplied. (obj: ' + this.name + ')');
                    return;
                }
                if (!w2utils.checkUniqueId(tab[i].id, this.tabs, 'tabs', this.name)) return;
                // add tab
                var newTab = $.extend({}, w2tabs.prototype.tab, tab[i]);
                if (id == null) {
                    this.tabs.push(newTab);
                } else {
                    var middle = this.get(id, true);
                    this.tabs = this.tabs.slice(0, middle).concat([newTab], this.tabs.slice(middle));
                }
                this.refresh(tab[i].id);
                this.resize();
            }
        },

        remove: function () {
            var removed = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                var tab = this.get(arguments[a]);
                if (!tab) return false;
                removed++;
                // remove from array
                this.tabs.splice(this.get(tab.id, true), 1);
                // remove from screen
                $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(tab.id)).remove();
            }
            this.resize();
            return removed;
        },

        select: function (id) {
            if (this.active == id || this.get(id) == null) return false;
            this.active = id;
            this.refresh();
            return true;
        },

        set: function (id, tab) {
            var index = this.get(id, true);
            if (index == null) return false;
            $.extend(this.tabs[index], tab);
            this.refresh(id);
            return true;
        },

        get: function (id, returnIndex) {
            if (arguments.length === 0) {
                var all = [];
                for (var i1 = 0; i1 &lt; this.tabs.length; i1++) {
                    if (this.tabs[i1].id != null) {
                        all.push(this.tabs[i1].id);
                    }
                }
                return all;
            } else {
                for (var i2 = 0; i2 &lt; this.tabs.length; i2++) {
                    if (this.tabs[i2].id == id) { // need to be == since id can be numeric
                        return (returnIndex === true ? i2 : this.tabs[i2]);
                    }
                }
            }
            return null;
        },

        show: function () {
            var obj = this;
            var shown = 0;
            var tmp = [];
            for (var a = 0; a &lt; arguments.length; a++) {
                var tab = this.get(arguments[a]);
                if (!tab || tab.hidden === false) continue;
                shown++;
                tab.hidden = false;
                tmp.push(tab.id);
            }
            setTimeout(function () {
                for (var t = 0; t &lt; tmp.length; t++) obj.refresh(tmp[t]);
                obj.resize();
            }, 15); // needs timeout
            return shown;
        },

        hide: function () {
            var obj = this;
            var hidden = 0;
            var tmp = [];
            for (var a = 0; a &lt; arguments.length; a++) {
                var tab = this.get(arguments[a]);
                if (!tab || tab.hidden === true) continue;
                hidden++;
                tab.hidden = true;
                tmp.push(tab.id);
            }
            setTimeout(function () {
                for (var t = 0; t &lt; tmp.length; t++) obj.refresh(tmp[t]);
                obj.resize();
            }, 15); // needs timeout
            return hidden;
        },

        enable: function () {
            var obj = this;
            var enabled = 0;
            var tmp = [];
            for (var a = 0; a &lt; arguments.length; a++) {
                var tab = this.get(arguments[a]);
                if (!tab || tab.disabled === false) continue;
                enabled++;
                tab.disabled = false;
                tmp.push(tab.id);
            }
            setTimeout(function () {
                for (var t = 0; t &lt; tmp.length; t++) obj.refresh(tmp[t]);
            }, 15); // needs timeout
            return enabled;
        },

        disable: function () {
            var obj = this;
            var disabled = 0;
            var tmp = [];
            for (var a = 0; a &lt; arguments.length; a++) {
                var tab = this.get(arguments[a]);
                if (!tab || tab.disabled === true) continue;
                disabled++;
                tab.disabled = true;
                tmp.push(tab.id);
            }
            setTimeout(function () {
                for (var t = 0; t &lt; tmp.length; t++) obj.refresh(tmp[t]);
            }, 15); // needs timeout
            return disabled;
        },

        tooltipShow: function (id, event, forceRefresh) {
            if (this.tooltip == null) return;
            var $el = $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(id));
            var item = this.get(id);
            var pos = this.tooltip;
            var txt = item.tooltip;
            if (typeof txt == 'function') txt = txt.call(this, item);
            $el.prop('_mouse_over', true);
            setTimeout(function () {
                if ($el.prop('_mouse_over') === true &amp;&amp; $el.prop('_mouse_tooltip') !== true) {
                    $el.prop('_mouse_tooltip', true);
                    // show tooltip
                    $el.w2tag(w2utils.lang(txt), {position: pos});
                }
                if (forceRefresh == true) {
                    $el.w2tag(w2utils.lang(txt), {position: pos});
                }
            }, 1);
        },

        tooltipHide: function (id) {
            if (this.tooltip == null) return;
            var $el = $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(id));
            var item = this.get(id);
            $el.removeProp('_mouse_over');
            setTimeout(function () {
                if ($el.prop('_mouse_over') !== true &amp;&amp; $el.prop('_mouse_tooltip') === true) {
                    $el.removeProp('_mouse_tooltip');
                    // hide tooltip
                    $el.w2tag();
                }
            }, 1);
        },

        refresh: function (id) {
            var time = (new Date()).getTime();
            if (this.flow == 'up') $(this.box).addClass('w2ui-tabs-up'); else $(this.box).removeClass('w2ui-tabs-up');
            // event before
            var edata = this.trigger({
                phase: 'before',
                type: 'refresh',
                target: (id != null ? id : this.name),
                object: this.get(id)
            });
            if (edata.isCancelled === true) return;
            if (id == null) {
                // refresh all
                for (var i = 0; i &lt; this.tabs.length; i++) this.refresh(this.tabs[i].id);
            } else {
                // create or refresh only one item
                var tab = this.get(id);
                if (tab == null) return false;
                if (tab.text == null &amp;&amp; tab.caption != null) tab.text = tab.caption;
                if (tab.tooltip == null &amp;&amp; tab.hint != null) tab.tooltip = tab.hint; // for backward compatibility
                var text = tab.text;
                if (typeof text == 'function') text = text.call(this, tab);
                if (text == null) text = '';

                var jq_el = $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(tab.id));
                var closable = '';
                if (tab.closable &amp;&amp; !tab.disabled) {
                    closable = '&lt;div class="w2ui-tab-close" ' +
                        '    onmouseover = "w2ui[\'' + this.name + '\'].tooltipShow(\'' + tab.id + '\', event);"' +
                        '    onmouseout  = "w2ui[\'' + this.name + '\'].tooltipHide(\'' + tab.id + '\', event);"' +
                        '    onclick="w2ui[\'' + this.name + '\'].animateClose(\'' + tab.id + '\', event);">' +
                        '&lt;/div>';
                }
                var tabHTML = closable +
                    '    &lt;div class="w2ui-tab' + (this.active === tab.id ? ' active' : '') + (tab.closable ? ' closable' : '')
                    + (tab['class'] ? ' ' + tab['class'] : '') + '" style="' + tab.style + '" ' +
                    '        onmouseover = "' + (!tab.disabled ? "w2ui['" + this.name + "'].tooltipShow('" + tab.id + "', event);" : "") + '"' +
                    '        onmouseout  = "' + (!tab.disabled ? "w2ui['" + this.name + "'].tooltipHide('" + tab.id + "', event);" : "") + '"' +
                    '        onclick="w2ui[\'' + this.name + '\'].click(\'' + tab.id + '\', event);">' + w2utils.lang(text) + '&lt;/div>';
                if (jq_el.length === 0) {
                    // does not exist - create it
                    var addStyle = '';
                    if (tab.hidden) {
                        addStyle += 'display: none;';
                    }
                    if (tab.disabled) {
                        addStyle += 'opacity: 0.2;';
                    }
                    var html = '&lt;td id="tabs_' + this.name + '_tab_' + tab.id + '" style="' + addStyle + '" valign="middle">' + tabHTML + '&lt;/td>';
                    if (this.get(id, true) !== this.tabs.length - 1 &amp;&amp; $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(this.tabs[parseInt(this.get(id, true)) + 1].id)).length > 0) {
                        $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(this.tabs[parseInt(this.get(id, true)) + 1].id)).before(html);
                    } else {
                        $(this.box).find('#tabs_' + this.name + '_right').before(html);
                    }
                } else {
                    // refresh
                    jq_el.html(tabHTML);
                    if (tab.hidden) {
                        jq_el.css('display', 'none');
                    }
                    else {
                        jq_el.css('display', '');
                    }
                    if (tab.disabled) {
                        jq_el.css({'opacity': '0.2'});
                    }
                    else {
                        jq_el.css({'opacity': '1'});
                    }
                }
            }
            // right html
            $('#tabs_' + this.name + '_right').html(this.right);
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            return (new Date()).getTime() - time;
        },

        render: function (box) {
            var time = (new Date()).getTime();
            // event before
            var edata = this.trigger({phase: 'before', type: 'render', target: this.name, box: box});
            if (edata.isCancelled === true) return;
            // default action
            // if (window.getSelection) window.getSelection().removeAllRanges(); // clear selection
            if (box != null) {
                if ($(this.box).find('> table #tabs_' + this.name + '_right').length > 0) {
                    $(this.box)
                        .removeAttr('name')
                        .removeClass('w2ui-reset w2ui-tabs')
                        .html('');
                }
                this.box = box;
            }
            if (!this.box) return false;
            // render all buttons
            var html = '&lt;div class="w2ui-scroll-wrapper" onmousedown="var el=w2ui[\'' + this.name + '\']; if (el) el.resize();">' +
                '&lt;table cellspacing="0" cellpadding="1" width="100%">&lt;tbody>' +
                '    &lt;tr>&lt;td width="100%" id="tabs_' + this.name + '_right" align="right">' + this.right + '&lt;/td>&lt;/tr>' +
                '&lt;/tbody>&lt;/table>' +
                '&lt;/div>' +
                '&lt;div class="w2ui-scroll-left" onclick="var el=w2ui[\'' + this.name + '\']; if (el) el.scroll(\'left\');">&lt;/div>' +
                '&lt;div class="w2ui-scroll-right" onclick="var el=w2ui[\'' + this.name + '\']; if (el) el.scroll(\'right\');">&lt;/div>';
            $(this.box)
                .attr('name', this.name)
                .addClass('w2ui-reset w2ui-tabs')
                .html(html);
            if ($(this.box).length > 0) $(this.box)[0].style.cssText += this.style;
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            this.refresh();
            this.resize();
            return (new Date()).getTime() - time;
        },

        scroll: function (direction) {
            var box = $(this.box);
            var obj = this;
            var scrollBox = box.find('.w2ui-scroll-wrapper');
            var scrollLeft = scrollBox.scrollLeft();
            var width1, width2, scroll;

            switch (direction) {
                case 'left':
                    width1 = scrollBox.outerWidth();
                    width2 = scrollBox.find(':first').outerWidth();
                    scroll = scrollLeft - width1 + 50; // 35 is width of both button
                    if (scroll &lt;= 0) scroll = 0;
                    scrollBox.animate({scrollLeft: scroll}, 300);
                    break;

                case 'right':
                    width1 = scrollBox.outerWidth();
                    width2 = scrollBox.find(':first').outerWidth();
                    scroll = scrollLeft + width1 - 50; // 35 is width of both button
                    if (scroll >= width2 - width1) scroll = width2 - width1;
                    scrollBox.animate({scrollLeft: scroll}, 300);
                    break;
            }
            setTimeout(function () {
                obj.resize();
            }, 350);
        },


        resize: function () {
            var time = (new Date()).getTime();
            // event before
            var edata = this.trigger({phase: 'before', type: 'resize', target: this.name});
            if (edata.isCancelled === true) return;

            // show hide overflow buttons
            var box = $(this.box);
            box.find('.w2ui-scroll-left, .w2ui-scroll-right').hide();
            var scrollBox = box.find('.w2ui-scroll-wrapper');
            if (scrollBox.find(':first').outerWidth() > scrollBox.outerWidth()) {
                // we have overflowed content
                if (scrollBox.scrollLeft() > 0) {
                    box.find('.w2ui-scroll-left').show();
                }
                if (scrollBox.scrollLeft() &lt; scrollBox.find(':first').outerWidth() - scrollBox.outerWidth()) {
                    box.find('.w2ui-scroll-right').show();
                }
            }

            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            return (new Date()).getTime() - time;
        },

        destroy: function () {
            // event before
            var edata = this.trigger({phase: 'before', type: 'destroy', target: this.name});
            if (edata.isCancelled === true) return;
            // clean up
            if ($(this.box).find('> table #tabs_' + this.name + '_right').length > 0) {
                $(this.box)
                    .removeAttr('name')
                    .removeClass('w2ui-reset w2ui-tabs')
                    .html('');
            }
            delete w2ui[this.name];
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        // ===================================================
        // -- Internal Event Handlers

        click: function (id, event) {
            var tab = this.get(id);
            if (tab == null || tab.disabled) return false;
            // event before
            var edata = this.trigger({
                phase: 'before',
                type: 'click',
                target: id,
                tab: tab,
                object: tab,
                originalEvent: event
            });
            if (edata.isCancelled === true) return;
            // default action
            $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(this.active) + ' .w2ui-tab').removeClass('active');
            this.active = tab.id;
            // route processing
            if (typeof tab.route == 'string') {
                var route = tab.route !== '' ? String('/' + tab.route).replace(/\/{2,}/g, '/') : '';
                var info = w2utils.parseRoute(route);
                if (info.keys.length > 0) {
                    for (var k = 0; k &lt; info.keys.length; k++) {
                        if (this.routeData[info.keys[k].name] == null) continue;
                        route = route.replace((new RegExp(':' + info.keys[k].name, 'g')), this.routeData[info.keys[k].name]);
                    }
                }
                setTimeout(function () {
                    window.location.hash = route;
                }, 1);
            }
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            this.refresh(id);
        },

        animateClose: function (id, event) {
            var tab = this.get(id);
            if (tab == null || tab.disabled) return false;
            // event before
            var edata = this.trigger({
                phase: 'before',
                type: 'close',
                target: id,
                object: this.get(id),
                originalEvent: event
            });
            if (edata.isCancelled === true) return;
            // default action
            var obj = this;
            $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(tab.id)).css(w2utils.cssPrefix('transition', '.2s')).css('opacity', '0');
            setTimeout(function () {
                var width = $(obj.box).find('#tabs_' + obj.name + '_tab_' + w2utils.escapeId(tab.id)).width();
                $(obj.box).find('#tabs_' + obj.name + '_tab_' + w2utils.escapeId(tab.id))
                    .html('&lt;div style="width: ' + width + 'px; ' + w2utils.cssPrefix('transition', '.2s', true) + '">&lt;/div>');
                setTimeout(function () {
                    $(obj.box).find('#tabs_' + obj.name + '_tab_' + w2utils.escapeId(tab.id)).find(':first-child').css({'width': '0px'});
                }, 50);
            }, 200);
            setTimeout(function () {
                obj.remove(id);
            }, 450);
            // event before
            this.trigger($.extend(edata, {phase: 'after'}));
            this.refresh();
        },

        animateInsert: function (id, tab) {
            if (this.get(id) == null) return;
            if (!$.isPlainObject(tab)) return;
            // check for unique
            if (!w2utils.checkUniqueId(tab.id, this.tabs, 'tabs', this.name)) return;
            // insert simple div
            var jq_el = $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(tab.id));
            if (jq_el.length !== 0) return; // already exists
            // measure width
            if (tab.text == null &amp;&amp; tab.caption != null) tab.text = tab.caption;
            var tmp = '&lt;div id="_tmp_tabs" class="w2ui-reset w2ui-tabs" style="position: absolute; top: -1000px;">' +
                '&lt;table cellspacing="0" cellpadding="1" width="100%">&lt;tbody>&lt;tr>' +
                '&lt;td id="_tmp_simple_tab" style="" valign="middle">' +
                (tab.closable ? '&lt;div class="w2ui-tab-close">&lt;/div>' : '') +
                '    &lt;div class="w2ui-tab ' + (this.active === tab.id ? 'active' : '') + '">' + tab.text + '&lt;/div>' +
                '&lt;/td>&lt;/tr>&lt;/tbody>&lt;/table>' +
                '&lt;/div>';
            $('body').append(tmp);
            // create dummy element
            var tabHTML = '&lt;div style="width: 1px; ' + w2utils.cssPrefix('transition', '.2s', true) + '">&amp;#160;&lt;/div>';
            var addStyle = '';
            if (tab.hidden) {
                addStyle += 'display: none;';
            }
            if (tab.disabled) {
                addStyle += 'opacity: 0.2;';
            }
            var html = '&lt;td id="tabs_' + this.name + '_tab_' + tab.id + '" style="' + addStyle + '" valign="middle">' + tabHTML + '&lt;/td>';
            if (this.get(id, true) !== this.tabs.length &amp;&amp; $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(this.tabs[parseInt(this.get(id, true))].id)).length > 0) {
                $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(this.tabs[parseInt(this.get(id, true))].id)).before(html);
            } else {
                $(this.box).find('#tabs_' + this.name + '_right').before(html);
            }
            // -- move
            var obj = this;
            setTimeout(function () {
                var width = $('#_tmp_simple_tab').width();
                $('#_tmp_tabs').remove();
                $('#tabs_' + obj.name + '_tab_' + w2utils.escapeId(tab.id) + ' > div').css('width', width + 'px');
            }, 1);
            setTimeout(function () {
                // insert for real
                obj.insert(id, tab);
            }, 200);
        }
    };

    $.extend(w2tabs.prototype, w2utils.event);
    w2obj.tabs = w2tabs;
})(jQuery);

/************************************************************************
 *   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
 *   - Following objects defined
 *        - w2toolbar        - toolbar widget
 *        - $().w2toolbar    - jQuery wrapper
 *   - Dependencies: jQuery, w2utils, w2field
 *
 * == NICE TO HAVE ==
 *   - vertical toolbar
 *
 ************************************************************************/

(function ($) {
    var w2toolbar = function (options) {
        this.box = null;      // DOM Element that holds the element
        this.name = null;      // unique name for w2ui
        this.routeData = {};        // data for dynamic routes
        this.items = [];
        this.right = '';        // HTML text on the right of toolbar
        this.tooltip = 'top|left';// can be top, bottom, left, right

        $.extend(true, this, w2obj.toolbar, options);
    };

    // ====================================================
    // -- Registers as a jQuery plugin

    $.fn.w2toolbar = function (method) {
        if ($.isPlainObject(method)) {
            // check name parameter
            if (!w2utils.checkName(method, 'w2toolbar')) return;
            // extend items
            var items = method.items || [];
            var object = new w2toolbar(method);
            $.extend(object, {items: [], handlers: []});
            for (var i = 0; i &lt; items.length; i++) {
                object.items[i] = $.extend({}, w2toolbar.prototype.item, items[i]);
                // menus
                if (object.items[i].type == 'menu-check') {
                    var item = object.items[i];
                    if (!Array.isArray(item.selected)) item.selected = [];
                    if (Array.isArray(item.items)) {
                        for (var j = 0; j &lt; item.items.length; j++) {
                            var it = item.items[j];
                            if (it.checked &amp;&amp; item.selected.indexOf(it.id) == -1) item.selected.push(it.id);
                            if (!it.checked &amp;&amp; item.selected.indexOf(it.id) != -1) it.checked = true;
                            if (it.checked == null) it.checked = false;
                        }
                    }
                }
                else if (object.items[i].type == 'menu-radio') {
                    var item = object.items[i];
                    if (Array.isArray(item.items)) {
                        for (var j = 0; j &lt; item.items.length; j++) {
                            var it = item.items[j];
                            if (it.checked &amp;&amp; item.selected == null) item.selected = it.id; else it.checked = false;
                            if (!it.checked &amp;&amp; item.selected == it.id) it.checked = true;
                            if (it.checked == null) it.checked = false;
                        }
                    }
                }
            }
            if ($(this).length !== 0) {
                object.render($(this)[0]);
            }
            // register new object
            w2ui[object.name] = object;
            return object;

        } else {
            var obj = w2ui[$(this).attr('name')];
            if (!obj) return null;
            if (arguments.length > 0) {
                if (obj[method]) obj[method].apply(obj, Array.prototype.slice.call(arguments, 1));
                return this;
            } else {
                return obj;
            }
        }
    };

    // ====================================================
    // -- Implementation of core functionality

    w2toolbar.prototype = {
        onClick: null,
        onRender: null,
        onRefresh: null,
        onResize: null,
        onDestroy: null,

        item: {
            id: null,        // command to be sent to all event handlers
            type: 'button',    // button, check, radio, drop, menu, menu-radio, menu-check, break, html, spacer
            text: null,
            html: '',
            tooltip: null,        // w2toolbar.tooltip should be
            count: null,
            hidden: false,
            disabled: false,
            checked: false,       // used for radio buttons
            img: null,
            icon: null,
            route: null,        // if not null, it is route to go
            arrow: true,        // arrow down for drop/menu types
            style: null,        // extre css style for caption
            color: null,        // color value - used in color pickers
            transparent: null,        // transparent t/f - used in color pickers
            group: null,        // used for radio buttons
            items: null,        // for type menu* it is an array of items in the menu
            selected: null,        // used for menu-check, menu-radio
            overlay: {},
            onClick: null,
            onRefresh: null
        },

        add: function (items) {
            this.insert(null, items);
        },

        insert: function (id, items) {
            if (!$.isArray(items)) items = [items];
            for (var o = 0; o &lt; items.length; o++) {
                // checks
                if (items[o].type == null) {
                    console.log('ERROR: The parameter "type" is required but not supplied in w2toolbar.add() method.');
                    return;
                }
                if ($.inArray(String(items[o].type), ['button', 'check', 'radio', 'drop', 'menu', 'menu-radio', 'menu-check', 'color', 'text-color', 'break', 'html', 'spacer']) == -1) {
                    console.log('ERROR: The parameter "type" should be one of the following [button, check, radio, drop, menu, break, html, spacer] ' +
                        'in w2toolbar.add() method.');
                    return;
                }
                if (items[o].id == null &amp;&amp; items[o].type != 'break' &amp;&amp; items[o].type != 'spacer') {
                    console.log('ERROR: The parameter "id" is required but not supplied in w2toolbar.add() method.');
                    return;
                }
                if (!w2utils.checkUniqueId(items[o].id, this.items, 'toolbar items', this.name)) return;
                // add item
                var it = $.extend({}, w2toolbar.prototype.item, items[o]);
                if (id == null) {
                    this.items.push(it);
                } else {
                    var middle = this.get(id, true);
                    this.items = this.items.slice(0, middle).concat([it], this.items.slice(middle));
                }
                this.refresh(it.id);
                this.resize();
            }
        },

        remove: function () {
            var removed = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                var it = this.get(arguments[a]);
                if (!it || String(arguments[a]).indexOf(':') != -1) continue;
                removed++;
                // remove from screen
                $(this.box).find('#tb_' + this.name + '_item_' + w2utils.escapeId(it.id)).remove();
                // remove from array
                var ind = this.get(it.id, true);
                if (ind != null) this.items.splice(ind, 1);
            }
            this.resize();
            return removed;
        },

        set: function (id, newOptions) {
            var item = this.get(id);
            if (item == null) return false;
            $.extend(item, newOptions);
            this.refresh(String(id).split(':')[0]);
            return true;
        },

        get: function (id, returnIndex) {
            if (arguments.length === 0) {
                var all = [];
                for (var i1 = 0; i1 &lt; this.items.length; i1++) if (this.items[i1].id != null) all.push(this.items[i1].id);
                return all;
            }
            var tmp = String(id).split(':');
            for (var i2 = 0; i2 &lt; this.items.length; i2++) {
                var it = this.items[i2];
                // find a menu item
                if (['menu', 'menu-radio', 'menu-check'].indexOf(it.type) != -1 &amp;&amp; tmp.length == 2 &amp;&amp; it.id == tmp[0]) {
                    for (var i = 0; i &lt; it.items.length; i++) {
                        var item = it.items[i];
                        if (item.id == tmp[1] || (item.id == null &amp;&amp; item.text == tmp[1])) {
                            if (returnIndex == true) return i; else return item;
                        }
                    }
                } else if (it.id == tmp[0]) {
                    if (returnIndex == true) return i2; else return it;
                }
            }
            return null;
        },

        show: function () {
            var obj = this;
            var items = 0;
            var tmp = [];
            for (var a = 0; a &lt; arguments.length; a++) {
                var it = this.get(arguments[a]);
                if (!it) continue;
                items++;
                it.hidden = false;
                tmp.push(String(arguments[a]).split(':')[0]);
            }
            setTimeout(function () {
                for (var t = 0; t &lt; tmp.length; t++) obj.refresh(tmp[t]);
                obj.resize();
            }, 15); // needs timeout
            return items;
        },

        hide: function () {
            var obj = this;
            var items = 0;
            var tmp = [];
            for (var a = 0; a &lt; arguments.length; a++) {
                var it = this.get(arguments[a]);
                if (!it) continue;
                items++;
                it.hidden = true;
                tmp.push(String(arguments[a]).split(':')[0]);
            }
            setTimeout(function () {
                for (var t = 0; t &lt; tmp.length; t++) {
                    obj.refresh(tmp[t]);
                    obj.tooltipHide(tmp[t]);
                }
                obj.resize();
            }, 15); // needs timeout
            return items;
        },

        enable: function () {
            var obj = this;
            var items = 0;
            var tmp = [];
            for (var a = 0; a &lt; arguments.length; a++) {
                var it = this.get(arguments[a]);
                if (!it) continue;
                items++;
                it.disabled = false;
                tmp.push(String(arguments[a]).split(':')[0]);
            }
            setTimeout(function () {
                for (var t = 0; t &lt; tmp.length; t++) obj.refresh(tmp[t]);
            }, 15); // needs timeout
            return items;
        },

        disable: function () {
            var obj = this;
            var items = 0;
            var tmp = [];
            for (var a = 0; a &lt; arguments.length; a++) {
                var it = this.get(arguments[a]);
                if (!it) continue;
                items++;
                it.disabled = true;
                tmp.push(String(arguments[a]).split(':')[0]);
            }
            setTimeout(function () {
                for (var t = 0; t &lt; tmp.length; t++) {
                    obj.refresh(tmp[t]);
                    obj.tooltipHide(tmp[t]);
                }
            }, 15); // needs timeout
            return items;
        },

        check: function () {
            var obj = this;
            var items = 0;
            var tmp = [];
            for (var a = 0; a &lt; arguments.length; a++) {
                var it = this.get(arguments[a]);
                if (!it || String(arguments[a]).indexOf(':') != -1) continue;
                items++;
                it.checked = true;
                tmp.push(String(arguments[a]).split(':')[0]);
            }
            setTimeout(function () {
                for (var t = 0; t &lt; tmp.length; t++) obj.refresh(tmp[t]);
            }, 15); // needs timeout
            return items;
        },

        uncheck: function () {
            var obj = this;
            var items = 0;
            var tmp = [];
            for (var a = 0; a &lt; arguments.length; a++) {
                var it = this.get(arguments[a]);
                if (!it || String(arguments[a]).indexOf(':') != -1) continue;
                // remove overlay
                if (['menu', 'menu-radio', 'menu-check', 'drop', 'color', 'text-color'].indexOf(it.type) != -1 &amp;&amp; it.checked) {
                    // hide overlay
                    setTimeout(function () {
                        var el = $('#tb_' + obj.name + '_item_' + w2utils.escapeId(it.id));
                        el.w2overlay({name: obj.name});
                    }, 1);
                }
                items++;
                it.checked = false;
                tmp.push(String(arguments[a]).split(':')[0]);
            }
            setTimeout(function () {
                for (var t = 0; t &lt; tmp.length; t++) obj.refresh(tmp[t]);
            }, 15); // needs timeout
            return items;
        },

        click: function (id, event) {
            var obj = this;
            // click on menu items
            var tmp = String(id).split(':');
            var it = this.get(tmp[0]);
            if (tmp.length > 1) {
                var subItem = this.get(id);
                if (subItem &amp;&amp; !subItem.disabled) {
                    obj.menuClick({name: obj.name, item: it, subItem: subItem, originalEvent: event});
                }
                return;
            }
            if (it &amp;&amp; !it.disabled) {
                // event before
                var edata = this.trigger({
                    phase: 'before', type: 'click', target: (id != null ? id : this.name),
                    item: it, object: it, originalEvent: event
                });
                if (edata.isCancelled === true) return;

                var btn = '#tb_' + this.name + '_item_' + w2utils.escapeId(it.id) + ' table.w2ui-button';
                $(btn).removeClass('down'); // need to requery at the moment -- as well as elsewhere in this function

                if (it.type == 'radio') {
                    for (var i = 0; i &lt; this.items.length; i++) {
                        var itt = this.items[i];
                        if (itt == null || itt.id == it.id || itt.type !== 'radio') continue;
                        if (itt.group == it.group &amp;&amp; itt.checked) {
                            itt.checked = false;
                            this.refresh(itt.id);
                        }
                    }
                    it.checked = true;
                    $(btn).addClass('checked');
                }

                if (['menu', 'menu-radio', 'menu-check', 'drop', 'color', 'text-color'].indexOf(it.type) != -1) {
                    obj.tooltipHide(id);
                    if (it.checked) {
                        // if it was already checked, second click will hide it
                        setTimeout(function () {
                            // hide overlay
                            var el = $('#tb_' + obj.name + '_item_' + w2utils.escapeId(it.id));
                            el.w2overlay({name: obj.name});
                            // uncheck
                            it.checked = false;
                            obj.refresh(it.id);
                        }, 1);

                    } else {

                        // show overlay
                        setTimeout(function () {
                            var el = $('#tb_' + obj.name + '_item_' + w2utils.escapeId(it.id));
                            if (!$.isPlainObject(it.overlay)) it.overlay = {};
                            var left = (el.width() - 50) / 2;
                            if (left > 19) left = 19;
                            if (it.type == 'drop') {
                                el.w2overlay(it.html, $.extend({name: obj.name, left: left, top: 3}, it.overlay, {
                                    onHide: function (event) {
                                        hideDrop();
                                    }
                                }));
                            }
                            if (['menu', 'menu-radio', 'menu-check'].indexOf(it.type) != -1) {
                                var menuType = 'normal';
                                if (it.type == 'menu-radio') {
                                    menuType = 'radio';
                                    it.items.forEach(function (item) {
                                        if (it.selected == item.id) item.checked = true; else item.checked = false;
                                    });
                                }
                                if (it.type == 'menu-check') {
                                    menuType = 'check';
                                    it.items.forEach(function (item) {
                                        if ($.isArray(it.selected) &amp;&amp; it.selected.indexOf(item.id) != -1) item.checked = true; else item.checked = false;
                                    });
                                }
                                el.w2menu($.extend({name: obj.name, items: it.items, left: left, top: 3}, it.overlay, {
                                    type: menuType,
                                    select: function (event) {
                                        obj.menuClick({
                                            name: obj.name,
                                            item: it,
                                            subItem: event.item,
                                            originalEvent: event.originalEvent,
                                            keepOpen: event.keepOpen
                                        });
                                    },
                                    onHide: function (event) {
                                        hideDrop();
                                    }
                                }));
                            }
                            if (['color', 'text-color'].indexOf(it.type) != -1) {
                                if (it.transparent == null) it.transparent = true;
                                $(el).w2color({color: it.color, transparent: it.transparent}, function (color, index) {
                                    if (color != null) {
                                        obj.colorClick({
                                            name: obj.name,
                                            item: it,
                                            color: color,
                                            originalEvent: event.originalEvent
                                        });
                                    }
                                    hideDrop();
                                });
                            }
                            function hideDrop(event) {
                                it.checked = false;
                                $(btn).removeClass('checked');
                            }
                        }, 1);
                    }
                }

                if (['check', 'menu', 'menu-radio', 'menu-check', 'drop', 'color', 'text-color'].indexOf(it.type) != -1) {
                    it.checked = !it.checked;
                    if (it.checked) {
                        $(btn).addClass('checked');
                    } else {
                        $(btn).removeClass('checked');
                    }
                }
                // route processing
                if (it.route) {
                    var route = String('/' + it.route).replace(/\/{2,}/g, '/');
                    var info = w2utils.parseRoute(route);
                    if (info.keys.length > 0) {
                        for (var k = 0; k &lt; info.keys.length; k++) {
                            route = route.replace((new RegExp(':' + info.keys[k].name, 'g')), this.routeData[info.keys[k].name]);
                        }
                    }
                    setTimeout(function () {
                        window.location.hash = route;
                    }, 1);
                }
                if (event &amp;&amp; ['button', 'check', 'radio'].indexOf(it.type) != -1) {
                    // need to refresh toolbar as it might be dynamic
                    this.tooltipShow(id, event, true);
                }
                // event after
                this.trigger($.extend(edata, {phase: 'after'}));
            }
        },

        scroll: function (direction) {
            var box = $(this.box);
            var obj = this;
            var scrollBox = box.find('.w2ui-scroll-wrapper');
            var scrollLeft = scrollBox.scrollLeft();
            var width1, width2, scroll;

            switch (direction) {
                case 'left':
                    width1 = scrollBox.outerWidth();
                    width2 = scrollBox.find(':first').outerWidth();
                    scroll = scrollLeft - width1 + 50; // 35 is width of both button
                    if (scroll &lt;= 0) scroll = 0;
                    scrollBox.animate({scrollLeft: scroll}, 300);
                    break;

                case 'right':
                    width1 = scrollBox.outerWidth();
                    width2 = scrollBox.find(':first').outerWidth();
                    scroll = scrollLeft + width1 - 50; // 35 is width of both button
                    if (scroll >= width2 - width1) scroll = width2 - width1;
                    scrollBox.animate({scrollLeft: scroll}, 300);
                    break;
            }
            setTimeout(function () {
                obj.resize();
            }, 350);
        },

        render: function (box) {
            var time = (new Date()).getTime();
            // event before
            var edata = this.trigger({phase: 'before', type: 'render', target: this.name, box: box});
            if (edata.isCancelled === true) return;

            if (box != null) {
                if ($(this.box).find('> table #tb_' + this.name + '_right').length > 0) {
                    $(this.box)
                        .removeAttr('name')
                        .removeClass('w2ui-reset w2ui-toolbar')
                        .html('');
                }
                this.box = box;
            }
            if (!this.box) return;
            // render all buttons
            var html = '&lt;div class="w2ui-scroll-wrapper" onmousedown="var el=w2ui[\'' + this.name + '\']; if (el) el.resize();">' +
                '&lt;table cellspacing="0" cellpadding="0" width="100%">&lt;tbody>' +
                '&lt;tr>';
            for (var i = 0; i &lt; this.items.length; i++) {
                var it = this.items[i];
                if (it == null)  continue;
                if (it.id == null) it.id = "item_" + i;
                if (it.type == 'spacer') {
                    html += '&lt;td width="100%" id="tb_' + this.name + '_item_' + it.id + '" align="right">&lt;/td>';
                } else {
                    html += '&lt;td id="tb_' + this.name + '_item_' + it.id + '" style="' + (it.hidden ? 'display: none' : '') + '" ' +
                        '    class="' + (it.disabled ? 'disabled' : '') + '" valign="middle">' +
                        '&lt;/td>';
                }
            }
            html += '&lt;td width="100%" id="tb_' + this.name + '_right" align="right">' + this.right + '&lt;/td>';
            html += '&lt;/tr>' +
                '&lt;/tbody>&lt;/table>&lt;/div>' +
                '&lt;div class="w2ui-scroll-left" onclick="var el=w2ui[\'' + this.name + '\']; if (el) el.scroll(\'left\');">&lt;/div>' +
                '&lt;div class="w2ui-scroll-right" onclick="var el=w2ui[\'' + this.name + '\']; if (el) el.scroll(\'right\');">&lt;/div>';
            $(this.box)
                .attr('name', this.name)
                .addClass('w2ui-reset w2ui-toolbar')
                .html(html);
            if ($(this.box).length > 0) $(this.box)[0].style.cssText += this.style;
            // refresh all
            this.refresh();
            this.resize();
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            return (new Date()).getTime() - time;
        },

        refresh: function (id) {
            var time = (new Date()).getTime();
            // event before
            var edata = this.trigger({
                phase: 'before',
                type: 'refresh',
                target: (id != null ? id : this.name),
                item: this.get(id)
            });
            if (edata.isCancelled === true) return;
            // refresh all
            if (id == null) {
                for (var i = 0; i &lt; this.items.length; i++) {
                    var it1 = this.items[i];
                    if (it1.id == null) it1.id = "item_" + i;
                    this.refresh(it1.id);
                }
                return;
            }
            // create or refresh only one item
            var it = this.get(id);
            if (it == null) return false;
            if (typeof it.onRefresh == 'function') {
                var edata2 = this.trigger({phase: 'before', type: 'refresh', target: id, item: it, object: it});
                if (edata2.isCancelled === true) return;
            }
            var el = $(this.box).find('#tb_' + this.name + '_item_' + w2utils.escapeId(it.id));
            var html = this.getItemHTML(it);
            if (el.length === 0) {
                // does not exist - create it
                if (it.type == 'spacer') {
                    html = '&lt;td width="100%" id="tb_' + this.name + '_item_' + it.id + '" align="right">&lt;/td>';
                } else {
                    html = '&lt;td id="tb_' + this.name + '_item_' + it.id + '" style="' + (it.hidden ? 'display: none' : '') + '" ' +
                        '    class="' + (it.disabled ? 'disabled' : '') + '" valign="middle">' + html +
                        '&lt;/td>';
                }
                if (this.get(id, true) == this.items.length - 1) {
                    $(this.box).find('#tb_' + this.name + '_right').before(html);
                } else {
                    $(this.box).find('#tb_' + this.name + '_item_' + w2utils.escapeId(this.items[parseInt(this.get(id, true)) + 1].id)).before(html);
                }
            } else {
                if (['menu', 'menu-radio', 'menu-check', 'drop', 'color', 'text-color'].indexOf(it.type) != -1 &amp;&amp; it.checked == false) {
                    if ($('#w2ui-overlay-' + this.name).length > 0) $('#w2ui-overlay-' + this.name)[0].hide();
                }
                // refresh
                el.html(html);
                if (it.hidden) {
                    el.css('display', 'none');
                } else {
                    el.css('display', '');
                }
                if (it.disabled) {
                    el.addClass('disabled');
                } else {
                    el.removeClass('disabled');
                }
            }
            // event after
            if (typeof it.onRefresh == 'function') {
                this.trigger($.extend(edata2, {phase: 'after'}));
            }
            this.trigger($.extend(edata, {phase: 'after'}));
            return (new Date()).getTime() - time;
        },

        resize: function () {
            var time = (new Date()).getTime();
            // event before
            var edata = this.trigger({phase: 'before', type: 'resize', target: this.name});
            if (edata.isCancelled === true) return;

            // show hide overflow buttons
            var box = $(this.box);
            box.find('.w2ui-scroll-left, .w2ui-scroll-right').hide();
            var scrollBox = box.find('.w2ui-scroll-wrapper');
            if (scrollBox.find(':first').outerWidth() > scrollBox.outerWidth()) {
                // we have overflowed content
                if (scrollBox.scrollLeft() > 0) {
                    box.find('.w2ui-scroll-left').show();
                }
                if (scrollBox.scrollLeft() &lt; scrollBox.find(':first').outerWidth() - scrollBox.outerWidth()) {
                    box.find('.w2ui-scroll-right').show();
                }
            }

            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            return (new Date()).getTime() - time;
        },

        destroy: function () {
            // event before
            var edata = this.trigger({phase: 'before', type: 'destroy', target: this.name});
            if (edata.isCancelled === true) return;
            // clean up
            if ($(this.box).find('> table #tb_' + this.name + '_right').length > 0) {
                $(this.box)
                    .removeAttr('name')
                    .removeClass('w2ui-reset w2ui-toolbar')
                    .html('');
            }
            $(this.box).html('');
            delete w2ui[this.name];
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        // ========================================
        // --- Internal Functions

        getItemHTML: function (item) {
            var html = '';
            if (item.caption != null &amp;&amp; item.text == null) item.text = item.caption; // for backward compatibility
            if (item.text == null) item.text = '';
            if (item.tooltip == null &amp;&amp; item.hint != null) item.tooltip = item.hint; // for backward compatibility
            if (item.tooltip == null) item.tooltip = '';
            var img = '&lt;td>&amp;#160;&lt;/td>';
            var text = item.text;
            if (typeof text == 'function') text = text.call(this, item);
            if (item.img) img = '&lt;td>&lt;div class="w2ui-tb-image w2ui-icon ' + item.img + '">&lt;/div>&lt;/td>';
            if (item.icon) img = '&lt;td>&lt;div class="w2ui-tb-image">&lt;span class="' + item.icon + '">&lt;/span>&lt;/div>&lt;/td>';

            if (html === '') switch (item.type) {
                case 'color':
                case 'text-color':
                    if (typeof item.color == 'string' &amp;&amp; item.color.substr(0, 1) == '#') item.color = item.color.substr(1);
                    if (item.type == 'color') {
                        text = '&lt;div style="height: 12px; width: 12px; margin-top: 1px; border: 1px solid #8A8A8A; border-radius: 1px; box-shadow: 0px 0px 1px #fff; ' +
                            '        background-color: #' + (item.color != null ? item.color : 'fff') + '; float: left;">&lt;/div>' +
                            (item.text ? '&lt;div style="margin-left: 17px;">' + w2utils.lang(item.text) + '&lt;/div>' : '');
                    }
                    if (item.type == 'text-color') {
                        text = '&lt;div style="color: #' + (item.color != null ? item.color : '444') + ';">' +
                            (item.text ? w2utils.lang(item.text) : '&lt;b>Aa&lt;/b>') +
                            '&lt;/div>';
                    }
                case 'menu':
                case 'menu-check':
                case 'menu-radio':
                case 'button':
                case 'check':
                case 'radio':
                case 'drop':
                    html += '&lt;table cellpadding="0" cellspacing="0" ' +
                        '       class="w2ui-button ' + (item.checked ? 'checked' : '') + '" ' +
                        '       onclick     = "var el=w2ui[\'' + this.name + '\']; if (el) el.click(\'' + item.id + '\', event);" ' +
                        '       onmouseover = "' + (!item.disabled ? "jQuery(this).addClass('over'); w2ui['" + this.name + "'].tooltipShow('" + item.id + "', event);" : "") + '"' +
                        '       onmouseout  = "' + (!item.disabled ? "jQuery(this).removeClass('over').removeClass('down'); w2ui['" + this.name + "'].tooltipHide('" + item.id + "', event);" : "") + '"' +
                        '       onmousedown = "' + (!item.disabled ? "jQuery(this).addClass('down');" : "") + '"' +
                        '       onmouseup   = "' + (!item.disabled ? "jQuery(this).removeClass('down');" : "") + '"' +
                        '>&lt;tbody>' +
                        '&lt;tr>&lt;td>' +
                        '  &lt;table cellpadding="1" cellspacing="0">&lt;tbody>' +
                        '  &lt;tr>' +
                        img +
                        (text !== ''
                                ? '&lt;td class="w2ui-tb-caption" nowrap="nowrap" style="' + (item.style ? item.style : '') + '">' + w2utils.lang(text) + '&lt;/td>'
                                : ''
                        ) +
                        (item.count != null
                                ? '&lt;td class="w2ui-tb-count" nowrap="nowrap">&lt;span>' + item.count + '&lt;/span>&lt;/td>'
                                : ''
                        ) +
                        (((['menu', 'menu-radio', 'menu-check', 'drop', 'color', 'text-color'].indexOf(item.type) != -1) &amp;&amp; item.arrow !== false) ?
                            '&lt;td class="w2ui-tb-down" nowrap="nowrap">&lt;div>&lt;/div>&lt;/td>' : '') +
                        '  &lt;/tr>&lt;/tbody>&lt;/table>' +
                        '&lt;/td>&lt;/tr>&lt;/tbody>&lt;/table>';
                    break;

                case 'break':
                    html += '&lt;table cellpadding="0" cellspacing="0">&lt;tbody>&lt;tr>' +
                        '    &lt;td>&lt;div class="w2ui-break">&amp;#160;&lt;/div>&lt;/td>' +
                        '&lt;/tr>&lt;/tbody>&lt;/table>';
                    break;

                case 'html':
                    html += '&lt;table cellpadding="0" cellspacing="0">&lt;tbody>&lt;tr>' +
                        '    &lt;td nowrap="nowrap">' + (typeof item.html == 'function' ? item.html.call(this, item) : item.html) + '&lt;/td>' +
                        '&lt;/tr>&lt;/tbody>&lt;/table>';
                    break;
            }
            return '&lt;div>' + html + '&lt;/div>';
        },

        tooltipShow: function (id, event, forceRefresh) {
            if (this.tooltip == null) return;
            var $el = $(this.box).find('#tb_' + this.name + '_item_' + w2utils.escapeId(id));
            var item = this.get(id);
            var pos = this.tooltip;
            var txt = item.tooltip;
            if (typeof txt == 'function') txt = txt.call(this, item);
            $el.prop('_mouse_over', true);
            setTimeout(function () {
                if ($el.prop('_mouse_over') === true &amp;&amp; $el.prop('_mouse_tooltip') !== true) {
                    $el.prop('_mouse_tooltip', true);
                    // show tooltip
                    if (['menu', 'menu-radio', 'menu-check', 'drop', 'color', 'text-color'].indexOf(item.type) != -1 &amp;&amp; item.checked == true) return; // not for opened drop downs
                    $el.w2tag(w2utils.lang(txt), {position: pos});
                }
                if (forceRefresh == true) {
                    $el.w2tag(w2utils.lang(txt), {position: pos});
                }
            }, 1);
        },

        tooltipHide: function (id, event) {
            if (this.tooltip == null) return;
            var $el = $(this.box).find('#tb_' + this.name + '_item_' + w2utils.escapeId(id));
            var item = this.get(id);
            $el.removeProp('_mouse_over');
            setTimeout(function () {
                if ($el.prop('_mouse_over') !== true &amp;&amp; $el.prop('_mouse_tooltip') === true) {
                    $el.removeProp('_mouse_tooltip');
                    // hide tooltip
                    $el.w2tag();
                }
            }, 1);
        },

        menuClick: function (event) {
            var obj = this;
            if (event.item &amp;&amp; !event.item.disabled) {
                // event before
                var edata = this.trigger({
                    phase: 'before', type: 'click', target: event.item.id + ':' + event.subItem.id, item: event.item,
                    subItem: event.subItem, originalEvent: event.originalEvent
                });
                if (edata.isCancelled === true) return;

                // route processing
                var it = event.subItem;
                var item = this.get(event.item.id);
                if (item.type == 'menu-radio') {
                    item.selected = it.id;
                    event.item.items.forEach(function (item) {
                        item.checked = false;
                    });
                    it.checked = true;
                }
                if (item.type == 'menu-check') {
                    if (!$.isArray(item.selected)) item.selected = [];
                    var ind = item.selected.indexOf(it.id);
                    if (ind == -1) {
                        item.selected.push(it.id);
                        it.checked = true;
                    } else {
                        item.selected.splice(ind, 1);
                        it.checked = false;
                    }
                }
                if (typeof it.route == 'string') {
                    var route = it.route !== '' ? String('/' + it.route).replace(/\/{2,}/g, '/') : '';
                    var info = w2utils.parseRoute(route);
                    if (info.keys.length > 0) {
                        for (var k = 0; k &lt; info.keys.length; k++) {
                            if (obj.routeData[info.keys[k].name] == null) continue;
                            route = route.replace((new RegExp(':' + info.keys[k].name, 'g')), this.routeData[info.keys[k].name]);
                        }
                    }
                    setTimeout(function () {
                        window.location.hash = route;
                    }, 1);
                }
                this.refresh(event.item.id);
                // event after
                this.trigger($.extend(edata, {phase: 'after'}));
            }
        },

        colorClick: function (event) {
            var obj = this;
            if (event.item &amp;&amp; !event.item.disabled) {
                // event before
                var edata = this.trigger({
                    phase: 'before', type: 'click', target: event.item.id, item: event.item,
                    color: event.color, originalEvent: event.originalEvent
                });
                if (edata.isCancelled === true) return;

                // default behavior
                event.item.color = event.color;
                obj.refresh(event.item.id);

                // event after
                this.trigger($.extend(edata, {phase: 'after'}));
            }
        }
    };

    $.extend(w2toolbar.prototype, w2utils.event);
    w2obj.toolbar = w2toolbar;
})(jQuery);

/************************************************************************
 *   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
 *   - Following objects defined
 *        - w2sidebar        - sidebar widget
 *        - $().w2sidebar    - jQuery wrapper
 *   - Dependencies: jQuery, w2utils
 *
 * == NICE TO HAVE ==
 *   - add find() method to find nodes by a specific criteria (I want all nodes for exampe)
 *   - dbl click should be like it is in grid (with timer not HTML dbl click event)
 *   - reorder with dgrag and drop
 *   - node.style is misleading - should be there to apply color for example
 *   - add multiselect
 *
 ************************************************************************/

(function ($) {
    var w2sidebar = function (options) {
        this.name = null;
        this.box = null;
        this.sidebar = null;
        this.parent = null;
        this.nodes = [];        // Sidebar child nodes
        this.menu = [];
        this.routeData = {};        // data for dynamic routes
        this.selected = null;      // current selected node (readonly)
        this.img = null;
        this.icon = null;
        this.style = '';
        this.topHTML = '';
        this.bottomHTML = '';
        this.flatButton = false;
        this.keyboard = true;
        this.flat = false;
        this.hasFocus = false;

        $.extend(true, this, w2obj.sidebar, options);
    };

    // ====================================================
    // -- Registers as a jQuery plugin

    $.fn.w2sidebar = function (method) {
        if ($.isPlainObject(method)) {
            // check name parameter
            if (!w2utils.checkName(method, 'w2sidebar')) return;
            // extend items
            var nodes = method.nodes;
            var object = new w2sidebar(method);
            $.extend(object, {handlers: [], nodes: []});
            if (nodes != null) {
                object.add(object, nodes);
            }
            if ($(this).length !== 0) {
                object.render($(this)[0]);
            }
            object.sidebar = object;
            // register new object
            w2ui[object.name] = object;
            return object;

        } else {
            var obj = w2ui[$(this).attr('name')];
            if (!obj) return null;
            if (arguments.length > 0) {
                if (obj[method]) obj[method].apply(obj, Array.prototype.slice.call(arguments, 1));
                return this;
            } else {
                return obj;
            }
        }
    };

    // ====================================================
    // -- Implementation of core functionality

    w2sidebar.prototype = {

        onClick: null,      // Fire when user click on Node Text
        onDblClick: null,      // Fire when user dbl clicks
        onContextMenu: null,
        onMenuClick: null,      // when context menu item selected
        onExpand: null,      // Fire when node Expands
        onCollapse: null,      // Fire when node Colapses
        onKeydown: null,
        onRender: null,
        onRefresh: null,
        onResize: null,
        onDestroy: null,
        onFocus: null,
        onBlur: null,
        onFlat: null,

        node: {
            id: null,
            text: '',
            count: null,
            img: null,
            icon: null,
            nodes: [],
            style: '',            // additional style for subitems
            route: null,
            selected: false,
            expanded: false,
            hidden: false,
            disabled: false,
            group: false,        // if true, it will build as a group
            groupShowHide: true,
            collapsible: true,
            plus: false,        // if true, plus will be shown even if there is no sub nodes
            // events
            onClick: null,
            onDblClick: null,
            onContextMenu: null,
            onExpand: null,
            onCollapse: null,
            // internal
            parent: null,         // node object
            sidebar: null
        },

        add: function (parent, nodes) {
            if (arguments.length == 1) {
                // need to be in reverse order
                nodes = arguments[0];
                parent = this;
            }
            if (typeof parent == 'string') parent = this.get(parent);
            return this.insert(parent, null, nodes);
        },

        insert: function (parent, before, nodes) {
            var txt, ind, tmp, node, nd;
            if (arguments.length == 2) {
                // need to be in reverse order
                nodes = arguments[1];
                before = arguments[0];
                if (before != null) {
                    ind = this.get(before);
                    if (ind == null) {
                        if (!$.isArray(nodes)) nodes = [nodes];
                        txt = (nodes[0].caption != null ? nodes[0].caption : nodes[0].text);
                        console.log('ERROR: Cannot insert node "' + txt + '" because cannot find node "' + before + '" to insert before.');
                        return null;
                    }
                    parent = this.get(before).parent;
                } else {
                    parent = this;
                }
            }
            if (typeof parent == 'string') parent = this.get(parent);
            if (!$.isArray(nodes)) nodes = [nodes];
            for (var o = 0; o &lt; nodes.length; o++) {
                node = nodes[o];
                if (typeof node.id == null) {
                    txt = (node.caption != null ? node.caption : node.text);
                    console.log('ERROR: Cannot insert node "' + txt + '" because it has no id.');
                    continue;
                }
                if (this.get(this, node.id) != null) {
                    txt = (node.caption != null ? node.caption : node.text);
                    console.log('ERROR: Cannot insert node with id=' + node.id + ' (text: ' + txt + ') because another node with the same id already exists.');
                    continue;
                }
                tmp = $.extend({}, w2sidebar.prototype.node, node);
                tmp.sidebar = this;
                tmp.parent = parent;
                nd = tmp.nodes || [];
                tmp.nodes = []; // very important to re-init empty nodes array
                if (before == null) { // append to the end
                    parent.nodes.push(tmp);
                } else {
                    ind = this.get(parent, before, true);
                    if (ind == null) {
                        txt = (node.caption != null ? node.caption : node.text);
                        console.log('ERROR: Cannot insert node "' + txt + '" because cannot find node "' + before + '" to insert before.');
                        return null;
                    }
                    parent.nodes.splice(ind, 0, tmp);
                }
                if (nd.length > 0) {
                    this.insert(tmp, null, nd);
                }
            }
            this.refresh(parent.id);
            return tmp;
        },

        remove: function () { // multiple arguments
            var deleted = 0;
            var tmp;
            for (var a = 0; a &lt; arguments.length; a++) {
                tmp = this.get(arguments[a]);
                if (tmp == null) continue;
                if (this.selected != null &amp;&amp; this.selected === tmp.id) {
                    this.selected = null;
                }
                var ind = this.get(tmp.parent, arguments[a], true);
                if (ind == null) continue;
                if (tmp.parent.nodes[ind].selected) tmp.sidebar.unselect(tmp.id);
                tmp.parent.nodes.splice(ind, 1);
                deleted++;
            }
            if (deleted > 0 &amp;&amp; arguments.length == 1) this.refresh(tmp.parent.id); else this.refresh();
            return deleted;
        },

        set: function (parent, id, node) {
            if (arguments.length == 2) {
                // need to be in reverse order
                node = id;
                id = parent;
                parent = this;
            }
            // searches all nested nodes
            if (typeof parent == 'string') parent = this.get(parent);
            if (parent.nodes == null) return null;
            for (var i = 0; i &lt; parent.nodes.length; i++) {
                if (parent.nodes[i].id === id) {
                    // make sure nodes inserted correctly
                    var nodes = node.nodes;
                    $.extend(parent.nodes[i], node, {nodes: []});
                    if (nodes != null) {
                        this.add(parent.nodes[i], nodes);
                    }
                    this.refresh(id);
                    return true;
                } else {
                    var rv = this.set(parent.nodes[i], id, node);
                    if (rv) return true;
                }
            }
            return false;
        },

        get: function (parent, id, returnIndex) { // can be just called get(id) or get(id, true)
            if (arguments.length === 0) {
                var all = [];
                var tmp = this.find({});
                for (var t = 0; t &lt; tmp.length; t++) {
                    if (tmp[t].id != null) all.push(tmp[t].id);
                }
                return all;
            } else {
                if (arguments.length == 1 || (arguments.length == 2 &amp;&amp; id === true)) {
                    // need to be in reverse order
                    returnIndex = id;
                    id = parent;
                    parent = this;
                }
                // searches all nested nodes
                if (typeof parent == 'string') parent = this.get(parent);
                if (parent.nodes == null) return null;
                for (var i = 0; i &lt; parent.nodes.length; i++) {
                    if (parent.nodes[i].id == id) {
                        if (returnIndex === true) return i; else return parent.nodes[i];
                    } else {
                        var rv = this.get(parent.nodes[i], id, returnIndex);
                        if (rv || rv === 0) return rv;
                    }
                }
                return null;
            }
        },

        find: function (parent, params, results) { // can be just called find({ selected: true })
            if (arguments.length == 1) {
                // need to be in reverse order
                params = parent;
                parent = this;
            }
            if (!results) results = [];
            // searches all nested nodes
            if (typeof parent == 'string') parent = this.get(parent);
            if (parent.nodes == null) return results;
            for (var i = 0; i &lt; parent.nodes.length; i++) {
                var match = true;
                for (var prop in params) { // params is an object
                    if (parent.nodes[i][prop] != params[prop]) match = false;
                }
                if (match) results.push(parent.nodes[i]);
                if (parent.nodes[i].nodes.length > 0) results = this.find(parent.nodes[i], params, results);
            }
            return results;
        },

        hide: function () { // multiple arguments
            var hidden = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                var tmp = this.get(arguments[a]);
                if (tmp == null) continue;
                tmp.hidden = true;
                hidden++;
            }
            if (arguments.length == 1) this.refresh(arguments[0]); else this.refresh();
            return hidden;
        },

        show: function () { // multiple arguments
            var shown = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                var tmp = this.get(arguments[a]);
                if (tmp == null) continue;
                tmp.hidden = false;
                shown++;
            }
            if (arguments.length == 1) this.refresh(arguments[0]); else this.refresh();
            return shown;
        },

        disable: function () { // multiple arguments
            var disabled = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                var tmp = this.get(arguments[a]);
                if (tmp == null) continue;
                tmp.disabled = true;
                if (tmp.selected) this.unselect(tmp.id);
                disabled++;
            }
            if (arguments.length == 1) this.refresh(arguments[0]); else this.refresh();
            return disabled;
        },

        enable: function () { // multiple arguments
            var enabled = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                var tmp = this.get(arguments[a]);
                if (tmp == null) continue;
                tmp.disabled = false;
                enabled++;
            }
            if (arguments.length == 1) this.refresh(arguments[0]); else this.refresh();
            return enabled;
        },

        select: function (id) {
            var new_node = this.get(id);
            if (!new_node) return false;
            if (this.selected == id &amp;&amp; new_node.selected) return false;
            this.unselect(this.selected);
            $(this.box).find('#node_' + w2utils.escapeId(id))
                .addClass('w2ui-selected')
                .find('.w2ui-icon').addClass('w2ui-icon-selected');
            new_node.selected = true;
            this.selected = id;
            return true;
        },

        unselect: function (id) {
            // if no arguments provided, unselect selected node
            if (arguments.length === 0) {
                id = this.selected;
            }
            var current = this.get(id);
            if (!current) return false;
            current.selected = false;
            $(this.box).find('#node_' + w2utils.escapeId(id))
                .removeClass('w2ui-selected')
                .find('.w2ui-icon').removeClass('w2ui-icon-selected');
            if (this.selected == id) this.selected = null;
            return true;
        },

        toggle: function (id) {
            var nd = this.get(id);
            if (nd == null) return false;
            if (nd.plus) {
                this.set(id, {plus: false});
                this.expand(id);
                this.refresh(id);
                return;
            }
            if (nd.nodes.length === 0) return false;
            if (!nd.collapsible) return false;
            if (this.get(id).expanded) return this.collapse(id); else return this.expand(id);
        },

        collapse: function (id) {
            var obj = this;
            var nd = this.get(id);
            // event before
            var edata = this.trigger({phase: 'before', type: 'collapse', target: id, object: nd});
            if (edata.isCancelled === true) return;
            // default action
            $(this.box).find('#node_' + w2utils.escapeId(id) + '_sub').slideUp(200);
            $(this.box).find('#node_' + w2utils.escapeId(id) + ' .w2ui-node-dots:first-child').html('&lt;div class="w2ui-expand">+&lt;/div>');
            nd.expanded = false;
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            setTimeout(function () {
                obj.refresh(id);
            }, 200);
            return true;
        },

        collapseAll: function (parent) {
            if (parent == null) parent = this;
            if (typeof parent == 'string') parent = this.get(parent);
            if (parent.nodes == null) return false;
            for (var i = 0; i &lt; parent.nodes.length; i++) {
                if (parent.nodes[i].expanded === true) parent.nodes[i].expanded = false;
                if (parent.nodes[i].nodes &amp;&amp; parent.nodes[i].nodes.length > 0) this.collapseAll(parent.nodes[i]);
            }
            this.refresh(parent.id);
            return true;
        },

        expand: function (id) {
            var obj = this;
            var nd = this.get(id);
            // event before
            var edata = this.trigger({phase: 'before', type: 'expand', target: id, object: nd});
            if (edata.isCancelled === true) return;
            // default action
            $(this.box).find('#node_' + w2utils.escapeId(id) + '_sub').slideDown(200);
            $(this.box).find('#node_' + w2utils.escapeId(id) + ' .w2ui-node-dots:first-child').html('&lt;div class="w2ui-expand">-&lt;/div>');
            nd.expanded = true;
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            setTimeout(function () {
                obj.refresh(id);
            }, 200);
            return true;
        },

        expandAll: function (parent) {
            if (parent == null) parent = this;
            if (typeof parent == 'string') parent = this.get(parent);
            if (parent.nodes == null) return false;
            for (var i = 0; i &lt; parent.nodes.length; i++) {
                if (parent.nodes[i].expanded === false) parent.nodes[i].expanded = true;
                if (parent.nodes[i].nodes &amp;&amp; parent.nodes[i].nodes.length > 0) this.expandAll(parent.nodes[i]);
            }
            this.refresh(parent.id);
        },

        expandParents: function (id) {
            var node = this.get(id);
            if (node == null) return false;
            if (node.parent) {
                if (!node.parent.expanded) {
                    node.parent.expanded = true;
                    this.refresh(node.parent.id);
                }
                this.expandParents(node.parent.id);
            }
            return true;
        },

        click: function (id, event) {
            var obj = this;
            var nd = this.get(id);
            if (nd == null) return;
            if (nd.disabled || nd.group) return; // should click event if already selected
            // unselect all previsously
            $(obj.box).find('.w2ui-node.w2ui-selected').each(function (index, el) {
                var oldID = $(el).attr('id').replace('node_', '');
                var oldNode = obj.get(oldID);
                if (oldNode != null) oldNode.selected = false;
                $(el).removeClass('w2ui-selected').find('.w2ui-icon').removeClass('w2ui-icon-selected');
            });
            // select new one
            var newNode = $(obj.box).find('#node_' + w2utils.escapeId(id));
            var oldNode = $(obj.box).find('#node_' + w2utils.escapeId(obj.selected));
            newNode.addClass('w2ui-selected').find('.w2ui-icon').addClass('w2ui-icon-selected');
            // need timeout to allow rendering
            setTimeout(function () {
                // event before
                var edata = obj.trigger({
                    phase: 'before',
                    type: 'click',
                    target: id,
                    originalEvent: event,
                    node: nd,
                    object: nd
                });
                if (edata.isCancelled === true) {
                    // restore selection
                    newNode.removeClass('w2ui-selected').find('.w2ui-icon').removeClass('w2ui-icon-selected');
                    oldNode.addClass('w2ui-selected').find('.w2ui-icon').addClass('w2ui-icon-selected');
                    return;
                }
                // default action
                if (oldNode != null) oldNode.selected = false;
                obj.get(id).selected = true;
                obj.selected = id;
                // route processing
                if (typeof nd.route == 'string') {
                    var route = nd.route !== '' ? String('/' + nd.route).replace(/\/{2,}/g, '/') : '';
                    var info = w2utils.parseRoute(route);
                    if (info.keys.length > 0) {
                        for (var k = 0; k &lt; info.keys.length; k++) {
                            if (obj.routeData[info.keys[k].name] == null) continue;
                            route = route.replace((new RegExp(':' + info.keys[k].name, 'g')), obj.routeData[info.keys[k].name]);
                        }
                    }
                    setTimeout(function () {
                        window.location.hash = route;
                    }, 1);
                }
                // event after
                obj.trigger($.extend(edata, {phase: 'after'}));
            }, 1);
        },

        focus: function (event) {
            var obj = this;
            // event before
            var edata = this.trigger({phase: 'before', type: 'focus', target: this.name, originalEvent: event});
            if (edata.isCancelled === true) return false;
            // default behaviour
            this.hasFocus = true;
            $(this.box).find('.w2ui-selected').removeClass('w2ui-inactive');
            setTimeout(function () {
                var $input = $(obj.box).find('#sidebar_' + obj.name + '_focus');
                if (!$input.is(':focus')) $input.focus();
            }, 10);
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        blur: function (event) {
            // event before
            var edata = this.trigger({phase: 'before', type: 'blur', target: this.name, originalEvent: event});
            if (edata.isCancelled === true) return false;
            // default behaviour
            this.hasFocus = false;
            $(this.box).find('.w2ui-selected').addClass('w2ui-inactive');
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        keydown: function (event) {
            var obj = this;
            var nd = obj.get(obj.selected);
            if (obj.keyboard !== true) return;
            if (!nd) nd = obj.nodes[0];
            // trigger event
            var edata = obj.trigger({phase: 'before', type: 'keydown', target: obj.name, originalEvent: event});
            if (edata.isCancelled === true) return;
            // default behaviour
            if (event.keyCode == 13 || event.keyCode == 32) { // enter or space
                if (nd.nodes.length > 0) obj.toggle(obj.selected);
            }
            if (event.keyCode == 37) { // left
                if (nd.nodes.length > 0 &amp;&amp; nd.expanded) {
                    obj.collapse(obj.selected);
                } else {
                    selectNode(nd.parent);
                    if (!nd.parent.group) obj.collapse(nd.parent.id);
                }
            }
            if (event.keyCode == 39) { // right
                if ((nd.nodes.length > 0 || nd.plus) &amp;&amp; !nd.expanded) obj.expand(obj.selected);
            }
            if (event.keyCode == 38) { // up
                selectNode(neighbor(nd, prev));
            }
            if (event.keyCode == 40) { // down
                selectNode(neighbor(nd, next));
            }
            // cancel event if needed
            if ($.inArray(event.keyCode, [13, 32, 37, 38, 39, 40]) != -1) {
                if (event.preventDefault) event.preventDefault();
                if (event.stopPropagation) event.stopPropagation();
            }
            // event after
            obj.trigger($.extend(edata, {phase: 'after'}));

            function selectNode(node, event) {
                if (node != null &amp;&amp; !node.hidden &amp;&amp; !node.disabled &amp;&amp; !node.group) {
                    obj.click(node.id, event);
                    setTimeout(function () {
                        obj.scrollIntoView();
                    }, 50);
                }
            }

            function neighbor(node, neighborFunc) {
                node = neighborFunc(node);
                while (node != null &amp;&amp; (node.hidden || node.disabled)) {
                    if (node.group) break; else node = neighborFunc(node);
                }
                return node;
            }

            function next(node, noSubs) {
                if (node == null) return null;
                var parent = node.parent;
                var ind = obj.get(node.id, true);
                var nextNode = null;
                // jump inside
                if (node.expanded &amp;&amp; node.nodes.length > 0 &amp;&amp; noSubs !== true) {
                    var t = node.nodes[0];
                    if (t.hidden || t.disabled || t.group) nextNode = next(t); else nextNode = t;
                } else {
                    if (parent &amp;&amp; ind + 1 &lt; parent.nodes.length) {
                        nextNode = parent.nodes[ind + 1];
                    } else {
                        nextNode = next(parent, true); // jump to the parent
                    }
                }
                if (nextNode != null &amp;&amp; (nextNode.hidden || nextNode.disabled || nextNode.group)) nextNode = next(nextNode);
                return nextNode;
            }

            function prev(node) {
                if (node == null) return null;
                var parent = node.parent;
                var ind = obj.get(node.id, true);
                var prevNode = (ind > 0) ? lastChild(parent.nodes[ind - 1]) : parent;
                if (prevNode != null &amp;&amp; (prevNode.hidden || prevNode.disabled || prevNode.group)) prevNode = prev(prevNode);
                return prevNode;
            }

            function lastChild(node) {
                if (node.expanded &amp;&amp; node.nodes.length > 0) {
                    var t = node.nodes[node.nodes.length - 1];
                    if (t.hidden || t.disabled || t.group) return prev(t); else return lastChild(t);
                }
                return node;
            }
        },

        scrollIntoView: function (id) {
            if (id == null) id = this.selected;
            var nd = this.get(id);
            if (nd == null) return;
            var body = $(this.box).find('.w2ui-sidebar-div');
            var item = $(this.box).find('#node_' + w2utils.escapeId(id));
            var offset = item.offset().top - body.offset().top;
            if (offset + item.height() > body.height() || offset &lt;= 0) {
                body.animate({'scrollTop': body.scrollTop() + offset - body.height() / 2 + item.height()}, 250, 'linear');
            }
        },

        dblClick: function (id, event) {
            var nd = this.get(id);
            // event before
            var edata = this.trigger({phase: 'before', type: 'dblClick', target: id, originalEvent: event, object: nd});
            if (edata.isCancelled === true) return;
            // default action
            this.toggle(id);
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        contextMenu: function (id, event) {
            var obj = this;
            var nd = obj.get(id);
            if (id != obj.selected) obj.click(id);
            // event before
            var edata = obj.trigger({
                phase: 'before',
                type: 'contextMenu',
                target: id,
                originalEvent: event,
                object: nd,
                allowOnDisabled: false
            });
            if (edata.isCancelled === true) return;
            // default action
            if (nd.disabled &amp;&amp; !edata.allowOnDisabled) return;
            if (obj.menu.length > 0) {
                $(obj.box).find('#node_' + w2utils.escapeId(id))
                    .w2menu({
                            items: obj.menu,
                            contextMenu: true,
                            originalEvent: event,
                            onSelect: function (event) {
                                obj.menuClick(id, parseInt(event.index), event.originalEvent);
                            }
                        }
                    );
            }
            // cancel event
            if (event.preventDefault) event.preventDefault();
            // event after
            obj.trigger($.extend(edata, {phase: 'after'}));
        },

        menuClick: function (itemId, index, event) {
            var obj = this;
            // event before
            var edata = obj.trigger({
                phase: 'before',
                type: 'menuClick',
                target: itemId,
                originalEvent: event,
                menuIndex: index,
                menuItem: obj.menu[index]
            });
            if (edata.isCancelled === true) return;
            // default action
            // -- empty
            // event after
            obj.trigger($.extend(edata, {phase: 'after'}));
        },

        goFlat: function () {
            // event before
            var edata = this.trigger({phase: 'before', type: 'flat', goFlat: !this.flat});
            if (edata.isCancelled === true) return;
            // default action
            this.flat = !this.flat;
            this.refresh();
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        render: function (box) {
            var time = (new Date()).getTime();
            var obj = this;
            // event before
            var edata = this.trigger({phase: 'before', type: 'render', target: this.name, box: box});
            if (edata.isCancelled === true) return;
            // default action
            if (box != null) {
                if ($(this.box).find('> div > div.w2ui-sidebar-div').length > 0) {
                    $(this.box)
                        .removeAttr('name')
                        .removeClass('w2ui-reset w2ui-sidebar')
                        .html('');
                }
                this.box = box;
            }
            if (!this.box) return;
            $(this.box)
                .attr('name', this.name)
                .addClass('w2ui-reset w2ui-sidebar')
                .html('&lt;div>' +
                    '&lt;input id="sidebar_' + this.name + '_focus" style="position: absolute; top: 0; right: 0; width: 1px; z-index: -1; opacity: 0"/>' +
                    '&lt;div class="w2ui-sidebar-top">&lt;/div>' +
                    '&lt;div class="w2ui-sidebar-div">&lt;/div>' +
                    '&lt;div class="w2ui-sidebar-bottom">&lt;/div>' +
                    '&lt;/div>'
                );
            $(this.box).find('> div').css({
                width: $(this.box).width() + 'px',
                height: $(this.box).height() + 'px'
            });
            if ($(this.box).length > 0) $(this.box)[0].style.cssText += this.style;
            // adjust top and bottom
            var flatHTML = '';
            if (this.flatButton == true) {
                flatHTML = '&lt;div class="w2ui-flat-' + (this.flat ? 'right' : 'left') + '" onclick="w2ui[\'' + this.name + '\'].goFlat()">&lt;/div>';
            }
            if (this.topHTML !== '' || flatHTML !== '') {
                $(this.box).find('.w2ui-sidebar-top').html(this.topHTML + flatHTML);
                $(this.box).find('.w2ui-sidebar-div')
                    .css('top', $(this.box).find('.w2ui-sidebar-top').height() + 'px');
            }
            if (this.bottomHTML !== '') {
                $(this.box).find('.w2ui-sidebar-bottom').html(this.bottomHTML);
                $(this.box).find('.w2ui-sidebar-div')
                    .css('bottom', $(this.box).find('.w2ui-sidebar-bottom').height() + 'px');
            }
            // focus
            var kbd_timer;
            $(this.box).find('#sidebar_' + this.name + '_focus')
                .on('focus', function (event) {
                    clearTimeout(kbd_timer);
                    if (!obj.hasFocus) obj.focus(event);
                })
                .on('blur', function (event) {
                    kbd_timer = setTimeout(function () {
                        if (obj.hasFocus) {
                            obj.blur(event);
                        }
                    }, 100);
                })
                .on('keydown', function (event) {
                    if (event.keyCode != 9) { // not tab
                        w2ui[obj.name].keydown.call(w2ui[obj.name], event);
                    }
                });
            $(this.box).off('mousedown').on('mousedown', function (event) {
                // set focus to grid
                setTimeout(function () {
                    // if input then do not focus
                    if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(event.target.tagName.toUpperCase()) == -1) {
                        var $input = $(obj.box).find('#sidebar_' + obj.name + '_focus');
                        if (!$input.is(':focus')) {
                            if ($(event.target).hasClass('w2ui-node')) {
                                var top = $(event.target).position().top + $(obj.box).find('.w2ui-sidebar-top').height() + event.offsetY;
                                $input.css({top: top + 'px', left: '0px'});
                            }
                            $input.focus();
                        }
                    }
                }, 1);
            });
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            // ---
            this.refresh();
            return (new Date()).getTime() - time;
        },

        refresh: function (id) {
            var time = (new Date()).getTime();
            // event before
            var edata = this.trigger({
                phase: 'before', type: 'refresh', target: (id != null ? id : this.name),
                fullRefresh: (id != null ? false : true)
            });
            if (edata.isCancelled === true) return;
            // adjust top and bottom
            var flatHTML = '';
            if (this.flatButton == true) {
                flatHTML = '&lt;div class="w2ui-flat-' + (this.flat ? 'right' : 'left') + '" onclick="w2ui[\'' + this.name + '\'].goFlat()">&lt;/div>';
            }
            if (this.topHTML !== '' || flatHTML !== '') {
                $(this.box).find('.w2ui-sidebar-top').html(this.topHTML + flatHTML);
                $(this.box).find('.w2ui-sidebar-div')
                    .css('top', $(this.box).find('.w2ui-sidebar-top').height() + 'px');
            }
            if (this.bottomHTML !== '') {
                $(this.box).find('.w2ui-sidebar-bottom').html(this.bottomHTML);
                $(this.box).find('.w2ui-sidebar-div')
                    .css('bottom', $(this.box).find('.w2ui-sidebar-bottom').height() + 'px');
            }
            // default action
            $(this.box).find('> div').removeClass('w2ui-sidebar-flat').addClass(this.flat ? 'w2ui-sidebar-flat' : '').css({
                width: $(this.box).width() + 'px',
                height: $(this.box).height() + 'px'
            });
            var obj = this;
            var node, nd;
            var nm;
            if (id == null) {
                node = this;
                nm = '.w2ui-sidebar-div';
            } else {
                node = this.get(id);
                if (node == null) return;
                nm = '#node_' + w2utils.escapeId(node.id) + '_sub';
            }
            var nodeHTML;
            if (node !== this) {
                var tmp = '#node_' + w2utils.escapeId(node.id);
                nodeHTML = getNodeHTML(node);
                $(this.box).find(tmp).before('&lt;div id="sidebar_' + this.name + '_tmp">&lt;/div>');
                $(this.box).find(tmp).remove();
                $(this.box).find(nm).remove();
                $('#sidebar_' + this.name + '_tmp').before(nodeHTML);
                $('#sidebar_' + this.name + '_tmp').remove();
            }
            // refresh sub nodes
            $(this.box).find(nm).html('');
            for (var i = 0; i &lt; node.nodes.length; i++) {
                nd = node.nodes[i];
                nodeHTML = getNodeHTML(nd);
                $(this.box).find(nm).append(nodeHTML);
                if (nd.nodes.length !== 0) {
                    this.refresh(nd.id);
                } else {
                    // trigger event
                    var edata2 = this.trigger({phase: 'before', type: 'refresh', target: nd.id});
                    if (edata2.isCancelled === true) return;
                    // event after
                    this.trigger($.extend(edata2, {phase: 'after'}));
                }
            }
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            return (new Date()).getTime() - time;

            function getNodeHTML(nd) {
                var html = '';
                var img = nd.img;
                if (img == null) img = this.img;
                var icon = nd.icon;
                if (icon == null) icon = this.icon;
                // -- find out level
                var tmp = nd.parent;
                var level = 0;
                while (tmp &amp;&amp; tmp.parent != null) {
                    if (tmp.group) level--;
                    tmp = tmp.parent;
                    level++;
                }
                if (nd.caption != null) nd.text = nd.caption;
                if (nd.group) {
                    html =
                        '&lt;div class="w2ui-node-group w2ui-level-' + level + '" id="node_' + nd.id + '"' +
                        '   onclick="w2ui[\'' + obj.name + '\'].toggle(\'' + nd.id + '\')"' +
                        '   oncontextmenu="w2ui[\'' + obj.name + '\'].contextMenu(\'' + nd.id + '\', event);"' +
                        '   onmouseout="jQuery(this).find(\'span:nth-child(1)\').css(\'color\', \'transparent\')" ' +
                        '   onmouseover="jQuery(this).find(\'span:nth-child(1)\').css(\'color\', \'inherit\')">' +
                        ((nd.groupShowHide &amp;&amp; nd.collapsible) ? '&lt;span>' + (!nd.hidden &amp;&amp; nd.expanded ? w2utils.lang('Hide') : w2utils.lang('Show')) + '&lt;/span>' : '&lt;span>&lt;/span>') +
                        (typeof nd.text == 'function' ? nd.text.call(obj, nd) : '&lt;span>' + nd.text + '&lt;/span>') +
                        '&lt;/div>' +
                        '&lt;div class="w2ui-node-sub" id="node_' + nd.id + '_sub" style="' + nd.style + ';' + (!nd.hidden &amp;&amp; nd.expanded ? '' : 'display: none;') + '">&lt;/div>';
                    if (obj.flat) {
                        html = '&lt;div class="w2ui-node-group" id="node_' + nd.id + '">&lt;span>&amp;#160;&lt;/span>&lt;/div>' +
                            '&lt;div id="node_' + nd.id + '_sub" style="' + nd.style + ';' + (!nd.hidden &amp;&amp; nd.expanded ? '' : 'display: none;') + '">&lt;/div>';
                    }
                } else {
                    if (nd.selected &amp;&amp; !nd.disabled) obj.selected = nd.id;
                    tmp = '';
                    if (img) tmp = '&lt;div class="w2ui-node-image w2ui-icon ' + img + (nd.selected &amp;&amp; !nd.disabled ? " w2ui-icon-selected" : "") + '">&lt;/div>';
                    if (icon) tmp = '&lt;div class="w2ui-node-image">&lt;span class="' + icon + '">&lt;/span>&lt;/div>';
                    var text = nd.text;
                    if (typeof nd.text == 'function') text = nd.text.call(obj, nd);
                    html = '&lt;div class="w2ui-node w2ui-level-' + level + ' ' + (nd.selected ? 'w2ui-selected' : '') + ' ' + (nd.disabled ? 'w2ui-disabled' : '') + '" id="node_' + nd.id + '" style="' + (nd.hidden ? 'display: none;' : '') + '"' +
                        '    ondblclick="w2ui[\'' + obj.name + '\'].dblClick(\'' + nd.id + '\', event);"' +
                        '    oncontextmenu="w2ui[\'' + obj.name + '\'].contextMenu(\'' + nd.id + '\', event);"' +
                        '    onClick="w2ui[\'' + obj.name + '\'].click(\'' + nd.id + '\', event); ">' +
                        '&lt;table cellpadding="0" cellspacing="0" style="margin-left:' + (level * 18) + 'px; padding-right:' + (level * 18) + 'px">&lt;tbody>&lt;tr>' +
                        '&lt;td class="w2ui-node-dots" nowrap="nowrap" onclick="w2ui[\'' + obj.name + '\'].toggle(\'' + nd.id + '\'); ' +
                        '        if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;">' +
                        '    &lt;div class="w2ui-expand">' + (nd.nodes.length > 0 ? (nd.expanded ? '-' : '+') : (nd.plus ? '+' : '')) + '&lt;/div>' +
                        '&lt;/td>' +
                        '&lt;td class="w2ui-node-data" nowrap="nowrap">' +
                        tmp +
                        (nd.count || nd.count === 0 ? '&lt;div class="w2ui-node-count">' + nd.count + '&lt;/div>' : '') +
                        '&lt;div class="w2ui-node-caption">' + text + '&lt;/div>' +
                        '&lt;/td>' +
                        '&lt;/tr>&lt;/tbody>&lt;/table>' +
                        '&lt;/div>' +
                        '&lt;div class="w2ui-node-sub" id="node_' + nd.id + '_sub" style="' + nd.style + ';' + (!nd.hidden &amp;&amp; nd.expanded ? '' : 'display: none;') + '">&lt;/div>';
                    if (obj.flat) {
                        html = '&lt;div class="w2ui-node w2ui-level-' + level + ' ' + (nd.selected ? 'w2ui-selected' : '') + ' ' + (nd.disabled ? 'w2ui-disabled' : '') + '" id="node_' + nd.id + '" style="' + (nd.hidden ? 'display: none;' : '') + '"' +
                            '    onmouseover="jQuery(this).find(\'.w2ui-node-data\').w2tag(w2utils.base64decode(\'' +
                            w2utils.base64encode(text + (nd.count || nd.count === 0 ? ' - &lt;span class="w2ui-node-count">' + nd.count + '&lt;/span>' : '')) + '\'), ' +
                            '               { id: \'' + nd.id + '\', left: -5 })"' +
                            '    onmouseout="jQuery(this).find(\'.w2ui-node-data\').w2tag(null, { id: \'' + nd.id + '\' })"' +
                            '    ondblclick="w2ui[\'' + obj.name + '\'].dblClick(\'' + nd.id + '\', event);"' +
                            '    oncontextmenu="w2ui[\'' + obj.name + '\'].contextMenu(\'' + nd.id + '\', event);"' +
                            '    onClick="w2ui[\'' + obj.name + '\'].click(\'' + nd.id + '\', event); ">' +
                            '&lt;div class="w2ui-node-data w2ui-node-flat">' + tmp + '&lt;/div>' +
                            '&lt;/div>' +
                            '&lt;div class="w2ui-node-sub" id="node_' + nd.id + '_sub" style="' + nd.style + ';' + (!nd.hidden &amp;&amp; nd.expanded ? '' : 'display: none;') + '">&lt;/div>';
                    }
                }
                return html;
            }
        },

        resize: function () {
            var time = (new Date()).getTime();
            // event before
            var edata = this.trigger({phase: 'before', type: 'resize', target: this.name});
            if (edata.isCancelled === true) return;
            // default action
            $(this.box).css('overflow', 'hidden');    // container should have no overflow
            $(this.box).find('> div').css({
                width: $(this.box).width() + 'px',
                height: $(this.box).height() + 'px'
            });
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            return (new Date()).getTime() - time;
        },

        destroy: function () {
            // event before
            var edata = this.trigger({phase: 'before', type: 'destroy', target: this.name});
            if (edata.isCancelled === true) return;
            // clean up
            if ($(this.box).find('> div > div.w2ui-sidebar-div').length > 0) {
                $(this.box)
                    .removeAttr('name')
                    .removeClass('w2ui-reset w2ui-sidebar')
                    .html('');
            }
            delete w2ui[this.name];
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        lock: function (msg, showSpinner) {
            var args = Array.prototype.slice.call(arguments, 0);
            args.unshift(this.box);
            w2utils.lock.apply(window, args);
        },

        unlock: function (speed) {
            w2utils.unlock(this.box, speed);
        }
    };

    $.extend(w2sidebar.prototype, w2utils.event);
    w2obj.sidebar = w2sidebar;
})(jQuery);

/************************************************************************
 *   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
 *   - Following objects defined
 *        - w2field        - various field controls
 *        - $().w2field    - jQuery wrapper
 *   - Dependencies: jQuery, w2utils
 *
 * == NICE TO HAVE ==
 *   - upload (regular files)
 *   - BUG with prefix/postfix and arrows (test in different contexts)
 *   - multiple date selection
 *   - month selection, year selections
 *   - arrows no longer work (for int)
 *   - form to support custom types
 *   - rewrite suffix and prefix positioning with translateY()
 *   - prefix and suffix are slow (100ms or so)
 *   - MultiSelect - Allow Copy/Paste for single and multi values
 *   - add routeData to list/enum
 *   - for type: list -> read value from attr('value')
 *   - ENUM, LIST: should have same as grid (limit, offset, search, sort)
 *   - ENUM, LIST: should support wild chars
 *   - add selection of predefined times (used for appointments)
 *
 ************************************************************************/

(function ($) {

    var w2field = function (options) {
        // public properties
        this.el = null;
        this.helpers = {}; // object or helper elements
        this.type = options.type || 'text';
        this.options = $.extend(true, {}, options);
        this.onSearch = options.onSearch || null;
        this.onRequest = options.onRequest || null;
        this.onLoad = options.onLoad || null;
        this.onError = options.onError || null;
        this.onClick = options.onClick || null;
        this.onAdd = options.onAdd || null;
        this.onNew = options.onNew || null;
        this.onRemove = options.onRemove || null;
        this.onMouseOver = options.onMouseOver || null;
        this.onMouseOut = options.onMouseOut || null;
        this.onIconClick = options.onIconClick || null;
        this.onScroll = options.onScroll || null;
        this.tmp = {}; // temp object
        // clean up some options
        delete this.options.type;
        delete this.options.onSearch;
        delete this.options.onRequest;
        delete this.options.onLoad;
        delete this.options.onError;
        delete this.options.onClick;
        delete this.options.onMouseOver;
        delete this.options.onMouseOut;
        delete this.options.onIconClick;
        delete this.options.onScroll;
        // extend with defaults
        $.extend(true, this, w2obj.field);
    };

    // ====================================================
    // -- Registers as a jQuery plugin

    $.fn.w2field = function (method, options) {
        // call direct
        if (this.length === 0) {
            var pr = w2field.prototype;
            if (pr[method]) {
                return pr[method].apply(pr, Array.prototype.slice.call(arguments, 1));
            }
        } else {
            // if without arguments - return the object
            if (arguments.length === 0) {
                var obj = $(this).data('w2field');
                return obj;
            }
            if (typeof method == 'string' &amp;&amp; typeof options == 'object') {
                method = $.extend(true, {}, options, {type: method});
            }
            if (typeof method == 'string' &amp;&amp; options == null) {
                method = {type: method};
            }
            method.type = String(method.type).toLowerCase();
            return this.each(function (index, el) {
                var obj = $(el).data('w2field');
                // if object is not defined, define it
                if (obj == null) {
                    var obj = new w2field(method);
                    $.extend(obj, {handlers: []});
                    if (el) obj.el = $(el)[0];
                    obj.init();
                    $(el).data('w2field', obj);
                    return obj;
                } else { // fully re-init
                    obj.clear();
                    if (method.type == 'clear') return;
                    var obj = new w2field(method);
                    $.extend(obj, {handlers: []});
                    if (el) obj.el = $(el)[0];
                    obj.init();
                    $(el).data('w2field', obj);
                    return obj;
                }
                return null;
            });
        }
    };

    // ====================================================
    // -- Implementation of core functionality

    /*     To add custom types
     $().w2field('addType', 'myType', function (options) {
     $(this.el).on('keypress', function (event) {
     if (event.metaKey || event.ctrlKey || event.altKey
     || (event.charCode != event.keyCode &amp;&amp; event.keyCode > 0)) return;
     var ch = String.fromCharCode(event.charCode);
     if (ch != 'a' &amp;&amp; ch != 'b' &amp;&amp; ch != 'c') {
     if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;
     return false;
     }
     });
     $(this.el).on('blur', function (event)  { // keyCode &amp; charCode differ in FireFox
     var ch = this.value;
     if (ch != 'a' &amp;&amp; ch != 'b' &amp;&amp; ch != 'c') {
     $(this).w2tag(w2utils.lang("Not a single character from the set of 'abc'"));
     }
     });
     });
     */

    w2field.prototype = {

        custom: {},  // map of custom types

        addType: function (type, handler) {
            type = String(type).toLowerCase();
            this.custom[type] = handler;
            return true;
        },

        removeType: function (type) {
            type = String(type).toLowerCase();
            if (!this.custom[type]) return false;
            delete this.custom[type];
            return true;
        },

        init: function () {
            var obj = this;
            var options = this.options;
            var defaults;

            // Custom Types
            if (typeof this.custom[this.type] == 'function') {
                this.custom[this.type].call(this, options);
                return;
            }
            // only for INPUT or TEXTAREA
            if (['INPUT', 'TEXTAREA'].indexOf(this.el.tagName.toUpperCase()) == -1) {
                console.log('ERROR: w2field could only be applied to INPUT or TEXTAREA.', this.el);
                return;
            }

            switch (this.type) {
                case 'text':
                case 'int':
                case 'float':
                case 'money':
                case 'currency':
                case 'percent':
                case 'alphanumeric':
                case 'bin':
                case 'hex':
                    defaults = {
                        min: null,
                        max: null,
                        step: 1,
                        autoFormat: true,
                        currencyPrefix: w2utils.settings.currencyPrefix,
                        currencySuffix: w2utils.settings.currencySuffix,
                        currencyPrecision: w2utils.settings.currencyPrecision,
                        decimalSymbol: w2utils.settings.decimalSymbol,
                        groupSymbol: w2utils.settings.groupSymbol,
                        arrows: false,
                        keyboard: true,
                        precision: null,
                        silent: true,
                        prefix: '',
                        suffix: ''
                    };
                    this.options = $.extend(true, {}, defaults, options);
                    options = this.options; // since object is re-created, need to re-assign
                    options.numberRE = new RegExp('[' + options.groupSymbol + ']', 'g');
                    options.moneyRE = new RegExp('[' + options.currencyPrefix + options.currencySuffix + options.groupSymbol + ']', 'g');
                    options.percentRE = new RegExp('[' + options.groupSymbol + '%]', 'g');
                    // no keyboard support needed
                    if (['text', 'alphanumeric', 'hex', 'bin'].indexOf(this.type) != -1) {
                        options.arrows = false;
                        options.keyboard = false;
                    }
                    this.addPrefix(); // only will add if needed
                    this.addSuffix();
                    break;

                case 'color':
                    defaults = {
                        prefix: '#',
                        suffix: '&lt;div style="width: ' + (parseInt($(this.el).css('font-size')) || 12) + 'px">&amp;#160;&lt;/div>',
                        arrows: false,
                        keyboard: false,
                        transparent: true
                    };
                    $.extend(options, defaults);
                    this.addPrefix();    // only will add if needed
                    this.addSuffix();    // only will add if needed
                    // additional checks
                    $(this.el).attr('maxlength', 6);
                    if ($(this.el).val() !== '') setTimeout(function () {
                        obj.change();
                    }, 1);
                    break;

                case 'date':
                    defaults = {
                        format: w2utils.settings.dateFormat, // date format
                        keyboard: true,
                        silent: true,
                        start: '',       // string or jquery object
                        end: '',       // string or jquery object
                        blocked: {},       // { '4/11/2011': 'yes' }
                        colored: {},        // { '4/11/2011': 'red:white' }
                        blockWeekDays: null       // array of numbers of weekday to block
                    };
                    this.options = $.extend(true, {}, defaults, options);
                    options = this.options; // since object is re-created, need to re-assign
                    if ($(this.el).attr('placeholder') == null) $(this.el).attr('placeholder', options.format);
                    break;

                case 'time':
                    defaults = {
                        format: w2utils.settings.timeFormat,
                        keyboard: true,
                        silent: true,
                        start: '',
                        end: '',
                        noMinutes: false
                    };
                    this.options = $.extend(true, {}, defaults, options);
                    options = this.options; // since object is re-created, need to re-assign
                    if ($(this.el).attr('placeholder') == null) $(this.el).attr('placeholder', options.format);
                    break;

                case 'datetime':
                    defaults = {
                        format: w2utils.settings.dateFormat + ' | ' + w2utils.settings.timeFormat,
                        keyboard: true,
                        silent: true,
                        start: '',       // string or jquery object or Date object
                        end: '',       // string or jquery object or Date object
                        blocked: [],       // [ '4/11/2011', '4/12/2011' ] or [ new Date(2011, 4, 11), new Date(2011, 4, 12) ]
                        colored: {},       // { '12/17/2014': 'blue:green', '12/18/2014': 'gray:white'  }; // key has to be formatted with w2utils.settings.dateFormat
                        placeholder: null,     // optional. will fall back to this.format if not specified. Only used if this.el has no placeholder attribute.
                        btn_now: true,     // show/hide the use-current-date-and-time button
                        noMinutes: false
                    };
                    this.options = $.extend(true, {}, defaults, options);
                    options = this.options; // since object is re-created, need to re-assign
                    if ($(this.el).attr('placeholder') == null) $(this.el).attr('placeholder', options.placeholder || options.format);
                    break;

                case 'list':
                case 'combo':
                    defaults = {
                        items: [],
                        selected: {},
                        url: null,          // url to pull data from
                        recId: null,          // map retrieved data from url to id, can be string or function
                        recText: null,          // map retrieved data from url to text, can be string or function
                        method: null,          // default comes from w2utils.settings.dataType
                        interval: 350,           // number of ms to wait before sending server call on search
                        postData: {},
                        minLength: 1,            // min number of chars when trigger search
                        cacheMax: 250,
                        maxDropHeight: 350,          // max height for drop down menu
                        maxDropWidth: null,         // if null then auto set
                        match: 'begins',     // ['contains', 'is', 'begins', 'ends']
                        silent: true,
                        icon: null,
                        iconStyle: '',
                        onSearch: null,         // when search needs to be performed
                        onRequest: null,         // when request is submitted
                        onLoad: null,         // when data is received
                        onError: null,         // when data fails to load due to server error or other failure modes
                        onIconClick: null,
                        renderDrop: null,         // render function for drop down item
                        compare: null,         // compare function for filtering
                        filter: true,         // weather to filter at all
                        prefix: '',
                        suffix: '',
                        openOnFocus: false,        // if to show overlay onclick or when typing
                        markSearch: false
                    };
                    options.items = this.normMenu(options.items); // need to be first
                    if (this.type == 'list') {
                        // defaults.search = (options.items &amp;&amp; options.items.length >= 10 ? true : false);
                        defaults.openOnFocus = true;
                        $(this.el).addClass('w2ui-select');
                        // if simple value - look it up
                        if (!$.isPlainObject(options.selected) &amp;&amp; options.items) {
                            for (var i = 0; i &lt; options.items.length; i++) {
                                var item = options.items[i];
                                if (item &amp;&amp; item.id == options.selected) {
                                    options.selected = $.extend(true, {}, item);
                                    break;
                                }
                            }
                        }
                        this.watchSize();
                    }
                    options = $.extend({}, defaults, options, {
                        align: 'both',      // same width as control
                        altRows: true         // alternate row color
                    });
                    this.options = options;
                    if (!$.isPlainObject(options.selected)) options.selected = {};
                    $(this.el).data('selected', options.selected);
                    if (options.url) {
                        options.items = [];
                        this.request(0);
                    }
                    if (this.type == 'list') this.addFocus();
                    this.addPrefix();
                    this.addSuffix();
                    setTimeout(function () {
                        obj.refresh();
                    }, 10); // need this for icon refresh
                    $(this.el).attr('autocomplete', 'off');
                    if (options.selected.text != null) $(this.el).val(options.selected.text);
                    break;

                case 'enum':
                    defaults = {
                        items: [],
                        selected: [],
                        max: 0,             // max number of selected items, 0 - unlim
                        url: null,          // not implemented
                        recId: null,          // map retrieved data from url to id, can be string or function
                        recText: null,          // map retrieved data from url to text, can be string or function
                        interval: 350,           // number of ms to wait before sending server call on search
                        method: null,          // default comes from w2utils.settings.dataType
                        postData: {},
                        minLength: 1,            // min number of chars when trigger search
                        cacheMax: 250,
                        maxWidth: 250,           // max width for a single item
                        maxHeight: 350,           // max height for input control to grow
                        maxDropHeight: 350,           // max height for drop down menu
                        maxDropWidth: null,          // if null then auto set
                        match: 'contains',    // ['contains', 'is', 'begins', 'ends']
                        silent: true,
                        openOnFocus: false,         // if to show overlay onclick or when typing
                        markSearch: true,
                        renderDrop: null,          // render function for drop down item
                        renderItem: null,          // render selected item
                        compare: null,          // compare function for filtering
                        filter: true,          // alias for compare
                        style: '',            // style for container div
                        onSearch: null,          // when search needs to be performed
                        onRequest: null,          // when request is submitted
                        onLoad: null,          // when data is received
                        onError: null,          // when data fails to load due to server error or other failure modes
                        onClick: null,          // when an item is clicked
                        onAdd: null,          // when an item is added
                        onNew: null,          // when new item should be added
                        onRemove: null,          // when an item is removed
                        onMouseOver: null,          // when an item is mouse over
                        onMouseOut: null,          // when an item is mouse out
                        onScroll: null           // when div with selected items is scrolled
                    };
                    options = $.extend({}, defaults, options, {
                        align: 'both',    // same width as control
                        suffix: '',
                        altRows: true       // alternate row color
                    });
                    options.items = this.normMenu(options.items);
                    options.selected = this.normMenu(options.selected);
                    this.options = options;
                    if (!$.isArray(options.selected)) options.selected = [];
                    $(this.el).data('selected', options.selected);
                    if (options.url) {
                        options.items = [];
                        this.request(0);
                    }
                    this.addSuffix();
                    this.addMulti();
                    this.watchSize();
                    break;

                case 'file':
                    defaults = {
                        selected: [],
                        max: 0,
                        maxSize: 0,        // max size of all files, 0 - unlim
                        maxFileSize: 0,        // max size of a single file, 0 -unlim
                        maxWidth: 250,      // max width for a single item
                        maxHeight: 350,      // max height for input control to grow
                        maxDropHeight: 350,      // max height for drop down menu
                        maxDropWidth: null,     // if null then auto set
                        readContent: true,     // if true, it will readAsDataURL content of the file
                        silent: true,
                        renderItem: null,     // render selected item
                        style: '',       // style for container div
                        onClick: null,     // when an item is clicked
                        onAdd: null,     // when an item is added
                        onRemove: null,     // when an item is removed
                        onMouseOver: null,     // when an item is mouse over
                        onMouseOut: null      // when an item is mouse out
                    };
                    options = $.extend({}, defaults, options, {
                        align: 'both',   // same width as control
                        altRows: true     // alternate row color
                    });
                    this.options = options;
                    if (!$.isArray(options.selected)) options.selected = [];
                    $(this.el).data('selected', options.selected);
                    if ($(this.el).attr('placeholder') == null) {
                        $(this.el).attr('placeholder', w2utils.lang('Attach files by dragging and dropping or Click to Select'));
                    }
                    this.addMulti();
                    this.watchSize();
                    break;
            }
            // attach events
            this.tmp = {
                onChange: function (event) {
                    obj.change.call(obj, event);
                },
                onClick: function (event) {
                    obj.click.call(obj, event);
                },
                onFocus: function (event) {
                    obj.focus.call(obj, event);
                },
                onBlur: function (event) {
                    obj.blur.call(obj, event);
                },
                onKeydown: function (event) {
                    obj.keyDown.call(obj, event);
                },
                onKeyup: function (event) {
                    obj.keyUp.call(obj, event);
                },
                onKeypress: function (event) {
                    obj.keyPress.call(obj, event);
                }
            };
            $(this.el)
                .addClass('w2field w2ui-input')
                .data('w2field', this)
                .on('change.w2field', this.tmp.onChange)
                .on('click.w2field', this.tmp.onClick)         // ignore click because it messes overlays
                .on('focus.w2field', this.tmp.onFocus)
                .on('blur.w2field', this.tmp.onBlur)
                .on('keydown.w2field', this.tmp.onKeydown)
                .on('keyup.w2field', this.tmp.onKeyup)
                .on('keypress.w2field', this.tmp.onKeypress)
                .css(w2utils.cssPrefix('box-sizing', 'border-box'));
            // format initial value
            this.change($.Event('change'));
        },

        watchSize: function () {
            var obj = this;
            var tmp = $(obj.el).data('tmp') || {};
            tmp.sizeTimer = setInterval(function () {
                if ($(obj.el).parents('body').length > 0) {
                    obj.resize();
                } else {
                    clearInterval(tmp.sizeTimer);
                }
            }, 200);
            $(obj.el).data('tmp', tmp);
        },

        get: function () {
            var ret;
            if (['list', 'enum', 'file'].indexOf(this.type) != -1) {
                ret = $(this.el).data('selected');
            } else {
                ret = $(this.el).val();
            }
            return ret;
        },

        set: function (val, append) {
            if (['list', 'enum', 'file'].indexOf(this.type) != -1) {
                if (this.type != 'list' &amp;&amp; append) {
                    if ($(this.el).data('selected') == null) $(this.el).data('selected', []);
                    $(this.el).data('selected').push(val);
                    $(this.el).change();
                } else {
                    var it = (this.type == 'enum' ? [val] : val);
                    $(this.el).data('selected', it).change();
                }
                this.refresh();
            } else {
                $(this.el).val(val);
            }
        },

        setIndex: function (ind, append) {
            if (['list', 'enum'].indexOf(this.type) != -1) {
                var items = this.options.items;
                if (items &amp;&amp; items[ind]) {
                    if (this.type != 'list' &amp;&amp; append) {
                        if ($(this.el).data('selected') == null) $(this.el).data('selected', []);
                        $(this.el).data('selected').push(items[ind]);
                        $(this.el).change();
                    } else {
                        var it = (this.type == 'enum' ? [items[ind]] : items[ind]);
                        $(this.el).data('selected', it).change();
                    }
                    this.refresh();
                    return true;
                }
            }
            return false;
        },

        clear: function () {
            var obj = this;
            var options = this.options;
            // if money then clear value
            if (['money', 'currency'].indexOf(this.type) != -1) {
                $(this.el).val($(this.el).val().replace(options.moneyRE, ''));
            }
            if (this.type == 'percent') {
                $(this.el).val($(this.el).val().replace(/%/g, ''));
            }
            if (this.type == 'color') {
                $(this.el).removeAttr('maxlength');
            }
            if (this.type == 'list') {
                $(this.el).removeClass('w2ui-select');
            }
            this.type = 'clear';
            var tmp = $(this.el).data('tmp');
            if (!this.tmp) return;
            // restore paddings
            if (tmp != null) {
                $(this.el).height('auto');
                if (tmp &amp;&amp; tmp['old-padding-left']) $(this.el).css('padding-left', tmp['old-padding-left']);
                if (tmp &amp;&amp; tmp['old-padding-right']) $(this.el).css('padding-right', tmp['old-padding-right']);
                if (tmp &amp;&amp; tmp['old-background-color']) $(this.el).css('background-color', tmp['old-background-color']);
                if (tmp &amp;&amp; tmp['old-border-color']) $(this.el).css('border-color', tmp['old-border-color']);
                // remove resize watcher
                clearInterval(tmp.sizeTimer);
            }
            // remove events and (data)
            $(this.el)
                .val(this.clean($(this.el).val()))
                .removeClass('w2field')
                .removeData()       // removes all attached data
                .off('.w2field');   // remove only events added by w2field
            // remove helpers
            for (var h in this.helpers) $(this.helpers[h]).remove();
            this.helpers = {};
        },

        refresh: function () {
            var obj = this;
            var options = this.options;
            var selected = $(this.el).data('selected');
            var time = (new Date()).getTime();
            // enum
            if (['list'].indexOf(this.type) != -1) {
                $(obj.el).parent().css('white-space', 'nowrap'); // needs this for arrow always to appear on the right side
                // hide focus and show text
                if (obj.helpers.prefix) obj.helpers.prefix.hide();
                setTimeout(function () {
                    if (!obj.helpers.focus) return;
                    // if empty show no icon
                    if (!$.isEmptyObject(selected) &amp;&amp; options.icon) {
                        options.prefix = '&lt;span class="w2ui-icon ' + options.icon + '"style="cursor: pointer; font-size: 14px;' +
                            ' display: inline-block; margin-top: -1px; color: #7F98AD;' + options.iconStyle + '">' +
                            '&lt;/span>';
                        obj.addPrefix();
                    } else {
                        options.prefix = '';
                        obj.addPrefix();
                    }
                    // focus helper
                    var focus = obj.helpers.focus.find('input');
                    if ($(focus).val() === '') {
                        $(focus).css('text-indent', '-9999em').prev().css('opacity', 0);
                        $(obj.el).val(selected &amp;&amp; selected.text != null ? w2utils.lang(selected.text) : '');
                    } else {
                        $(focus).css('text-indent', 0).prev().css('opacity', 1);
                        $(obj.el).val('');
                        setTimeout(function () {
                            if (obj.helpers.prefix) obj.helpers.prefix.hide();
                            var tmp = 'position: absolute; opacity: 0; margin: 4px 0px 0px 2px; background-position: left !important;';
                            if (options.icon) {
                                $(focus).css('margin-left', '17px');
                                $(obj.helpers.focus).find('.icon-search').attr('style', tmp + 'width: 11px !important; opacity: 1; display: block');
                            } else {
                                $(focus).css('margin-left', '0px');
                                $(obj.helpers.focus).find('.icon-search').attr('style', tmp + 'width: 0px !important; opacity: 0; display: none');
                            }
                        }, 1);
                    }
                    // if readonly or disabled
                    if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) {
                        setTimeout(function () {
                            $(obj.helpers.prefix).css('opacity', '0.6');
                            $(obj.helpers.suffix).css('opacity', '0.6');
                        }, 1);
                    } else {
                        setTimeout(function () {
                            $(obj.helpers.prefix).css('opacity', '1');
                            $(obj.helpers.suffix).css('opacity', '1');
                        }, 1);
                    }
                }, 1);
            }
            if (['enum', 'file'].indexOf(this.type) != -1) {
                var html = '';
                if (selected) {
                    for (var s = 0; s &lt; selected.length; s++) {
                        var it = selected[s];
                        var ren = '';
                        if (typeof options.renderItem == 'function') {
                            ren = options.renderItem(it, s, '&lt;div class="w2ui-list-remove" title="' + w2utils.lang('Remove') + '" index="' + s + '">&amp;#160;&amp;#160;&lt;/div>');
                        } else {
                            ren = '&lt;div class="w2ui-list-remove" title="' + w2utils.lang('Remove') + '" index="' + s + '">&amp;#160;&amp;#160;&lt;/div>' +
                                (obj.type == 'enum' ? it.text : it.name + '&lt;span class="file-size"> - ' + w2utils.formatSize(it.size) + '&lt;/span>');
                        }
                        html += '&lt;li index="' + s + '" style="max-width: ' + parseInt(options.maxWidth) + 'px; ' + (it.style ? it.style : '') + '">' +
                            ren + '&lt;/li>';
                    }
                }
                var div = obj.helpers.multi;
                var ul = div.find('ul');
                div.attr('style', div.attr('style') + ';' + options.style);
                $(obj.el).css('z-index', '-1');
                if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) {
                    setTimeout(function () {
                        div[0].scrollTop = 0; // scroll to the top
                        div.addClass('w2ui-readonly')
                            .find('li').css('opacity', '0.9')
                            .parent().find('li.nomouse').hide()
                            .find('input').prop('readonly', true)
                            .parents('ul')
                            .find('.w2ui-list-remove').hide();
                    }, 1);
                } else {
                    setTimeout(function () {
                        div.removeClass('w2ui-readonly')
                            .find('li').css('opacity', '1')
                            .parent().find('li.nomouse').show()
                            .find('input').prop('readonly', false)
                            .parents('ul')
                            .find('.w2ui-list-remove').show();
                    }, 1);
                }

                // clean
                div.find('.w2ui-enum-placeholder').remove();
                ul.find('li').not('li.nomouse').remove();
                // add new list
                if (html !== '') {
                    ul.prepend(html);
                } else if ($(obj.el).attr('placeholder') != null &amp;&amp; div.find('input').val() === '') {
                    var style =
                        'padding-top: ' + $(this.el).css('padding-top') + ';' +
                        'padding-left: ' + $(this.el).css('padding-left') + '; ' +
                        'box-sizing: ' + $(this.el).css('box-sizing') + '; ' +
                        'line-height: ' + $(this.el).css('line-height') + '; ' +
                        'font-size: ' + $(this.el).css('font-size') + '; ' +
                        'font-family: ' + $(this.el).css('font-family') + '; ';
                    div.prepend('&lt;div class="w2ui-enum-placeholder" style="' + style + '">' + $(obj.el).attr('placeholder') + '&lt;/div>');
                }
                // ITEMS events
                div.off('scroll.w2field').on('scroll.w2field', function (event) {
                    var edata = obj.trigger({phase: 'before', type: 'scroll', target: obj.el, originalEvent: event});
                    if (edata.isCancelled === true) return;
                    // event after
                    obj.trigger($.extend(edata, {phase: 'after'}));
                })
                    .find('li')
                    .data('mouse', 'out')
                    .on('click', function (event) {
                        var target = (event.target.tagName.toUpperCase() == 'LI' ? event.target : $(event.target).parents('LI'));
                        var item = selected[$(target).attr('index')];
                        if ($(target).hasClass('nomouse')) return;
                        event.stopPropagation();
                        // default behavior
                        if ($(event.target).hasClass('w2ui-list-remove')) {
                            if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                            // trigger event
                            var edata = obj.trigger({
                                phase: 'before',
                                type: 'remove',
                                target: obj.el,
                                originalEvent: event.originalEvent,
                                item: item
                            });
                            if (edata.isCancelled === true) return;
                            // default behavior
                            $().w2overlay();
                            selected.splice($(event.target).attr('index'), 1);
                            $(obj.el).trigger('change');
                            $(event.target).parent().fadeOut('fast');
                            setTimeout(function () {
                                obj.refresh();
                                // event after
                                obj.trigger($.extend(edata, {phase: 'after'}));
                            }, 300);
                        } else {
                            // trigger event
                            var edata = obj.trigger({
                                phase: 'before',
                                type: 'click',
                                target: obj.el,
                                originalEvent: event.originalEvent,
                                item: item
                            });
                            if (edata.isCancelled === true) return;
                            // if file - show image preview
                            if (obj.type == 'file') {
                                var preview = '';
                                if ((/image/i).test(item.type)) { // image
                                    preview = '&lt;div style="padding: 3px;">' +
                                        '    &lt;img src="' + (item.content ? 'data:' + item.type + ';base64,' + item.content : '') + '" style="max-width: 300px;" ' +
                                        '        onload="var w = jQuery(this).width(); var h = jQuery(this).height(); ' +
                                        '            if (w &lt; 300 &amp; h &lt; 300) return; ' +
                                        '            if (w >= h &amp;&amp; w > 300) jQuery(this).width(300);' +
                                        '            if (w &lt; h &amp;&amp; h > 300) jQuery(this).height(300);"' +
                                        '        onerror="this.style.display = \'none\'"' +
                                        '    >' +
                                        '&lt;/div>';
                                }
                                var td1 = 'style="padding: 3px; text-align: right; color: #777;"';
                                var td2 = 'style="padding: 3px"';
                                preview += '&lt;div style="padding: 8px;">' +
                                    '    &lt;table cellpadding="2">&lt;tbody>' +
                                    '    &lt;tr>&lt;td ' + td1 + '>' + w2utils.lang('Name') + ':&lt;/td>&lt;td ' + td2 + '>' + item.name + '&lt;/td>&lt;/tr>' +
                                    '    &lt;tr>&lt;td ' + td1 + '>' + w2utils.lang('Size') + ':&lt;/td>&lt;td ' + td2 + '>' + w2utils.formatSize(item.size) + '&lt;/td>&lt;/tr>' +
                                    '    &lt;tr>&lt;td ' + td1 + '>' + w2utils.lang('Type') + ':&lt;/td>&lt;td ' + td2 + '>' +
                                    '        &lt;span style="width: 200px; display: block-inline; overflow: hidden; text-overflow: ellipsis; white-space: nowrap="nowrap";">' + item.type + '&lt;/span>' +
                                    '    &lt;/td>&lt;/tr>' +
                                    '    &lt;tr>&lt;td ' + td1 + '>' + w2utils.lang('Modified') + ':&lt;/td>&lt;td ' + td2 + '>' + w2utils.date(item.modified) + '&lt;/td>&lt;/tr>' +
                                    '    &lt;/tbody>&lt;/table>' +
                                    '&lt;/div>';
                                $('#w2ui-overlay').remove();
                                $(target).w2overlay(preview);
                            }                            // event after
                            obj.trigger($.extend(edata, {phase: 'after'}));
                        }
                    })
                    .on('mouseover', function (event) {
                        var target = (event.target.tagName.toUpperCase() == 'LI' ? event.target : $(event.target).parents('LI'));
                        if ($(target).hasClass('nomouse')) return;
                        if ($(target).data('mouse') == 'out') {
                            var item = selected[$(event.target).attr('index')];
                            // trigger event
                            var edata = obj.trigger({
                                phase: 'before',
                                type: 'mouseOver',
                                target: obj.el,
                                originalEvent: event.originalEvent,
                                item: item
                            });
                            if (edata.isCancelled === true) return;
                            // event after
                            obj.trigger($.extend(edata, {phase: 'after'}));
                        }
                        $(target).data('mouse', 'over');
                    })
                    .on('mouseout', function (event) {
                        var target = (event.target.tagName.toUpperCase() == 'LI' ? event.target : $(event.target).parents('LI'));
                        if ($(target).hasClass('nomouse')) return;
                        $(target).data('mouse', 'leaving');
                        setTimeout(function () {
                            if ($(target).data('mouse') == 'leaving') {
                                $(target).data('mouse', 'out');
                                var item = selected[$(event.target).attr('index')];
                                // trigger event
                                var edata = obj.trigger({
                                    phase: 'before',
                                    type: 'mouseOut',
                                    target: obj.el,
                                    originalEvent: event.originalEvent,
                                    item: item
                                });
                                if (edata.isCancelled === true) return;
                                // event after
                                obj.trigger($.extend(edata, {phase: 'after'}));
                            }
                        }, 0);
                    });
                // adjust height
                $(this.el).height('auto');
                var cntHeight = $(div).find('> div.w2ui-multi-items').height() + w2utils.getSize(div, '+height') * 2;
                if (cntHeight &lt; 26) cntHeight = 26;
                if (cntHeight > options.maxHeight) cntHeight = options.maxHeight;
                if (div.length > 0) div[0].scrollTop = 1000;
                var inpHeight = w2utils.getSize($(this.el), 'height') - 2;
                if (inpHeight > cntHeight) cntHeight = inpHeight;
                $(div).css({
                    'height': cntHeight + 'px',
                    overflow: (cntHeight == options.maxHeight ? 'auto' : 'hidden')
                });
                if (cntHeight &lt; options.maxHeight) $(div).prop('scrollTop', 0);
                $(this.el).css({'height': (cntHeight + 2) + 'px'});
                // update size
                if (obj.type == 'enum') {
                    var tmp = obj.helpers.multi.find('input');
                    tmp.width(((tmp.val().length + 2) * 8) + 'px');
                }
            }
            return (new Date()).getTime() - time;
        },

        reset: function () {
            var type = this.type;
            this.clear();
            this.type = type;
            this.init();
        },

        // resizing width of list, enum, file controls
        resize: function () {
            var obj = this;
            var new_width = $(obj.el).width();
            var new_height = $(obj.el).height();
            if (obj.tmp.current_width == new_width &amp;&amp; new_height > 0) return;

            var focus = this.helpers.focus;
            var multi = this.helpers.multi;
            var suffix = this.helpers.suffix;
            var prefix = this.helpers.prefix;

            // resize helpers
            if (focus) {
                focus.width($(obj.el).width());
            }
            if (multi) {
                var width = (w2utils.getSize(obj.el, 'width')
                - parseInt($(obj.el).css('margin-left'), 10)
                - parseInt($(obj.el).css('margin-right'), 10));
                $(multi).width(width);
            }
            if (suffix) {
                obj.options.suffix = '&lt;div class="arrow-down" style="margin-top: ' + ((parseInt($(obj.el).height()) - 6) / 2) + 'px;">&lt;/div>';
                obj.addSuffix();
            }
            if (prefix) {
                obj.addPrefix();
            }
            // remember width
            obj.tmp.current_width = new_width;
        },

        clean: function (val) {
            //issue #499
            if (typeof val == 'number') {
                return val;
            }
            var options = this.options;
            val = String(val).trim();
            // clean
            if (['int', 'float', 'money', 'currency', 'percent'].indexOf(this.type) != -1) {
                if (typeof val == 'string') {
                    if (options.autoFormat &amp;&amp; ['money', 'currency'].indexOf(this.type) != -1) val = String(val).replace(options.moneyRE, '');
                    if (options.autoFormat &amp;&amp; this.type == 'percent') val = String(val).replace(options.percentRE, '');
                    if (options.autoFormat &amp;&amp; ['int', 'float'].indexOf(this.type) != -1) val = String(val).replace(options.numberRE, '');
                    val = val.replace(/\s+/g, '').replace(w2utils.settings.groupSymbol, '').replace(w2utils.settings.decimalSymbol, '.');
                }
                if (parseFloat(val) == val) {
                    if (options.min != null &amp;&amp; val &lt; options.min) {
                        val = options.min;
                        $(this.el).val(options.min);
                    }
                    if (options.max != null &amp;&amp; val > options.max) {
                        val = options.max;
                        $(this.el).val(options.max);
                    }
                }
                if (val !== '' &amp;&amp; w2utils.isFloat(val)) val = Number(val); else val = '';
            }
            return val;
        },

        format: function (val) {
            var options = this.options;
            // autoformat numbers or money
            if (options.autoFormat &amp;&amp; val !== '') {
                switch (this.type) {
                    case 'money':
                    case 'currency':
                        val = w2utils.formatNumber(val, options.currencyPrecision, options.groupSymbol);
                        if (val !== '') val = options.currencyPrefix + val + options.currencySuffix;
                        break;
                    case 'percent':
                        val = w2utils.formatNumber(val, options.precision, options.groupSymbol);
                        if (val !== '') val += '%';
                        break;
                    case 'float':
                        val = w2utils.formatNumber(val, options.precision, options.groupSymbol);
                        break;
                    case 'int':
                        val = w2utils.formatNumber(val, 0, options.groupSymbol);
                        break;
                }
            }
            return val;
        },

        change: function (event) {
            var obj = this;
            var options = obj.options;
            // numeric
            if (['int', 'float', 'money', 'currency', 'percent'].indexOf(this.type) != -1) {
                // check max/min
                var val = $(this.el).val();
                var new_val = this.format(this.clean($(this.el).val()));
                // if was modified
                if (val !== '' &amp;&amp; val != new_val) {
                    $(this.el).val(new_val).change();
                    // cancel event
                    event.stopPropagation();
                    event.preventDefault();
                    return false;
                }
            }
            // color
            if (this.type == 'color') {
                var color = '#' + $(this.el).val();
                if ($(this.el).val().length != 6 &amp;&amp; $(this.el).val().length != 3) color = '';
                $(this.el).next().find('div').css('background-color', color);
                if ($(obj.el).is(':focus')) this.updateOverlay();
            }
            // list, enum
            if (['list', 'enum', 'file'].indexOf(this.type) != -1) {
                obj.refresh();
                // need time out to show icon indent properly
                setTimeout(function () {
                    obj.refresh();
                }, 5);
            }
            // date, time
            if (['date', 'time', 'datetime'].indexOf(this.type) != -1) {
                // convert linux timestamps
                var tmp = parseInt(obj.el.value);
                if (w2utils.isInt(obj.el.value) &amp;&amp; tmp > 3000) {
                    if (this.type == 'time') $(obj.el).val(w2utils.formatTime(new Date(tmp), options.format)).change();
                    if (this.type == 'date') $(obj.el).val(w2utils.formatDate(new Date(tmp), options.format)).change();
                    if (this.type == 'datetime') $(obj.el).val(w2utils.formatDateTime(new Date(tmp), options.format)).change();
                }
            }
        },

        click: function (event) {
            event.stopPropagation();
            // lists
            if (['list', 'combo', 'enum'].indexOf(this.type) != -1) {
                if (!$(this.el).is(':focus')) this.focus(event);
            }
            // other fields with drops
            if (['date', 'time', 'color', 'datetime'].indexOf(this.type) != -1) {
                this.updateOverlay();
            }
        },

        focus: function (event) {
            var obj = this;
            var options = this.options;
            // color, date, time
            if (['color', 'date', 'time', 'datetime'].indexOf(obj.type) !== -1) {
                if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay')[0].hide();
                setTimeout(function () {
                    obj.updateOverlay();
                }, 150);
            }
            // menu
            if (['list', 'combo', 'enum'].indexOf(obj.type) != -1) {
                if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay')[0].hide();
                obj.resize();
                setTimeout(function () {
                    if (obj.type == 'list' &amp;&amp; $(obj.el).is(':focus')) {
                        $(obj.helpers.focus).find('input').focus();
                        return;
                    }
                    obj.search();
                    setTimeout(function () {
                        obj.updateOverlay();
                    }, 1);
                }, 1);
            }
            // file
            if (obj.type == 'file') {
                $(obj.helpers.multi).css({'outline': 'auto 5px #7DB4F3', 'outline-offset': '-2px'});
            }
        },

        blur: function (event) {
            var obj = this;
            var options = obj.options;
            var val = $(obj.el).val().trim();
            // hide overlay
            if (['color', 'date', 'time', 'list', 'combo', 'enum', 'datetime'].indexOf(obj.type) != -1) {
                if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay')[0].hide();
            }
            if (['int', 'float', 'money', 'currency', 'percent'].indexOf(obj.type) != -1) {
                if (val !== '' &amp;&amp; !obj.checkType(val)) {
                    $(obj.el).val('').change();
                    if (options.silent === false) {
                        $(obj.el).w2tag('Not a valid number');
                        setTimeout(function () {
                            $(obj.el).w2tag('');
                        }, 3000);
                    }
                }
            }
            // date or time
            if (['date', 'time', 'datetime'].indexOf(obj.type) != -1) {
                // check if in range
                if (val !== '' &amp;&amp; !obj.inRange(obj.el.value)) {
                    $(obj.el).val('').removeData('selected').change();
                    if (options.silent === false) {
                        $(obj.el).w2tag('Not in range');
                        setTimeout(function () {
                            $(obj.el).w2tag('');
                        }, 3000);
                    }
                } else {
                    if (obj.type == 'date' &amp;&amp; val !== '' &amp;&amp; !w2utils.isDate(obj.el.value, options.format)) {
                        $(obj.el).val('').removeData('selected').change();
                        if (options.silent === false) {
                            $(obj.el).w2tag('Not a valid date');
                            setTimeout(function () {
                                $(obj.el).w2tag('');
                            }, 3000);
                        }
                    }
                    else if (obj.type == 'time' &amp;&amp; val !== '' &amp;&amp; !w2utils.isTime(obj.el.value)) {
                        $(obj.el).val('').removeData('selected').change();
                        if (options.silent === false) {
                            $(obj.el).w2tag('Not a valid time');
                            setTimeout(function () {
                                $(obj.el).w2tag('');
                            }, 3000);
                        }
                    }
                    else if (obj.type == 'datetime' &amp;&amp; val !== '' &amp;&amp; !w2utils.isDateTime(obj.el.value, options.format)) {
                        $(obj.el).val('').removeData('selected').change();
                        if (options.silent === false) {
                            $(obj.el).w2tag('Not a valid date');
                            setTimeout(function () {
                                $(obj.el).w2tag('');
                            }, 3000);
                        }
                    }
                }
            }
            // clear search input
            if (obj.type == 'enum') {
                $(obj.helpers.multi).find('input').val('').width(20);
            }
            // file
            if (obj.type == 'file') {
                $(obj.helpers.multi).css({'outline': 'none'});
            }
        },

        keyPress: function (event) {
            var obj = this;
            var options = obj.options;
            // ignore wrong pressed key
            if (['int', 'float', 'money', 'currency', 'percent', 'hex', 'bin', 'color', 'alphanumeric'].indexOf(obj.type) != -1) {
                // keyCode &amp; charCode differ in FireFox
                if (event.metaKey || event.ctrlKey || event.altKey || (event.charCode != event.keyCode &amp;&amp; event.keyCode > 0)) return;
                var ch = String.fromCharCode(event.charCode);
                if (!obj.checkType(ch, true) &amp;&amp; event.keyCode != 13) {
                    event.preventDefault();
                    if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;
                    return false;
                }
            }
            // update date popup
            if (['date', 'time', 'datetime'].indexOf(obj.type) != -1) {
                if (event.keyCode !== 9) setTimeout(function () {
                    obj.updateOverlay();
                }, 1);
            }
        },

        keyDown: function (event, extra) {
            var obj = this;
            var options = obj.options;
            var key = event.keyCode || (extra &amp;&amp; extra.keyCode);
            // numeric
            if (['int', 'float', 'money', 'currency', 'percent'].indexOf(obj.type) != -1) {
                if (!options.keyboard || $(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                var cancel = false;
                var val = parseFloat($(obj.el).val().replace(options.moneyRE, '')) || 0;
                var inc = options.step;
                if (event.ctrlKey || event.metaKey) inc = 10;
                switch (key) {
                    case 38: // up
                        if (event.shiftKey) break; // no action if shift key is pressed
                        $(obj.el).val((val + inc &lt;= options.max || options.max == null ? Number((val + inc).toFixed(12)) : options.max)).change();
                        cancel = true;
                        break;
                    case 40: // down
                        if (event.shiftKey) break; // no action if shift key is pressed
                        $(obj.el).val((val - inc >= options.min || options.min == null ? Number((val - inc).toFixed(12)) : options.min)).change();
                        cancel = true;
                        break;
                }
                if (cancel) {
                    event.preventDefault();
                    setTimeout(function () {
                        // set cursor to the end
                        obj.el.setSelectionRange(obj.el.value.length, obj.el.value.length);
                    }, 0);
                }
            }
            // date
            if (obj.type == 'date') {
                if (!options.keyboard || $(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                var cancel = false;
                var daymil = 24 * 60 * 60 * 1000;
                var inc = 1;
                if (event.ctrlKey || event.metaKey) inc = 10;
                var dt = w2utils.isDate($(obj.el).val(), options.format, true);
                if (!dt) {
                    dt = new Date();
                    daymil = 0;
                }
                switch (key) {
                    case 38: // up
                        if (event.shiftKey) break; // no action if shift key is pressed
                        var newDT = w2utils.formatDate(dt.getTime() + daymil, options.format);
                        if (inc == 10) newDT = w2utils.formatDate(new Date(dt.getFullYear(), dt.getMonth() + 1, dt.getDate()), options.format);
                        $(obj.el).val(newDT).change();
                        cancel = true;
                        break;
                    case 40: // down
                        if (event.shiftKey) break; // no action if shift key is pressed
                        var newDT = w2utils.formatDate(dt.getTime() - daymil, options.format);
                        if (inc == 10) newDT = w2utils.formatDate(new Date(dt.getFullYear(), dt.getMonth() - 1, dt.getDate()), options.format);
                        $(obj.el).val(newDT).change();
                        cancel = true;
                        break;
                }
                if (cancel) {
                    event.preventDefault();
                    setTimeout(function () {
                        // set cursor to the end
                        obj.el.setSelectionRange(obj.el.value.length, obj.el.value.length);
                        obj.updateOverlay();
                    }, 0);
                }
            }
            // time
            if (obj.type == 'time') {
                if (!options.keyboard || $(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                var cancel = false;
                var inc = (event.ctrlKey || event.metaKey ? 60 : 1);
                var val = $(obj.el).val();
                var time = obj.toMin(val) || obj.toMin((new Date()).getHours() + ':' + ((new Date()).getMinutes() - 1));
                switch (key) {
                    case 38: // up
                        if (event.shiftKey) break; // no action if shift key is pressed
                        time += inc;
                        cancel = true;
                        break;
                    case 40: // down
                        if (event.shiftKey) break; // no action if shift key is pressed
                        time -= inc;
                        cancel = true;
                        break;
                }
                if (cancel) {
                    $(obj.el).val(obj.fromMin(time)).change();
                    event.preventDefault();
                    setTimeout(function () {
                        // set cursor to the end
                        obj.el.setSelectionRange(obj.el.value.length, obj.el.value.length);
                    }, 0);
                }
            }
            // datetime
            if (obj.type == 'datetime') {
                if (!options.keyboard || $(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                var cancel = false;
                var daymil = 24 * 60 * 60 * 1000;
                var inc = 1;
                if (event.ctrlKey || event.metaKey) inc = 10;
                var str = $(obj.el).val();
                var dt = w2utils.isDateTime(str, this.options.format, true);
                if (!dt) {
                    dt = new Date();
                    daymil = 0;
                }
                switch (key) {
                    case 38: // up
                        if (event.shiftKey) break; // no action if shift key is pressed
                        var newDT = w2utils.formatDateTime(dt.getTime() + daymil, options.format);
                        if (inc == 10) newDT = w2utils.formatDateTime(new Date(dt.getFullYear(), dt.getMonth() + 1, dt.getDate()), options.format);
                        $(obj.el).val(newDT).change();
                        cancel = true;
                        break;
                    case 40: // down
                        if (event.shiftKey) break; // no action if shift key is pressed
                        var newDT = w2utils.formatDateTime(dt.getTime() - daymil, options.format);
                        if (inc == 10) newDT = w2utils.formatDateTime(new Date(dt.getFullYear(), dt.getMonth() - 1, dt.getDate()), options.format);
                        $(obj.el).val(newDT).change();
                        cancel = true;
                        break;
                }
                if (cancel) {
                    event.preventDefault();
                    setTimeout(function () {
                        // set cursor to the end
                        obj.el.setSelectionRange(obj.el.value.length, obj.el.value.length);
                        obj.updateOverlay();
                    }, 0);
                }
            }
            // color
            if (obj.type == 'color') {
                if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                // paste
                if (event.keyCode == 86 &amp;&amp; (event.ctrlKey || event.metaKey)) {
                    $(obj.el).prop('maxlength', 7);
                    setTimeout(function () {
                        var val = $(obj).val();
                        if (val.substr(0, 1) == '#') val = val.substr(1);
                        if (!w2utils.isHex(val)) val = '';
                        $(obj).val(val).prop('maxlength', 6).change();
                    }, 20);
                }
                if ((event.ctrlKey || event.metaKey) &amp;&amp; !event.shiftKey) {
                    var dir = null;
                    var newColor = null;
                    switch (key) {
                        case 38: // up
                            dir = 'up';
                            break;
                        case 40: // down
                            dir = 'down';
                            break;
                        case 39: // right
                            dir = 'right';
                            break;
                        case 37: // left
                            dir = 'left';
                            break;
                    }
                    if (obj.el.nav &amp;&amp; dir != null) {
                        newColor = obj.el.nav(dir);
                        $(obj.el).val(newColor).change();
                        event.preventDefault();
                    }
                }
            }
            // list/select/combo
            if (['list', 'combo', 'enum'].indexOf(obj.type) != -1) {
                if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                var selected = $(obj.el).data('selected');
                var focus = $(obj.el);
                var indexOnly = false;
                if (['list', 'enum'].indexOf(obj.type) != -1) {
                    if (obj.type == 'list') {
                        focus = $(obj.helpers.focus).find('input');
                    }
                    if (obj.type == 'enum') {
                        focus = $(obj.helpers.multi).find('input');
                    }
                    // not arrows - refresh
                    if ([37, 38, 39, 40].indexOf(key) == -1) {
                        setTimeout(function () {
                            obj.refresh();
                        }, 1);
                    }
                    // paste
                    if (event.keyCode == 86 &amp;&amp; (event.ctrlKey || event.metaKey)) {
                        setTimeout(function () {
                            obj.refresh();
                            obj.search();
                            obj.request();
                        }, 50);
                    }
                }
                // apply arrows
                switch (key) {
                    case 27: // escape
                        if (obj.type == 'list') {
                            if (focus.val() !== '') focus.val('');
                            event.stopPropagation(); // escape in field should not close popup
                        }
                        break;
                    case 37: // left
                    case 39: // right
                        // indexOnly = true;
                        break;
                    case 13: // enter
                        if ($('#w2ui-overlay').length === 0) break; // no action if overlay not open
                        var item = options.items[options.index];
                        if (obj.type == 'enum') {
                            if (item != null) {
                                // trigger event
                                var edata = obj.trigger({
                                    phase: 'before',
                                    type: 'add',
                                    target: obj.el,
                                    originalEvent: event.originalEvent,
                                    item: item
                                });
                                if (edata.isCancelled === true) return;
                                item = edata.item; // need to reassign because it could be recreated by user
                                // default behavior
                                if (selected.length >= options.max &amp;&amp; options.max > 0) selected.pop();
                                delete item.hidden;
                                delete obj.tmp.force_open;
                                selected.push(item);
                                $(obj.el).change();
                                focus.val('').width(20);
                                obj.refresh();
                                // event after
                                obj.trigger($.extend(edata, {phase: 'after'}));
                            } else {
                                // trigger event
                                item = {id: focus.val(), text: focus.val()};
                                var edata = obj.trigger({
                                    phase: 'before',
                                    type: 'new',
                                    target: obj.el,
                                    originalEvent: event.originalEvent,
                                    item: item
                                });
                                if (edata.isCancelled === true) return;
                                item = edata.item; // need to reassign because it could be recreated by user
                                // default behavior
                                if (typeof obj.onNew == 'function') {
                                    if (selected.length >= options.max &amp;&amp; options.max > 0) selected.pop();
                                    delete obj.tmp.force_open;
                                    selected.push(item);
                                    $(obj.el).change();
                                    focus.val('').width(20);
                                    obj.refresh();
                                }
                                // event after
                                obj.trigger($.extend(edata, {phase: 'after'}));
                            }
                        } else {
                            if (item) $(obj.el).data('selected', item).val(item.text).change();
                            if ($(obj.el).val() === '' &amp;&amp; $(obj.el).data('selected')) $(obj.el).removeData('selected').val('').change();
                            if (obj.type == 'list') {
                                focus.val('');
                                obj.refresh();
                            }
                            // hide overlay
                            obj.tmp.force_hide = true;
                        }
                        break;
                    case 8:  // backspace
                    case 46: // delete
                        if (obj.type == 'enum' &amp;&amp; key == 8) {
                            if (focus.val() === '' &amp;&amp; selected.length > 0) {
                                var item = selected[selected.length - 1];
                                // trigger event
                                var edata = obj.trigger({
                                    phase: 'before',
                                    type: 'remove',
                                    target: obj.el,
                                    originalEvent: event.originalEvent,
                                    item: item
                                });
                                if (edata.isCancelled === true) return;
                                // default behavior
                                selected.pop();
                                $(obj.el).trigger('change');
                                obj.refresh();
                                // event after
                                obj.trigger($.extend(edata, {phase: 'after'}));
                            }
                        }
                        if (obj.type == 'list' &amp;&amp; focus.val() === '') {
                            $(obj.el).data('selected', {}).change();
                            obj.refresh();
                        }
                        break;
                    case 38: // up
                        options.index = w2utils.isInt(options.index) ? parseInt(options.index) : 0;
                        options.index--;
                        while (options.index > 0 &amp;&amp; options.items[options.index].hidden) options.index--;
                        if (options.index === 0 &amp;&amp; options.items[options.index].hidden) {
                            while (options.items[options.index] &amp;&amp; options.items[options.index].hidden) options.index++;
                        }
                        indexOnly = true;
                        break;
                    case 40: // down
                        options.index = w2utils.isInt(options.index) ? parseInt(options.index) : -1;
                        options.index++;
                        while (options.index &lt; options.items.length - 1 &amp;&amp; options.items[options.index].hidden) options.index++;
                        if (options.index == options.items.length - 1 &amp;&amp; options.items[options.index].hidden) {
                            while (options.items[options.index] &amp;&amp; options.items[options.index].hidden) options.index--;
                        }
                        // show overlay if not shown
                        if (focus.val() === '' &amp;&amp; $('#w2ui-overlay').length === 0) {
                            obj.tmp.force_open = true;
                        } else {
                            indexOnly = true;
                        }
                        break;
                }
                if (indexOnly) {
                    if (options.index &lt; 0) options.index = 0;
                    if (options.index >= options.items.length) options.index = options.items.length - 1;
                    obj.updateOverlay(indexOnly);
                    // cancel event
                    event.preventDefault();
                    setTimeout(function () {
                        // set cursor to the end
                        if (obj.type == 'enum') {
                            var tmp = focus.get(0);
                            tmp.setSelectionRange(tmp.value.length, tmp.value.length);
                        } else if (obj.type == 'list') {
                            var tmp = focus.get(0);
                            tmp.setSelectionRange(tmp.value.length, tmp.value.length);
                        } else {
                            obj.el.setSelectionRange(obj.el.value.length, obj.el.value.length);
                        }
                    }, 0);
                    return;
                }
                // expand input
                if (obj.type == 'enum') {
                    focus.width(((focus.val().length + 2) * 8) + 'px');
                }
            }
        },

        keyUp: function (event) {
            var obj = this;
            if (this.type == 'color') {
                if (event.keyCode == 86 &amp;&amp; (event.ctrlKey || event.metaKey)) {
                    $(this).prop('maxlength', 6);
                }
            }
            if (['list', 'combo', 'enum'].indexOf(this.type) != -1) {
                if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                // need to be here for ipad compa
                if ([16, 17, 18, 20, 37, 39, 91].indexOf(event.keyCode) == -1) { // no refreah on crtl, shift, left/right arrows, etc
                    var input = $(this.helpers.focus).find('input');
                    if (input.length === 0) input = $(this.el); // for combo list
                    // trigger event
                    var edata = this.trigger({
                        phase: 'before',
                        type: 'search',
                        originalEvent: event,
                        target: input,
                        search: input.val()
                    });
                    if (edata.isCancelled === true) return;
                    // regular
                    if (!this.tmp.force_hide) this.request();
                    if (input.val().length == 1) this.refresh();
                    if ($('#w2ui-overlay').length === 0 || [38, 40].indexOf(event.keyCode) == -1) { // no search on arrows
                        this.search();
                    }
                    // event after
                    this.trigger($.extend(edata, {phase: 'after'}));
                }
            }
        },

        clearCache: function () {
            var options = this.options;
            options.items = [];
            this.tmp.xhr_loading = false;
            this.tmp.xhr_search = '';
            this.tmp.xhr_total = -1;
        },

        request: function (interval) {
            var obj = this;
            var options = this.options;
            var search = $(obj.el).val() || '';
            // if no url - do nothing
            if (!options.url) return;
            // --
            if (obj.type == 'enum') {
                var tmp = $(obj.helpers.multi).find('input');
                if (tmp.length === 0) search = ''; else search = tmp.val();
            }
            if (obj.type == 'list') {
                var tmp = $(obj.helpers.focus).find('input');
                if (tmp.length === 0) search = ''; else search = tmp.val();
            }
            if (options.minLength !== 0 &amp;&amp; search.length &lt; options.minLength) {
                options.items = []; // need to empty the list
                this.updateOverlay();
                return;
            }
            if (interval == null) interval = options.interval;
            if (obj.tmp.xhr_search == null) obj.tmp.xhr_search = '';
            if (obj.tmp.xhr_total == null) obj.tmp.xhr_total = -1;
            // check if need to search
            if (options.url &amp;&amp; $(obj.el).prop('readonly') !== true &amp;&amp; $(obj.el).prop('disabled') !== true &amp;&amp; (
                    (options.items.length === 0 &amp;&amp; obj.tmp.xhr_total !== 0) ||
                    (obj.tmp.xhr_total == options.cacheMax &amp;&amp; search.length > obj.tmp.xhr_search.length) ||
                    (search.length >= obj.tmp.xhr_search.length &amp;&amp; search.substr(0, obj.tmp.xhr_search.length) != obj.tmp.xhr_search) ||
                    (search.length &lt; obj.tmp.xhr_search.length)
                )) {
                // empty list
                if (obj.tmp.xhr) obj.tmp.xhr.abort();
                obj.tmp.xhr_loading = true;
                obj.search();
                // timeout
                clearTimeout(obj.tmp.timeout);
                obj.tmp.timeout = setTimeout(function () {
                    // trigger event
                    var url = options.url;
                    var postData = {
                        search: search,
                        max: options.cacheMax
                    };
                    $.extend(postData, options.postData);
                    var edata = obj.trigger({
                        phase: 'before',
                        type: 'request',
                        search: search,
                        target: obj.el,
                        url: url,
                        postData: postData
                    });
                    if (edata.isCancelled === true) return;
                    url = edata.url;
                    postData = edata.postData;
                    var ajaxOptions = {
                        type: 'GET',
                        url: url,
                        data: postData,
                        dataType: 'JSON' // expected from server
                    };
                    if (options.method) ajaxOptions.type = options.method;
                    if (w2utils.settings.dataType == 'JSON') {
                        ajaxOptions.type = 'POST';
                        ajaxOptions.data = JSON.stringify(ajaxOptions.data);
                        ajaxOptions.contentType = 'application/json';
                    }
                    if (w2utils.settings.dataType == 'HTTPJSON') {
                        ajaxOptions.data = {request: JSON.stringify(ajaxOptions.data)};
                    }
                    if (options.method != null) ajaxOptions.type = options.method;
                    obj.tmp.xhr = $.ajax(ajaxOptions)
                        .done(function (data, status, xhr) {
                            // trigger event
                            var edata2 = obj.trigger({
                                phase: 'before',
                                type: 'load',
                                target: obj.el,
                                search: postData.search,
                                data: data,
                                xhr: xhr
                            });
                            if (edata2.isCancelled === true) return;
                            // default behavior
                            data = edata2.data;
                            if (typeof data == 'string') data = JSON.parse(data);
                            if (data.records == null &amp;&amp; data.items != null) {
                                // needed for backward compatibility
                                data.records = data.items;
                                delete data.items;
                            }
                            if (data.status != 'success' || !Array.isArray(data.records)) {
                                console.log('ERROR: server did not return proper structure. It should return', {
                                    status: 'success',
                                    records: [{id: 1, text: 'item'}]
                                });
                                return;
                            }
                            // remove all extra items if more then needed for cache
                            if (data.records.length > options.cacheMax) data.records.splice(options.cacheMax, 100000);
                            // map id and text
                            if (options.recId == null &amp;&amp; options.recid != null) options.recId = options.recid; // since lower-case recid is used in grid
                            if (options.recId || options.recText) {
                                data.records.forEach(function (item) {
                                    if (typeof options.recId == 'string') item.id = item[options.recId];
                                    if (typeof options.recId == 'function') item.id = options.recId(item);
                                    if (typeof options.recText == 'string') item.text = item[options.recText];
                                    if (typeof options.recText == 'function') item.text = options.recText(item);
                                });
                            }
                            // remember stats
                            obj.tmp.xhr_loading = false;
                            obj.tmp.xhr_search = search;
                            obj.tmp.xhr_total = data.records.length;
                            options.items = obj.normMenu(data.records);
                            if (search === '' &amp;&amp; data.records.length === 0) obj.tmp.emptySet = true; else obj.tmp.emptySet = false;
                            obj.search();
                            // event after
                            obj.trigger($.extend(edata2, {phase: 'after'}));
                        })
                        .fail(function (xhr, status, error) {
                            // trigger event
                            var errorObj = {status: status, error: error, rawResponseText: xhr.responseText};
                            var edata2 = obj.trigger({
                                phase: 'before',
                                type: 'error',
                                target: obj.el,
                                search: search,
                                error: errorObj,
                                xhr: xhr
                            });
                            if (edata2.isCancelled === true) return;
                            // default behavior
                            if (status != 'abort') {
                                var data;
                                try {
                                    data = $.parseJSON(xhr.responseText);
                                } catch (e) {
                                }
                                console.log('ERROR: Server communication failed.',
                                    '\n   EXPECTED:', {status: 'success', records: [{id: 1, text: 'item'}]},
                                    '\n         OR:', {status: 'error', message: 'error message'},
                                    '\n   RECEIVED:', typeof data == 'object' ? data : xhr.responseText);
                            }
                            // reset stats
                            obj.clearCache();
                            obj.search();
                            // event after
                            obj.trigger($.extend(edata2, {phase: 'after'}));
                        });
                    // event after
                    obj.trigger($.extend(edata, {phase: 'after'}));
                }, interval);
            }
        },

        search: function () {
            var obj = this;
            var options = this.options;
            var search = $(obj.el).val();
            var target = obj.el;
            var ids = [];
            var selected = $(obj.el).data('selected');
            if (obj.type == 'enum') {
                target = $(obj.helpers.multi).find('input');
                search = target.val();
                for (var s in selected) {
                    if (selected[s]) ids.push(selected[s].id);
                }
            }
            else if (obj.type == 'list') {
                target = $(obj.helpers.focus).find('input');
                search = target.val();
                for (var s in selected) {
                    if (selected[s]) ids.push(selected[s].id);
                }
            }
            if (obj.tmp.xhr_loading !== true) {
                var shown = 0;
                for (var i = 0; i &lt; options.items.length; i++) {
                    var item = options.items[i];
                    if (options.compare != null) {
                        if (typeof options.compare == 'function') {
                            item.hidden = (options.compare.call(this, item, search) === false ? true : false);
                        }
                    } else {
                        var prefix = '';
                        var suffix = '';
                        if (['is', 'begins'].indexOf(options.match) != -1) prefix = '^';
                        if (['is', 'ends'].indexOf(options.match) != -1) suffix = '$';
                        try {
                            var re = new RegExp(prefix + search + suffix, 'i');
                            if (re.test(item.text) || item.text == '...') item.hidden = false; else item.hidden = true;
                        } catch (e) {
                        }
                    }
                    if (options.filter === false) item.hidden = false;
                    // do not show selected items
                    if (obj.type == 'enum' &amp;&amp; $.inArray(item.id, ids) != -1) item.hidden = true;
                    if (item.hidden !== true) {
                        shown++;
                        delete item.hidden;
                    }
                }
                // preselect first item
                options.index = -1;
                while (options.items[options.index] &amp;&amp; options.items[options.index].hidden) options.index++;
                if (shown &lt;= 0) options.index = -1;
                options.spinner = false;
                obj.updateOverlay();
                setTimeout(function () {
                    var html = $('#w2ui-overlay').html() || '';
                    if (options.markSearch &amp;&amp; html.indexOf('$.fn.w2menuHandler') != -1) { // do not highlight when no items
                        $('#w2ui-overlay').w2marker(search);
                    }
                }, 1);
            } else {
                options.items.splice(0, options.cacheMax);
                options.spinner = true;
                obj.updateOverlay();
            }
        },

        updateOverlay: function (indexOnly) {
            var obj = this;
            var options = this.options;
            // color
            if (this.type == 'color') {
                if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                $(this.el).w2color({color: $(this.el).val(), transparent: options.transparent}, function (color) {
                    if (color == null) return;
                    $(obj.el).val(color).change();
                });
            }
            // date
            if (this.type == 'date') {
                if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                if ($('#w2ui-overlay').length === 0) {
                    $(obj.el).w2overlay('&lt;div class="w2ui-reset w2ui-calendar" onclick="event.stopPropagation();">&lt;/div>', {
                        css: {"background-color": "#f5f5f5"}
                    });
                }
                var month, year;
                var dt = w2utils.isDate($(obj.el).val(), obj.options.format, true);
                if (dt) {
                    month = dt.getMonth() + 1;
                    year = dt.getFullYear();
                }
                (function refreshCalendar(month, year) {
                    $('#w2ui-overlay > div > div').html(obj.getMonthHTML(month, year, $(obj.el).val()));
                    $('#w2ui-overlay .w2ui-calendar-title')
                        .on('mousedown', function () {
                            if ($(this).next().hasClass('w2ui-calendar-jump')) {
                                $(this).next().remove();
                            } else {
                                var selYear, selMonth;
                                $(this).after('&lt;div class="w2ui-calendar-jump" style="">&lt;/div>');
                                $(this).next().hide().html(obj.getYearHTML()).fadeIn(200);
                                setTimeout(function () {
                                    $('#w2ui-overlay .w2ui-calendar-jump')
                                        .find('.w2ui-jump-month, .w2ui-jump-year')
                                        .on('click', function () {
                                            if ($(this).hasClass('w2ui-jump-month')) {
                                                $(this).parent().find('.w2ui-jump-month').removeClass('selected');
                                                $(this).addClass('selected');
                                                selMonth = $(this).attr('name');
                                            }
                                            if ($(this).hasClass('w2ui-jump-year')) {
                                                $(this).parent().find('.w2ui-jump-year').removeClass('selected');
                                                $(this).addClass('selected');
                                                selYear = $(this).attr('name');
                                            }
                                            if (selYear != null &amp;&amp; selMonth != null) {
                                                $('#w2ui-overlay .w2ui-calendar-jump').fadeOut(100);
                                                setTimeout(function () {
                                                    refreshCalendar(parseInt(selMonth) + 1, selYear);
                                                }, 100);
                                            }
                                        });
                                    $('#w2ui-overlay .w2ui-calendar-jump >:last-child').prop('scrollTop', 2000);
                                }, 1);
                            }
                        });
                    $('#w2ui-overlay .w2ui-date')
                        .on('mousedown', function () {
                            var day = $(this).attr('date');
                            $(obj.el).val(day).change();
                            $(this).css({'background-color': '#B6D5FB', 'border-color': '#aaa'});
                        })
                        .on('mouseup', function () {
                            setTimeout(function () {
                                if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay').removeData('keepOpen')[0].hide();
                            }, 10);
                        });
                    $('#w2ui-overlay .previous').on('mousedown', function () {
                        var tmp = obj.options.current.split('/');
                        tmp[0] = parseInt(tmp[0]) - 1;
                        refreshCalendar(tmp[0], tmp[1]);
                    });
                    $('#w2ui-overlay .next').on('mousedown', function () {
                        var tmp = obj.options.current.split('/');
                        tmp[0] = parseInt(tmp[0]) + 1;
                        refreshCalendar(tmp[0], tmp[1]);
                    });
                })(month, year);
            }
            // time
            if (this.type == 'time') {
                if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                if ($('#w2ui-overlay').length === 0) {
                    $(obj.el).w2overlay('&lt;div class="w2ui-reset w2ui-calendar-time" onclick="event.stopPropagation();">&lt;/div>', {
                        css: {"background-color": "#fff"}
                    });
                }
                var h24 = (this.options.format == 'h24');
                $('#w2ui-overlay > div').html(obj.getHourHTML());
                $('#w2ui-overlay .w2ui-time')
                    .on('mousedown', function (event) {
                        $(this).css({'background-color': '#B6D5FB', 'border-color': '#aaa'});
                        var hour = $(this).attr('hour');
                        $(obj.el).val((hour > 12 &amp;&amp; !h24 ? hour - 12 : hour) + ':00' + (!h24 ? (hour &lt; 12 ? ' am' : ' pm') : '')).change();
                    });
                if (this.options.noMinutes == null || this.options.noMinutes === false) {
                    $('#w2ui-overlay .w2ui-time')
                        .on('mouseup', function () {
                            var hour = $(this).attr('hour');
                            if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay')[0].hide();
                            $(obj.el).w2overlay('&lt;div class="w2ui-reset w2ui-calendar-time">&lt;/div>', {css: {"background-color": "#fff"}});
                            $('#w2ui-overlay > div').html(obj.getMinHTML(hour));
                            $('#w2ui-overlay .w2ui-time')
                                .on('mousedown', function () {
                                    $(this).css({'background-color': '#B6D5FB', 'border-color': '#aaa'});
                                    var min = $(this).attr('min');
                                    $(obj.el).val((hour > 12 &amp;&amp; !h24 ? hour - 12 : hour) + ':' + (min &lt; 10 ? 0 : '') + min + (!h24 ? (hour &lt; 12 ? ' am' : ' pm') : '')).change();
                                })
                                .on('mouseup', function () {
                                    setTimeout(function () {
                                        if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay').removeData('keepOpen')[0].hide();
                                    }, 10);
                                });
                        });
                } else {
                    $('#w2ui-overlay .w2ui-time')
                        .on('mouseup', function () {
                            setTimeout(function () {
                                if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay').removeData('keepOpen')[0].hide();
                            }, 10);
                        });
                }
            }
            // datetime
            if (this.type == 'datetime') {
                if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                // hide overlay if we are in the time selection
                if ($("#w2ui-overlay .w2ui-time").length > 0) $('#w2ui-overlay')[0].hide();
                if ($('#w2ui-overlay').length === 0) {
                    $(obj.el).w2overlay('&lt;div class="w2ui-reset w2ui-calendar" onclick="event.stopPropagation();">&lt;/div>', {
                        css: {"background-color": "#f5f5f5"}
                    });
                }
                var month, year;
                var dt = w2utils.isDateTime($(obj.el).val(), obj.options.format, true);
                if (dt) {
                    month = dt.getMonth() + 1;
                    year = dt.getFullYear();
                }
                var selDate = null;
                (function refreshCalendar(month, year) {
                    $('#w2ui-overlay > div > div').html(
                        obj.getMonthHTML(month, year, $(obj.el).val())
                        + (options.btn_now ? '&lt;div class="w2ui-calendar-now now">' + w2utils.lang('Current Date &amp; Time') + '&lt;/div>' : '')
                    );
                    $('#w2ui-overlay .w2ui-calendar-title')
                        .on('mousedown', function () {
                            if ($(this).next().hasClass('w2ui-calendar-jump')) {
                                $(this).next().remove();
                            } else {
                                var selYear, selMonth;
                                $(this).after('&lt;div class="w2ui-calendar-jump" style="">&lt;/div>');
                                $(this).next().hide().html(obj.getYearHTML()).fadeIn(200);
                                setTimeout(function () {
                                    $('#w2ui-overlay .w2ui-calendar-jump')
                                        .find('.w2ui-jump-month, .w2ui-jump-year')
                                        .on('click', function () {
                                            if ($(this).hasClass('w2ui-jump-month')) {
                                                $(this).parent().find('.w2ui-jump-month').removeClass('selected');
                                                $(this).addClass('selected');
                                                selMonth = $(this).attr('name');
                                            }
                                            if ($(this).hasClass('w2ui-jump-year')) {
                                                $(this).parent().find('.w2ui-jump-year').removeClass('selected');
                                                $(this).addClass('selected');
                                                selYear = $(this).attr('name');
                                            }
                                            if (selYear != null &amp;&amp; selMonth != null) {
                                                $('#w2ui-overlay .w2ui-calendar-jump').fadeOut(100);
                                                setTimeout(function () {
                                                    refreshCalendar(parseInt(selMonth) + 1, selYear);
                                                }, 100);
                                            }
                                        });
                                    $('#w2ui-overlay .w2ui-calendar-jump >:last-child').prop('scrollTop', 2000);
                                }, 1);
                            }
                        });
                    $('#w2ui-overlay .w2ui-date')
                        .on('mousedown', function () {
                            var day = $(this).attr('date');
                            $(obj.el).val(day).change();
                            $(this).css({'background-color': '#B6D5FB', 'border-color': '#aaa'});
                            selDate = new Date($(this).attr('data-date'));
                        })
                        .on('mouseup', function () {
                            // continue with time picker
                            var selHour, selMin;
                            if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay')[0].hide();
                            $(obj.el).w2overlay('&lt;div class="w2ui-reset w2ui-calendar-time">&lt;/div>', {css: {"background-color": "#fff"}});
                            var h24 = (obj.options.format == 'h24');
                            $('#w2ui-overlay > div').html(obj.getHourHTML());
                            $('#w2ui-overlay .w2ui-time')
                                .on('mousedown', function (event) {
                                    $(this).css({'background-color': '#B6D5FB', 'border-color': '#aaa'});
                                    selHour = $(this).attr('hour');
                                    selDate.setHours(selHour);
                                    var txt = w2utils.formatDateTime(selDate, obj.options.format);
                                    $(obj.el).val(txt).change();
                                    //$(obj.el).val((hour > 12 &amp;&amp; !h24 ? hour - 12 : hour) + ':00' + (!h24 ? (hour &lt; 12 ? ' am' : ' pm') : '')).change();
                                });
                            if (obj.options.noMinutes == null || obj.options.noMinutes === false) {
                                $('#w2ui-overlay .w2ui-time')
                                    .on('mouseup', function () {
                                        var hour = $(this).attr('hour');
                                        if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay')[0].hide();
                                        $(obj.el).w2overlay('&lt;div class="w2ui-reset w2ui-calendar-time">&lt;/div>', {css: {"background-color": "#fff"}});
                                        $('#w2ui-overlay > div').html(obj.getMinHTML(hour));
                                        $('#w2ui-overlay .w2ui-time')
                                            .on('mousedown', function () {
                                                $(this).css({'background-color': '#B6D5FB', 'border-color': '#aaa'});
                                                selMin = $(this).attr('min');
                                                selDate.setHours(selHour, selMin);
                                                var txt = w2utils.formatDateTime(selDate, obj.options.format);
                                                $(obj.el).val(txt).change();
                                                //$(obj.el).val((hour > 12 &amp;&amp; !h24 ? hour - 12 : hour) + ':' + (min &lt; 10 ? 0 : '') + min + (!h24 ? (hour &lt; 12 ? ' am' : ' pm') : '')).change();
                                            })
                                            .on('mouseup', function () {
                                                setTimeout(function () {
                                                    if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay').removeData('keepOpen')[0].hide();
                                                }, 10);
                                            });
                                    });
                            } else {
                                $('#w2ui-overlay .w2ui-time')
                                    .on('mouseup', function () {
                                        setTimeout(function () {
                                            if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay').removeData('keepOpen')[0].hide();
                                        }, 10);
                                    });
                            }
                        });
                    $('#w2ui-overlay .previous').on('mousedown', function () {
                        var tmp = obj.options.current.split('/');
                        tmp[0] = parseInt(tmp[0]) - 1;
                        refreshCalendar(tmp[0], tmp[1]);
                    });
                    $('#w2ui-overlay .next').on('mousedown', function () {
                        var tmp = obj.options.current.split('/');
                        tmp[0] = parseInt(tmp[0]) + 1;
                        refreshCalendar(tmp[0], tmp[1]);
                    });
                    // "now" button
                    $('#w2ui-overlay .now')
                        .on('mousedown', function () {
                            // this currently ignores blocked days or start / end dates!
                            var tmp = w2utils.formatDateTime(new Date(), obj.options.format);
                            $(obj.el).val(tmp).change();
                            return false;
                        })
                        .on('mouseup', function () {
                            setTimeout(function () {
                                if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay').removeData('keepOpen')[0].hide();
                            }, 10);
                        });
                })(month, year);
            }
            // list
            if (['list', 'combo', 'enum'].indexOf(this.type) != -1) {
                var el = this.el;
                var input = this.el;
                if (this.type == 'enum') {
                    el = $(this.helpers.multi);
                    input = $(el).find('input');
                }
                if (this.type == 'list') {
                    var sel = $(input).data('selected');
                    if ($.isPlainObject(sel) &amp;&amp; !$.isEmptyObject(sel) &amp;&amp; options.index == -1) {
                        options.items.forEach(function (item, ind) {
                            if (item.id == sel.id) {
                                options.index = ind;
                            }
                        });
                    }
                    input = $(this.helpers.focus).find('input');
                }
                if ($(input).is(':focus')) {
                    if (options.openOnFocus === false &amp;&amp; $(input).val() === '' &amp;&amp; obj.tmp.force_open !== true) {
                        $().w2overlay();
                        return;
                    }
                    if (obj.tmp.force_hide) {
                        $().w2overlay();
                        setTimeout(function () {
                            delete obj.tmp.force_hide;
                        }, 1);
                        return;
                    }
                    if ($(input).val() !== '') delete obj.tmp.force_open;
                    var msgNoItems = w2utils.lang('No matches');
                    if (options.url != null &amp;&amp; $(input).val().length &lt; options.minLength &amp;&amp; obj.tmp.emptySet !== true) msgNoItems = options.minLength + ' ' + w2utils.lang('letters or more...');
                    if (options.url != null &amp;&amp; $(input).val() === '' &amp;&amp; obj.tmp.emptySet !== true) msgNoItems = w2utils.lang('Type to search...');
                    if (options.url == null &amp;&amp; options.items.length === 0) msgNoItems = w2utils.lang('Empty list');
                    if (options.msgNoItems != null) msgNoItems = options.msgNoItems;
                    if (msgNoItems == 'function') msgNoItems = msgNoItems(options);
                    $(el).w2menu((!indexOnly ? 'refresh' : 'refresh-index'), $.extend(true, {}, options, {
                        search: false,
                        render: options.renderDrop,
                        maxHeight: options.maxDropHeight,
                        maxWidth: options.maxDropWidth,
                        msgNoItems: msgNoItems,
                        // selected with mouse
                        onSelect: function (event) {
                            if (obj.type == 'enum') {
                                var selected = $(obj.el).data('selected');
                                if (event.item) {
                                    // trigger event
                                    var edata = obj.trigger({
                                        phase: 'before',
                                        type: 'add',
                                        target: obj.el,
                                        originalEvent: event.originalEvent,
                                        item: event.item
                                    });
                                    if (edata.isCancelled === true) return;
                                    // default behavior
                                    if (selected.length >= options.max &amp;&amp; options.max > 0) selected.pop();
                                    delete event.item.hidden;
                                    selected.push(event.item);
                                    $(obj.el).data('selected', selected).change();
                                    $(obj.helpers.multi).find('input').val('').width(20);
                                    obj.refresh();
                                    if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay')[0].hide();
                                    // event after
                                    obj.trigger($.extend(edata, {phase: 'after'}));
                                }
                            } else {
                                $(obj.el).data('selected', event.item).val(event.item.text).change();
                                if (obj.helpers.focus) obj.helpers.focus.find('input').val('');
                            }
                        }
                    }));
                }
            }
        },

        inRange: function (str, onlyDate) {
            var inRange = false;
            if (this.type == 'date') {
                var dt = w2utils.isDate(str, this.options.format, true);
                if (dt) {
                    // enable range
                    if (this.options.start || this.options.end) {
                        var st = (typeof this.options.start == 'string' ? this.options.start : $(this.options.start).val());
                        var en = (typeof this.options.end == 'string' ? this.options.end : $(this.options.end).val());
                        var start = w2utils.isDate(st, this.options.format, true);
                        var end = w2utils.isDate(en, this.options.format, true);
                        var current = new Date(dt);
                        if (!start) start = current;
                        if (!end) end = current;
                        if (current >= start &amp;&amp; current &lt;= end) inRange = true;
                    } else {
                        inRange = true;
                    }
                    // block predefined dates
                    if (this.options.blocked &amp;&amp; $.inArray(str, this.options.blocked) != -1) inRange = false;

                    /*
                     clockWeekDay - type: array or integers. every element - number of week day.
                     number of weekday (1 - monday, 2 - tuesday, 3 - wensday, 4 - thursday, 5 - friday, 6 - saturday, 0 - sunday)
                     for block in calendar (for example, block all sundays so user can't choose sunday in calendar)
                     */
                    if (this.options.blockWeekDays != null &amp;&amp; this.options.blockWeekDays != undefined
                        &amp;&amp; this.options.blockWeekDays.length != undefined) {
                        var l = this.options.blockWeekDays.length;
                        for (var i = 0; i &lt; l; i++) {
                            if (dt.getDay() == this.options.blockWeekDays[i]) {
                                inRange = false;
                            }
                        }
                    }
                }
            } else if (this.type == 'time') {
                if (this.options.start || this.options.end) {
                    var tm = this.toMin(str);
                    var tm1 = this.toMin(this.options.start);
                    var tm2 = this.toMin(this.options.end);
                    if (!tm1) tm1 = tm;
                    if (!tm2) tm2 = tm;
                    if (tm >= tm1 &amp;&amp; tm &lt;= tm2) inRange = true;
                } else {
                    inRange = true;
                }
            } else if (this.type == 'datetime') {
                var dt = w2utils.isDateTime(str, this.options.format, true);
                if (dt) {
                    // enable range
                    if (this.options.start || this.options.end) {
                        var start, end;
                        if (typeof this.options.start == 'object' &amp;&amp; this.options.start instanceof Date) {
                            start = this.options.start;
                        } else {
                            var st = (typeof this.options.start == 'string' ? this.options.start : $(this.options.start).val());
                            if (st.trim() !== '') {
                                start = w2utils.isDateTime(st, this.options.format, true);
                            } else {
                                start = '';
                            }
                        }
                        if (typeof this.options.end == 'object' &amp;&amp; this.options.end instanceof Date) {
                            end = this.options.end;
                        } else {
                            var en = (typeof this.options.end == 'string' ? this.options.end : $(this.options.end).val());
                            if (en.trim() !== '') {
                                end = w2utils.isDateTime(en, this.options.format, true);
                            } else {
                                end = '';
                            }
                        }
                        var current = dt; // new Date(dt);
                        if (!start) start = current;
                        if (!end) end = current;
                        if (onlyDate &amp;&amp; start instanceof Date) {
                            start.setHours(0);
                            start.setMinutes(0);
                            start.setSeconds(0);
                        }
                        if (current >= start &amp;&amp; current &lt;= end) inRange = true;
                    } else {
                        inRange = true;
                    }
                    // block predefined dates
                    if (inRange &amp;&amp; this.options.blocked) {
                        for (var i = 0; i &lt; this.options.blocked.length; i++) {
                            var blocked = this.options.blocked[i];
                            if (typeof blocked == 'string') {
                                // convert string to Date object
                                blocked = w2utils.isDateTime(blocked, this.options.format, true);
                            }
                            // check for Date object with the same day
                            if (typeof blocked == 'object' &amp;&amp; blocked instanceof Date &amp;&amp; (blocked.getFullYear() == dt.getFullYear() &amp;&amp; blocked.getMonth() == dt.getMonth() &amp;&amp; blocked.getDate() == dt.getDate())) {
                                inRange = false;
                                break;
                            }
                        }
                    }
                }
            }
            return inRange;
        },

        /*
         *  INTERNAL FUNCTIONS
         */

        checkType: function (ch, loose) {
            var obj = this;
            switch (obj.type) {
                case 'int':
                    if (loose &amp;&amp; ['-', obj.options.groupSymbol].indexOf(ch) != -1) return true;
                    return w2utils.isInt(ch.replace(obj.options.numberRE, ''));
                case 'percent':
                    ch = ch.replace(/%/g, '');
                case 'float':
                    if (loose &amp;&amp; ['-', w2utils.settings.decimalSymbol, obj.options.groupSymbol].indexOf(ch) != -1) return true;
                    return w2utils.isFloat(ch.replace(obj.options.numberRE, ''));
                case 'money':
                case 'currency':
                    if (loose &amp;&amp; ['-', obj.options.decimalSymbol, obj.options.groupSymbol, obj.options.currencyPrefix, obj.options.currencySuffix].indexOf(ch) != -1) return true;
                    return w2utils.isFloat(ch.replace(obj.options.moneyRE, ''));
                case 'bin':
                    return w2utils.isBin(ch);
                case 'hex':
                case 'color':
                    return w2utils.isHex(ch);
                case 'alphanumeric':
                    return w2utils.isAlphaNumeric(ch);
            }
            return true;
        },

        addPrefix: function () {
            var obj = this;
            setTimeout(function () {
                if (obj.type === 'clear') return;
                var helper;
                var tmp = $(obj.el).data('tmp') || {};
                if (tmp['old-padding-left']) $(obj.el).css('padding-left', tmp['old-padding-left']);
                tmp['old-padding-left'] = $(obj.el).css('padding-left');
                $(obj.el).data('tmp', tmp);
                // remove if already displaed
                if (obj.helpers.prefix) $(obj.helpers.prefix).remove();
                if (obj.options.prefix !== '') {
                    // add fresh
                    $(obj.el).before(
                        '&lt;div class="w2ui-field-helper">' +
                        obj.options.prefix +
                        '&lt;/div>'
                    );
                    helper = $(obj.el).prev();
                    helper
                        .css({
                            'color': $(obj.el).css('color'),
                            'font-family': $(obj.el).css('font-family'),
                            'font-size': $(obj.el).css('font-size'),
                            'padding-top': $(obj.el).css('padding-top'),
                            'padding-bottom': $(obj.el).css('padding-bottom'),
                            'padding-left': $(obj.el).css('padding-left'),
                            'padding-right': 0,
                            'margin-top': (parseInt($(obj.el).css('margin-top'), 10) + 2) + 'px',
                            'margin-bottom': (parseInt($(obj.el).css('margin-bottom'), 10) + 1) + 'px',
                            'margin-left': $(obj.el).css('margin-left'),
                            'margin-right': 0
                        })
                        .on('click', function (event) {
                            if (obj.options.icon &amp;&amp; typeof obj.onIconClick == 'function') {
                                // event before
                                var edata = obj.trigger({
                                    phase: 'before',
                                    type: 'iconClick',
                                    target: obj.el,
                                    el: $(this).find('span.w2ui-icon')[0]
                                });
                                if (edata.isCancelled === true) return;

                                // intentionally empty

                                // event after
                                obj.trigger($.extend(edata, {phase: 'after'}));
                            } else {
                                if (obj.type == 'list') {
                                    $(obj.helpers.focus).find('input').focus();
                                } else {
                                    $(obj.el).focus();
                                }
                            }
                        });
                    $(obj.el).css('padding-left', (helper.width() + parseInt($(obj.el).css('padding-left'), 10)) + 'px');
                    // remember helper
                    obj.helpers.prefix = helper;
                }
            }, 1);
        },

        addSuffix: function () {
            var obj = this;
            var helper, pr;
            setTimeout(function () {
                if (obj.type === 'clear') return;
                var tmp = $(obj.el).data('tmp') || {};
                if (tmp['old-padding-right']) $(obj.el).css('padding-right', tmp['old-padding-right']);
                tmp['old-padding-right'] = $(obj.el).css('padding-right');
                $(obj.el).data('tmp', tmp);
                pr = parseInt($(obj.el).css('padding-right'), 10);
                if (obj.options.arrows) {
                    // remove if already displayed
                    if (obj.helpers.arrows) $(obj.helpers.arrows).remove();
                    // add fresh
                    $(obj.el).after(
                        '&lt;div class="w2ui-field-helper" style="border: 1px solid transparent">&amp;#160;' +
                        '    &lt;div class="w2ui-field-up" type="up">' +
                        '        &lt;div class="arrow-up" type="up">&lt;/div>' +
                        '    &lt;/div>' +
                        '    &lt;div class="w2ui-field-down" type="down">' +
                        '        &lt;div class="arrow-down" type="down">&lt;/div>' +
                        '    &lt;/div>' +
                        '&lt;/div>');
                    var height = w2utils.getSize(obj.el, 'height');
                    helper = $(obj.el).next();
                    helper.css({
                        'color': $(obj.el).css('color'),
                        'font-family': $(obj.el).css('font-family'),
                        'font-size': $(obj.el).css('font-size'),
                        'height': ($(obj.el).height() + parseInt($(obj.el).css('padding-top'), 10) + parseInt($(obj.el).css('padding-bottom'), 10) ) + 'px',
                        'padding': 0,
                        'margin-top': (parseInt($(obj.el).css('margin-top'), 10) + 1) + 'px',
                        'margin-bottom': 0,
                        'border-left': '1px solid silver'
                    })
                        .css('margin-left', '-' + (helper.width() + parseInt($(obj.el).css('margin-right'), 10) + 12) + 'px')
                        .on('mousedown', function (event) {
                            var body = $('body');
                            body.on('mouseup', tmp);
                            body.data('_field_update_timer', setTimeout(update, 700));
                            update(false);
                            // timer function
                            function tmp() {
                                clearTimeout(body.data('_field_update_timer'));
                                body.off('mouseup', tmp);
                            }

                            // update function
                            function update(notimer) {
                                $(obj.el).focus();
                                obj.keyDown($.Event("keydown"), {
                                    keyCode: ($(event.target).attr('type') == 'up' ? 38 : 40)
                                });
                                if (notimer !== false) $('body').data('_field_update_timer', setTimeout(update, 60));
                            }
                        });
                    pr += helper.width() + 12;
                    $(obj.el).css('padding-right', pr + 'px');
                    // remember helper
                    obj.helpers.arrows = helper;
                }
                if (obj.options.suffix !== '') {
                    // remove if already displayed
                    if (obj.helpers.suffix) $(obj.helpers.suffix).remove();
                    // add fresh
                    $(obj.el).after(
                        '&lt;div class="w2ui-field-helper">' +
                        obj.options.suffix +
                        '&lt;/div>');
                    helper = $(obj.el).next();
                    helper
                        .css({
                            'color': $(obj.el).css('color'),
                            'font-family': $(obj.el).css('font-family'),
                            'font-size': $(obj.el).css('font-size'),
                            'padding-top': $(obj.el).css('padding-top'),
                            'padding-bottom': $(obj.el).css('padding-bottom'),
                            'padding-left': '3px',
                            'padding-right': $(obj.el).css('padding-right'),
                            'margin-top': (parseInt($(obj.el).css('margin-top'), 10) + 2) + 'px',
                            'margin-bottom': (parseInt($(obj.el).css('margin-bottom'), 10) + 1) + 'px'
                        })
                        .on('click', function (event) {
                            if (obj.type == 'list') {
                                $(obj.helpers.focus).find('input').focus();
                            } else {
                                $(obj.el).focus();
                            }
                        });

                    helper.css('margin-left', '-' + (w2utils.getSize(helper, 'width') + parseInt($(obj.el).css('margin-right'), 10) + 2) + 'px');
                    pr += helper.width() + 3;
                    $(obj.el).css('padding-right', pr + 'px');
                    // remember helper
                    obj.helpers.suffix = helper;
                }
            }, 1);
        },

        addFocus: function () {
            var obj = this;
            var options = this.options;
            var width = 0; // 11 - show search icon, 0 do not show
            var pholder;
            // clean up &amp; init
            $(obj.helpers.focus).remove();
            // remember original tabindex
            var tabIndex = $(obj.el).attr('tabIndex');
            if (tabIndex &amp;&amp; tabIndex != -1) obj.el._tabIndex = tabIndex;
            if (obj.el._tabIndex) tabIndex = obj.el._tabIndex;
            if (tabIndex == null) tabIndex = -1;
            // build helper
            var html =
                '&lt;div class="w2ui-field-helper">' +
                '    &lt;div class="w2ui-icon icon-search" style="opacity: 0; display: none">&lt;/div>' +
                '    &lt;input type="text" autocomplete="off" tabIndex="' + tabIndex + '"/>' +
                '&lt;/div>';
            $(obj.el).attr('tabindex', -1).before(html);
            var helper = $(obj.el).prev();
            obj.helpers.focus = helper;
            helper.css({
                width: $(obj.el).width(),
                "margin-top": $(obj.el).css('margin-top'),
                "margin-left": (parseInt($(obj.el).css('margin-left')) + parseInt($(obj.el).css('padding-left'))) + 'px',
                "margin-bottom": $(obj.el).css('margin-bottom'),
                "margin-right": $(obj.el).css('margin-right')
            })
                .find('input')
                .css({
                    cursor: 'default',
                    width: '100%',
                    outline: 'none',
                    opacity: 1,
                    margin: 0,
                    border: '1px solid transparent',
                    padding: $(obj.el).css('padding-top'),
                    "padding-left": 0,
                    "margin-left": (width > 0 ? width + 6 : 0),
                    "background-color": 'transparent'
                });
            // INPUT events
            helper.find('input')
                .on('click', function (event) {
                    if ($('#w2ui-overlay').length === 0) obj.focus(event);
                    event.stopPropagation();
                })
                .on('focus', function (event) {
                    pholder = $(obj.el).attr('placeholder');
                    $(obj.el).css({'outline': 'auto 5px #7DB4F3', 'outline-offset': '-2px'});
                    $(this).val('');
                    $(obj.el).triggerHandler('focus');
                    if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;
                })
                .on('blur', function (event) {
                    $(obj.el).css('outline', 'none');
                    $(this).val('');
                    obj.refresh();
                    $(obj.el).triggerHandler('blur');
                    if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;
                    if (pholder != null) $(obj.el).attr('placeholder', pholder);
                })
                .on('keydown', function (event) {
                    var el = this;
                    obj.keyDown(event);
                    setTimeout(function () {
                        if (el.value === '') $(obj.el).attr('placeholder', pholder); else $(obj.el).attr('placeholder', '');
                    }, 10);
                })
                .on('keyup', function (event) {
                    obj.keyUp(event);
                })
                .on('keypress', function (event) {
                    obj.keyPress(event);
                });
            // MAIN div
            helper.on('click', function (event) {
                $(this).find('input').focus();
            });
            obj.refresh();
        },

        addMulti: function () {
            var obj = this;
            var options = this.options;
            // clean up &amp; init
            $(obj.helpers.multi).remove();
            // build helper
            var html = '';
            var margin =
                'margin-top     : 0px; ' +
                'margin-bottom  : 0px; ' +
                'margin-left    : ' + $(obj.el).css('margin-left') + '; ' +
                'margin-right   : ' + $(obj.el).css('margin-right') + '; ' +
                'width          : ' + (w2utils.getSize(obj.el, 'width')
                - parseInt($(obj.el).css('margin-left'), 10)
                - parseInt($(obj.el).css('margin-right'), 10))
                + 'px;';
            if (obj.type == 'enum') {
                // remember original tabindex
                var tabIndex = $(obj.el).attr('tabIndex');
                if (tabIndex &amp;&amp; tabIndex != -1) obj.el._tabIndex = tabIndex;
                if (obj.el._tabIndex) tabIndex = obj.el._tabIndex;
                if (tabIndex == null) tabIndex = -1;

                html = '&lt;div class="w2ui-field-helper w2ui-list" style="' + margin + '; box-sizing: border-box">' +
                    '    &lt;div style="padding: 0px; margin: 0px; display: inline-block" class="w2ui-multi-items">' +
                    '    &lt;ul>' +
                    '        &lt;li style="padding-left: 0px; padding-right: 0px" class="nomouse">' +
                    '            &lt;input type="text" style="width: 20px; margin: -3px 0 0; padding: 2px 0; border-color: white" autocomplete="off"' + ($(obj.el).prop('readonly') ? ' readonly="readonly"' : '') + ($(obj.el).prop('disabled') ? ' disabled="disabled"' : '') + ' tabindex="' + tabIndex + '"/>' +
                    '        &lt;/li>' +
                    '    &lt;/ul>' +
                    '    &lt;/div>' +
                    '&lt;/div>';
            }
            if (obj.type == 'file') {
                html = '&lt;div class="w2ui-field-helper w2ui-list" style="' + margin + '; box-sizing: border-box">' +
                    '   &lt;div style="position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px;">' +
                    '       &lt;input class="file-input" type="file" style="width: 100%; height: 100%; opacity: 0;" name="attachment" multiple tabindex="-1"' + ($(obj.el).prop('readonly') ? ' readonly="readonly"' : '') + ($(obj.el).prop('disabled') ? ' disabled="disabled"' : '') + ($(obj.el).attr('accept') ? ' accept="' + $(obj.el).attr('accept') + '"' : '') + '/>' +
                    '   &lt;/div>' +
                    '    &lt;div style="position: absolute; padding: 0px; margin: 0px; display: inline-block" class="w2ui-multi-items">' +
                    '        &lt;ul>&lt;li style="padding-left: 0px; padding-right: 0px" class="nomouse">&lt;/li>&lt;/ul>' +
                    '    &lt;/div>' +
                    '&lt;/div>';
            }
            // old bg and border
            var tmp = $(obj.el).data('tmp') || {};
            tmp['old-background-color'] = $(obj.el).css('background-color');
            tmp['old-border-color'] = $(obj.el).css('border-color');
            $(obj.el).data('tmp', tmp);

            $(obj.el)
                .before(html)
                .css({
                    'background-color': 'transparent',
                    'border-color': 'transparent'
                });

            var div = $(obj.el).prev();
            obj.helpers.multi = div;
            if (obj.type == 'enum') {
                $(obj.el).attr('tabindex', -1);
                // INPUT events
                div.find('input')
                    .on('click', function (event) {
                        if ($('#w2ui-overlay').length === 0) obj.focus(event);
                        $(obj.el).triggerHandler('click');
                    })
                    .on('focus', function (event) {
                        $(div).css({'outline': 'auto 5px #7DB4F3', 'outline-offset': '-2px'});
                        $(obj.el).triggerHandler('focus');
                        if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;
                    })
                    .on('blur', function (event) {
                        $(div).css('outline', 'none');
                        $(obj.el).triggerHandler('blur');
                        if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;
                    })
                    .on('keyup', function (event) {
                        obj.keyUp(event);
                    })
                    .on('keydown', function (event) {
                        obj.keyDown(event);
                    })
                    .on('keypress', function (event) {
                        obj.keyPress(event);
                    });
                // MAIN div
                div.on('click', function (event) {
                    $(this).find('input').focus();
                });
            }
            if (obj.type == 'file') {
                $(obj.el).css('outline', 'none');
                div.on('click', function (event) {
                    $(obj.el).focus();
                    if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                    obj.blur(event);
                    obj.resize();
                    setTimeout(function () {
                        div.find('input').click();
                    }, 10); // needed this when clicked on items div
                })
                    .on('dragenter', function (event) {
                        if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                        $(div).addClass('w2ui-file-dragover');
                    })
                    .on('dragleave', function (event) {
                        if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                        var tmp = $(event.target).parents('.w2ui-field-helper');
                        if (tmp.length === 0) $(div).removeClass('w2ui-file-dragover');
                    })
                    .on('drop', function (event) {
                        if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) return;
                        $(div).removeClass('w2ui-file-dragover');
                        var files = event.originalEvent.dataTransfer.files;
                        for (var i = 0, l = files.length; i &lt; l; i++) obj.addFile.call(obj, files[i]);
                        // cancel to stop browser behaviour
                        event.preventDefault();
                        event.stopPropagation();
                    })
                    .on('dragover', function (event) {
                        // cancel to stop browser behaviour
                        event.preventDefault();
                        event.stopPropagation();
                    });
                div.find('input')
                    .on('click', function (event) {
                        event.stopPropagation();
                    })
                    .on('change', function () {
                        if (typeof this.files !== "undefined") {
                            for (var i = 0, l = this.files.length; i &lt; l; i++) {
                                obj.addFile.call(obj, this.files[i]);
                            }
                        }
                    });
            }
            obj.refresh();
        },

        addFile: function (file) {
            var obj = this;
            var options = this.options;
            var selected = $(obj.el).data('selected');
            var newItem = {
                name: file.name,
                type: file.type,
                modified: file.lastModifiedDate,
                size: file.size,
                content: null,
                file: file
            };
            var size = 0;
            var cnt = 0;
            var err;
            if (selected) {
                for (var s = 0; s &lt; selected.length; s++) {
                    // check for dups
                    if (selected[s].name == file.name &amp;&amp; selected[s].size == file.size) return;
                    size += selected[s].size;
                    cnt++;
                }
            }
            // trigger event
            var edata = obj.trigger({
                phase: 'before',
                type: 'add',
                target: obj.el,
                file: newItem,
                total: cnt,
                totalSize: size
            });
            if (edata.isCancelled === true) return;
            // check params
            if (options.maxFileSize !== 0 &amp;&amp; newItem.size > options.maxFileSize) {
                err = 'Maximum file size is ' + w2utils.formatSize(options.maxFileSize);
                if (options.silent === false) $(obj.el).w2tag(err);
                console.log('ERROR: ' + err);
                return;
            }
            if (options.maxSize !== 0 &amp;&amp; size + newItem.size > options.maxSize) {
                err = 'Maximum total size is ' + w2utils.formatSize(options.maxSize);
                if (options.silent === false) $(obj.el).w2tag(err);
                console.log('ERROR: ' + err);
                return;
            }
            if (options.max !== 0 &amp;&amp; cnt >= options.max) {
                err = 'Maximum number of files is ' + options.max;
                if (options.silent === false) $(obj.el).w2tag(err);
                console.log('ERROR: ' + err);
                return;
            }
            selected.push(newItem);
            // read file as base64
            if (typeof FileReader !== "undefined" &amp;&amp; options.readContent === true) {
                var reader = new FileReader();
                // need a closure
                reader.onload = (function () {
                    return function (event) {
                        var fl = event.target.result;
                        var ind = fl.indexOf(',');
                        newItem.content = fl.substr(ind + 1);
                        obj.refresh();
                        $(obj.el).trigger('change');
                        // event after
                        obj.trigger($.extend(edata, {phase: 'after'}));
                    };
                })();
                reader.readAsDataURL(file);
            } else {
                obj.refresh();
                $(obj.el).trigger('change');
            }
        },

        normMenu: function (menu) {
            if ($.isArray(menu)) {
                for (var m = 0; m &lt; menu.length; m++) {
                    if (typeof menu[m] == 'string') {
                        menu[m] = {id: menu[m], text: menu[m]};
                    } else {
                        if (menu[m].text != null &amp;&amp; menu[m].id == null) menu[m].id = menu[m].text;
                        if (menu[m].text == null &amp;&amp; menu[m].id != null) menu[m].text = menu[m].id;
                        if (menu[m].caption != null) menu[m].text = menu[m].caption;
                    }
                }
                return menu;
            } else if (typeof menu == 'function') {
                return this.normMenu(menu());
            } else if (typeof menu == 'object') {
                var tmp = [];
                for (var m in menu) tmp.push({id: m, text: menu[m]});
                return tmp;
            }
        },

        getMonthHTML: function (month, year, selected) {
            var td = new Date();
            var months = w2utils.settings.fullmonths;
            var daysCount = ['31', '28', '31', '30', '31', '30', '31', '31', '30', '31', '30', '31'];
            var today = td.getFullYear() + '/' + (Number(td.getMonth()) + 1) + '/' + td.getDate();
            var days = w2utils.settings.fulldays.slice();    // creates copy of the array
            var sdays = w2utils.settings.shortdays.slice();   // creates copy of the array
            if (w2utils.settings.weekStarts != 'M') {
                days.unshift(days.pop());
                sdays.unshift(sdays.pop());
            }
            var options = this.options;
            if (options == null) options = {};
            // normalize date
            year = w2utils.isInt(year) ? parseInt(year) : td.getFullYear();
            month = w2utils.isInt(month) ? parseInt(month) : td.getMonth() + 1;
            if (month > 12) {
                month -= 12;
                year++;
            }
            if (month &lt; 1 || month === 0) {
                month += 12;
                year--;
            }
            if (year / 4 == Math.floor(year / 4)) {
                daysCount[1] = '29';
            } else {
                daysCount[1] = '28';
            }
            options.current = month + '/' + year;

            // start with the required date
            td = new Date(year, month - 1, 1);
            var weekDay = td.getDay();
            var dayTitle = '';
            for (var i = 0; i &lt; sdays.length; i++) dayTitle += '&lt;td title="' + days[i] + '">' + sdays[i] + '&lt;/td>';

            var html =
                '&lt;div class="w2ui-calendar-title title">' +
                '    &lt;div class="w2ui-calendar-previous previous"> &lt;div>&lt;/div> &lt;/div>' +
                '    &lt;div class="w2ui-calendar-next next"> &lt;div>&lt;/div> &lt;/div> ' +
                months[month - 1] + ', ' + year +
                '&lt;/div>' +
                '&lt;table class="w2ui-calendar-days" cellspacing="0">&lt;tbody>' +
                '    &lt;tr class="w2ui-day-title">' + dayTitle + '&lt;/tr>' +
                '    &lt;tr>';

            var day = 1;
            if (w2utils.settings.weekStarts != 'M') weekDay++;
            if (this.type === 'datetime') {
                var dt_sel = w2utils.isDateTime(selected, options.format, true);
                selected = w2utils.formatDate(dt_sel, w2utils.settings.dateFormat);
            }
            for (var ci = 1; ci &lt; 43; ci++) {
                if (weekDay === 0 &amp;&amp; ci == 1) {
                    for (var ti = 0; ti &lt; 6; ti++) html += '&lt;td class="w2ui-day-empty">&amp;#160;&lt;/td>';
                    ci += 6;
                } else {
                    if (ci &lt; weekDay || day > daysCount[month - 1]) {
                        html += '&lt;td class="w2ui-day-empty">&amp;#160;&lt;/td>';
                        if ((ci) % 7 === 0) html += '&lt;/tr>&lt;tr>';
                        continue;
                    }
                }
                var dt = year + '/' + month + '/' + day;
                var DT = new Date(dt);
                var className = '';
                if (DT.getDay() === 6) className = ' w2ui-saturday';
                if (DT.getDay() === 0) className = ' w2ui-sunday';
                if (dt == today) className += ' w2ui-today';

                var dspDay = day;
                var col = '';
                var bgcol = '';
                var tmp_dt, tmp_dt_fmt;
                if (this.type === 'datetime') {
                    // var fm = options.format.split('|')[0].trim();
                    // tmp_dt      = w2utils.formatDate(dt, fm);
                    tmp_dt = w2utils.formatDateTime(dt, options.format);
                    tmp_dt_fmt = w2utils.formatDate(dt, w2utils.settings.dateFormat);
                } else {
                    tmp_dt = w2utils.formatDate(dt, options.format);
                    tmp_dt_fmt = tmp_dt;
                }
                if (options.colored &amp;&amp; options.colored[tmp_dt_fmt] !== undefined) { // if there is predefined colors for dates
                    var tmp = options.colored[tmp_dt_fmt].split(':');
                    bgcol = 'background-color: ' + tmp[0] + ';';
                    col = 'color: ' + tmp[1] + ';';
                }
                html += '&lt;td class="' + (this.inRange(tmp_dt, true) ? 'w2ui-date ' + (tmp_dt_fmt == selected ? 'w2ui-date-selected' : '') : 'w2ui-blocked') + className + '" ' +
                    '   style="' + col + bgcol + '" date="' + tmp_dt + '" data-date="' + DT + '">' +
                    dspDay +
                    '&lt;/td>';
                if (ci % 7 === 0 || (weekDay === 0 &amp;&amp; ci == 1)) html += '&lt;/tr>&lt;tr>';
                day++;
            }
            html += '&lt;/tr>&lt;/tbody>&lt;/table>';
            return html;
        },

        getYearHTML: function () {
            var months = w2utils.settings.shortmonths;
            var start_year = w2utils.settings.dateStartYear;
            var end_year = w2utils.settings.dateEndYear;
            var mhtml = '';
            var yhtml = '';
            for (var m = 0; m &lt; months.length; m++) {
                mhtml += '&lt;div class="w2ui-jump-month" name="' + m + '">' + months[m] + '&lt;/div>';
            }
            for (var y = start_year; y &lt;= end_year; y++) {
                yhtml += '&lt;div class="w2ui-jump-year" name="' + y + '">' + y + '&lt;/div>';
            }
            return '&lt;div>' + mhtml + '&lt;/div>&lt;div>' + yhtml + '&lt;/div>';
        },

        getHourHTML: function () {
            var tmp = [];
            var options = this.options;
            if (options == null) options = {format: w2utils.settings.timeFormat};
            var h24 = (options.format.indexOf('h24') > -1);
            for (var a = 0; a &lt; 24; a++) {
                var time = (a >= 12 &amp;&amp; !h24 ? a - 12 : a) + ':00' + (!h24 ? (a &lt; 12 ? ' am' : ' pm') : '');
                if (a == 12 &amp;&amp; !h24) time = '12:00 pm';
                if (!tmp[Math.floor(a / 8)]) tmp[Math.floor(a / 8)] = '';
                var tm1 = this.fromMin(this.toMin(time));
                var tm2 = this.fromMin(this.toMin(time) + 59);
                if (this.type === 'datetime') {
                    var dt = w2utils.isDateTime(this.el.value, options.format, true);
                    var fm = options.format.split('|')[0].trim();
                    tm1 = w2utils.formatDate(dt, fm) + ' ' + tm1;
                    tm2 = w2utils.formatDate(dt, fm) + ' ' + tm2;
                }
                tmp[Math.floor(a / 8)] += '&lt;div class="' + (this.inRange(tm1) || this.inRange(tm2) ? 'w2ui-time ' : 'w2ui-blocked') + '" hour="' + a + '">' + time + '&lt;/div>';
            }
            var html =
                '&lt;div class="w2ui-calendar">' +
                '   &lt;div class="w2ui-calendar-title">' + w2utils.lang('Select Hour') + '&lt;/div>' +
                '   &lt;div class="w2ui-calendar-time">&lt;table>&lt;tbody>&lt;tr>' +
                '       &lt;td>' + tmp[0] + '&lt;/td>' +
                '       &lt;td>' + tmp[1] + '&lt;/td>' +
                '       &lt;td>' + tmp[2] + '&lt;/td>' +
                '   &lt;/tr>&lt;/tbody>&lt;/table>&lt;/div>' +
                '&lt;/div>';
            return html;
        },

        getMinHTML: function (hour) {
            if (hour == null) hour = 0;
            var options = this.options;
            if (options == null) options = {format: w2utils.settings.timeFormat};
            var h24 = (options.format.indexOf('h24') > -1);
            var tmp = [];
            for (var a = 0; a &lt; 60; a += 5) {
                var time = (hour > 12 &amp;&amp; !h24 ? hour - 12 : hour) + ':' + (a &lt; 10 ? 0 : '') + a + ' ' + (!h24 ? (hour &lt; 12 ? 'am' : 'pm') : '');
                var tm = time;
                var ind = a &lt; 20 ? 0 : (a &lt; 40 ? 1 : 2);
                if (!tmp[ind]) tmp[ind] = '';
                if (this.type === 'datetime') {
                    var dt = w2utils.isDateTime(this.el.value, options.format, true);
                    var fm = options.format.split('|')[0].trim();
                    tm = w2utils.formatDate(dt, fm) + ' ' + tm;
                }
                tmp[ind] += '&lt;div class="' + (this.inRange(tm) ? 'w2ui-time ' : 'w2ui-blocked') + '" min="' + a + '">' + time + '&lt;/div>';
            }
            var html =
                '&lt;div class="w2ui-calendar">' +
                '   &lt;div class="w2ui-calendar-title">' + w2utils.lang('Select Minute') + '&lt;/div>' +
                '   &lt;div class="w2ui-calendar-time">&lt;table>&lt;tbody>&lt;tr>' +
                '       &lt;td>' + tmp[0] + '&lt;/td>' +
                '       &lt;td>' + tmp[1] + '&lt;/td>' +
                '       &lt;td>' + tmp[2] + '&lt;/td>' +
                '   &lt;/tr>&lt;/tbody>&lt;/table>&lt;/div>' +
                '&lt;/div>';
            return html;
        },

        toMin: function (str) {
            if (typeof str != 'string') return null;
            var tmp = str.split(':');
            if (tmp.length === 2) {
                tmp[0] = parseInt(tmp[0]);
                tmp[1] = parseInt(tmp[1]);
                if (str.indexOf('pm') != -1 &amp;&amp; tmp[0] != 12) tmp[0] += 12;
            } else {
                return null;
            }
            return tmp[0] * 60 + tmp[1];
        },

        fromMin: function (time) {
            var ret = '';
            if (time >= 24 * 60) time = time % (24 * 60);
            if (time &lt; 0) time = 24 * 60 + time;
            var hour = Math.floor(time / 60);
            var min = ((time % 60) &lt; 10 ? '0' : '') + (time % 60);
            var options = this.options;
            if (options == null) options = {format: w2utils.settings.timeFormat};
            if (options.format.indexOf('h24') != -1) {
                ret = hour + ':' + min;
            } else {
                ret = (hour &lt;= 12 ? hour : hour - 12) + ':' + min + ' ' + (hour >= 12 ? 'pm' : 'am');
            }
            return ret;
        }
    };

    $.extend(w2field.prototype, w2utils.event);
    w2obj.field = w2field;

})(jQuery);

/************************************************************************
 *   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
 *   - Following objects defined
 *        - w2form      - form widget
 *        - $().w2form  - jQuery wrapper
 *   - Dependencies: jQuery, w2utils, w2fields, w2tabs, w2toolbar
 *
 * == NICE TO HAVE ==
 *   - include delta on save
 *   - form should read &lt;select> &lt;options> into items
 *   - two way data bindings
 *   - verify validation of fields
 *   - added getChanges() - not complete
 *   - nested record object
 *   - formHTML --> template
 *
 * == 1.5 changes
 *   - $('#form').w2form() - if called w/o argument then it returns form object
 *   - added onProgress
 *   - added field.html.style (for the whole field)
 *   - added enable/disable, show/hide
 *   - added field.disabled, field.hidden
 *   - when field is blank, set record.field = null
 *   - action: { caption: 'Limpiar', style: '', class: '', onClick: function () {} }
 *   - added ability to generate radio and select html in generateHTML()
 *   - refresh(field) - would refresh only one field
 *   - form.message
 *   - added field.html.column
 *   - added field types html, empty, custom
 *   - httpHeaders
 *   - method
 *
 ************************************************************************/


(function ($) {
    var w2form = function (options) {
        // public properties
        this.name = null;
        this.header = '';
        this.box = null;     // HTML element that hold this element
        this.url = '';
        this.routeData = {};       // data for dynamic routes
        this.formURL = '';       // url where to get form HTML
        this.formHTML = '';       // form HTML (might be loaded from the url)
        this.page = 0;        // current page
        this.recid = 0;        // can be null or 0
        this.fields = [];
        this.actions = {};
        this.record = {};
        this.original = {};
        this.postData = {};
        this.httpHeaders = {};
        this.method = null;     // only used when not null, otherwise set based on w2utils.settings.dataType
        this.toolbar = {};       // if not empty, then it is toolbar
        this.tabs = {};       // if not empty, then it is tabs object
        this.style = '';
        this.focus = 0;        // focus first or other element

        // internal
        this.isGenerated = false;
        this.last = {
            xhr: null        // jquery xhr requests
        };

        $.extend(true, this, w2obj.form, options);
    };

    // ====================================================
    // -- Registers as a jQuery plugin

    $.fn.w2form = function (method) {
        if ($.isPlainObject(method)) {
            var obj = this;
            // check name parameter
            if (!w2utils.checkName(method, 'w2form')) return;
            // remember items
            var record = method.record;
            var original = method.original;
            var fields = method.fields;
            var toolbar = method.toolbar;
            var tabs = method.tabs;
            // extend items
            var object = new w2form(method);
            $.extend(object, {record: {}, original: {}, fields: [], tabs: {}, toolbar: {}, handlers: []});
            if ($.isArray(tabs)) {
                $.extend(true, object.tabs, {tabs: []});
                for (var t = 0; t &lt; tabs.length; t++) {
                    var tmp = tabs[t];
                    if (typeof tmp === 'object') {
                        object.tabs.tabs.push(tmp);
                        if (tmp.active === true) {
                            object.tabs.active = tmp.id;
                        }
                    } else {
                        object.tabs.tabs.push({id: tmp, caption: tmp});
                    }
                }
            } else {
                $.extend(true, object.tabs, tabs);
            }
            $.extend(true, object.toolbar, toolbar);
            // reassign variables
            if (fields) for (var p = 0; p &lt; fields.length; p++) {
                var field = $.extend(true, {}, fields[p]);
                if (field.name == null &amp;&amp; field.field != null) field.name = field.field;
                if (field.field == null &amp;&amp; field.name != null) field.field = field.name;
                object.fields[p] = field;
            }
            for (var p in record) { // it is an object
                if ($.isPlainObject(record[p])) {
                    object.record[p] = $.extend(true, {}, record[p]);
                } else {
                    object.record[p] = record[p];
                }
            }
            for (var p in original) { // it is an object
                if ($.isPlainObject(original[p])) {
                    object.original[p] = $.extend(true, {}, original[p]);
                } else {
                    object.original[p] = original[p];
                }
            }
            if (obj.length > 0) object.box = obj[0];
            // render if necessary
            if (object.formURL !== '') {
                $.get(object.formURL, function (data) { // should always be $.get as it is template
                    object.formHTML = data;
                    object.isGenerated = true;
                    if ($(object.box).length !== 0 || data.length !== 0) {
                        $(object.box).html(data);
                        object.render(object.box);
                    }
                });
            } else if (object.formHTML !== '') {
                // it is already loaded into formHTML
            } else if ($(this).length !== 0 &amp;&amp; $.trim($(this).html()) !== '') {
                object.formHTML = $(this).html();
            } else { // try to generate it
                object.formHTML = object.generateHTML();
            }
            // register new object
            w2ui[object.name] = object;
            // render if not loaded from url
            if (object.formURL === '') {
                if (String(object.formHTML).indexOf('w2ui-page') == -1) {
                    object.formHTML = '&lt;div class="w2ui-page page-0">' + object.formHTML + '&lt;/div>';
                }
                $(object.box).html(object.formHTML);
                object.isGenerated = true;
                object.render(object.box);
            }
            return object;

        } else {
            var obj = w2ui[$(this).attr('name')];
            if (!obj) return null;
            if (arguments.length > 0) {
                if (obj[method]) obj[method].apply(obj, Array.prototype.slice.call(arguments, 1));
                return this;
            } else {
                return obj;
            }
        }
    };

    // ====================================================
    // -- Implementation of core functionality

    w2form.prototype = {
        // events
        onRequest: null,
        onLoad: null,
        onValidate: null,
        onSubmit: null,
        onProgress: null,
        onSave: null,
        onChange: null,
        onRender: null,
        onRefresh: null,
        onResize: null,
        onDestroy: null,
        onAction: null,
        onToolbar: null,
        onError: null,

        msgNotJSON: 'Returned data is not in valid JSON format.',
        msgAJAXerror: 'AJAX error. See console for more details.',
        msgRefresh: 'Refreshing...',
        msgSaving: 'Saving...',

        get: function (field, returnIndex) {
            if (arguments.length === 0) {
                var all = [];
                for (var f1 = 0; f1 &lt; this.fields.length; f1++) {
                    if (this.fields[f1].name != null) all.push(this.fields[f1].name);
                }
                return all;
            } else {
                for (var f2 = 0; f2 &lt; this.fields.length; f2++) {
                    if (this.fields[f2].name == field) {
                        if (returnIndex === true) return f2; else return this.fields[f2];
                    }
                }
                return null;
            }
        },

        set: function (field, obj) {
            for (var f = 0; f &lt; this.fields.length; f++) {
                if (this.fields[f].name == field) {
                    $.extend(this.fields[f], obj);
                    this.refresh();
                    return true;
                }
            }
            return false;
        },

        show: function () {
            var affected = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                var fld = this.get(arguments[a]);
                if (fld &amp;&amp; fld.hidden) {
                    fld.hidden = false;
                    affected++;
                }
            }
            if (affected > 0) this.refresh();
            return affected;
        },

        hide: function () {
            var affected = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                var fld = this.get(arguments[a]);
                if (fld &amp;&amp; !fld.hidden) {
                    fld.hidden = true;
                    affected++;
                }
            }
            if (affected > 0) this.refresh();
            return affected;
        },

        enable: function () {
            var affected = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                var fld = this.get(arguments[a]);
                if (fld &amp;&amp; fld.disabled) {
                    fld.disabled = false;
                    affected++;
                }
            }
            if (affected > 0) this.refresh();
            return affected;
        },

        disable: function () {
            var affected = 0;
            for (var a = 0; a &lt; arguments.length; a++) {
                var fld = this.get(arguments[a]);
                if (fld &amp;&amp; !fld.disabled) {
                    fld.disabled = true;
                    affected++;
                }
            }
            if (affected > 0) this.refresh();
            return affected;
        },

        reload: function (callBack) {
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (url &amp;&amp; this.recid !== 0 &amp;&amp; this.recid != null) {
                // this.clear();
                this.request(callBack);
            } else {
                // this.refresh(); // no need to refresh
                if (typeof callBack == 'function') callBack();
            }
        },

        clear: function () {
            this.recid = 0;
            this.record = {};
            $().w2tag();
            this.refresh();
        },

        error: function (msg) {
            var obj = this;
            // let the management of the error outside of the grid
            var edata = this.trigger({target: this.name, type: 'error', message: msg, xhr: this.last.xhr});
            if (edata.isCancelled === true) {
                if (typeof callBack == 'function') callBack();
                return;
            }
            // need a time out because message might be already up)
            setTimeout(function () {
                obj.message(msg);
            }, 1);
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        message: function (options) {
            if (typeof options == 'string') {
                options = {
                    width: (options.length &lt; 300 ? 350 : 550),
                    height: (options.length &lt; 300 ? 170 : 250),
                    body: '&lt;div class="w2ui-centered">' + options + '&lt;/div>',
                    buttons: '&lt;button class="w2ui-btn" onclick="w2ui[\'' + this.name + '\'].message()">Ok&lt;/button>',
                    onOpen: function (event) {
                        setTimeout(function () {
                            $(event.box).find('.w2ui-btn').focus();
                        }, 25);
                    }
                };
            }
            w2utils.message.call(this, {
                box: this.box,
                path: 'w2ui.' + this.name,
                title: '.w2ui-form-header:visible',
                body: '.w2ui-form-box'
            }, options);
        },

        validate: function (showErrors) {
            if (showErrors == null) showErrors = true;
            $().w2tag(); // hide all tags before validating
            // validate before saving
            var errors = [];
            for (var f = 0; f &lt; this.fields.length; f++) {
                var field = this.fields[f];
                if (this.record[field.name] == null) this.record[field.name] = '';
                switch (field.type) {
                    case 'int':
                        if (this.record[field.name] &amp;&amp; !w2utils.isInt(this.record[field.name])) {
                            errors.push({field: field, error: w2utils.lang('Not an integer')});
                        }
                        break;
                    case 'float':
                        if (this.record[field.name] &amp;&amp; !w2utils.isFloat(this.record[field.name])) {
                            errors.push({field: field, error: w2utils.lang('Not a float')});
                        }
                        break;
                    case 'money':
                        if (this.record[field.name] &amp;&amp; !w2utils.isMoney(this.record[field.name])) {
                            errors.push({field: field, error: w2utils.lang('Not in money format')});
                        }
                        break;
                    case 'color':
                    case 'hex':
                        if (this.record[field.name] &amp;&amp; !w2utils.isHex(this.record[field.name])) {
                            errors.push({field: field, error: w2utils.lang('Not a hex number')});
                        }
                        break;
                    case 'email':
                        if (this.record[field.name] &amp;&amp; !w2utils.isEmail(this.record[field.name])) {
                            errors.push({field: field, error: w2utils.lang('Not a valid email')});
                        }
                        break;
                    case 'checkbox':
                        // convert true/false
                        if (this.record[field.name] == true) this.record[field.name] = 1; else this.record[field.name] = 0;
                        break;
                    case 'date':
                        // format date before submit
                        if (!field.options.format) field.options.format = w2utils.settings.dateFormat;
                        if (this.record[field.name] &amp;&amp; !w2utils.isDate(this.record[field.name], field.options.format)) {
                            errors.push({
                                field: field,
                                error: w2utils.lang('Not a valid date') + ': ' + field.options.format
                            });
                        } else {
                        }
                        break;
                    case 'list':
                    case 'combo':
                        break;
                    case 'enum':
                        break;
                }
                // === check required - if field is '0' it should be considered not empty
                var val = this.record[field.name];
                if (field.required &amp;&amp; (val === '' || ($.isArray(val) &amp;&amp; val.length === 0) || ($.isPlainObject(val) &amp;&amp; $.isEmptyObject(val)))) {
                    errors.push({field: field, error: w2utils.lang('Required field')});
                }
                if (field.equalto &amp;&amp; this.record[field.name] != this.record[field.equalto]) {
                    errors.push({field: field, error: w2utils.lang('Field should be equal to ') + field.equalto});
                }
            }
            // event before
            var edata = this.trigger({phase: 'before', target: this.name, type: 'validate', errors: errors});
            if (edata.isCancelled === true) return;
            // show error
            if (showErrors) {
                for (var e = 0; e &lt; edata.errors.length; e++) {
                    var err = edata.errors[e];
                    if (err.field == null) continue;
                    if (err.field.type == 'radio') { // for radio and checkboxes
                        $($(err.field.el).parents('div')[0]).w2tag(err.error, {"class": 'w2ui-error'});
                    } else if (['enum', 'file'].indexOf(err.field.type) != -1) {
                        (function (err) {
                            setTimeout(function () {
                                var fld = $(err.field.el).data('w2field').helpers.multi;
                                $(err.field.el).w2tag(err.error);
                                $(fld).addClass('w2ui-error');
                            }, 1);
                        })(err);
                    } else {
                        $(err.field.el).w2tag(err.error, {"class": 'w2ui-error'});
                    }
                    this.goto(errors[0].field.page);
                }
            }
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            return errors;
        },

        getChanges: function () {
            var differ = function (record, original, result) {
                for (var i in record) {
                    if (typeof record[i] == "object") {
                        result[i] = differ(record[i], original[i] || {}, {});
                        if (!result[i] || $.isEmptyObject(result[i])) delete result[i];
                    } else if (record[i] != original[i]) {
                        result[i] = record[i];
                    }
                }
                return result;
            };
            return differ(this.record, this.original, {});
        },

        request: function (postData, callBack) { // if (1) param then it is call back if (2) then postData and callBack
            var obj = this;
            // check for multiple params
            if (typeof postData == 'function') {
                callBack = postData;
                postData = null;
            }
            if (postData == null) postData = {};
            if (!this.url || (typeof this.url == 'object' &amp;&amp; !this.url.get)) return;
            if (this.recid == null) this.recid = 0;
            // build parameters list
            var params = {};
            // add list params
            params['cmd'] = 'get';
            params['recid'] = this.recid;
            params['name'] = this.name;
            // append other params
            $.extend(params, this.postData);
            $.extend(params, postData);
            // event before
            var edata = this.trigger({
                phase: 'before',
                type: 'request',
                target: this.name,
                url: this.url,
                postData: params,
                httpHeaders: this.httpHeaders
            });
            if (edata.isCancelled === true) {
                if (typeof callBack == 'function') callBack({status: 'error', message: 'Request aborted.'});
                return;
            }
            // default action
            this.record = {};
            this.original = {};
            // call server to get data
            this.lock(w2utils.lang(this.msgRefresh));
            var url = edata.url;
            if (typeof edata.url == 'object' &amp;&amp; edata.url.get) url = edata.url.get;
            if (this.last.xhr) try {
                this.last.xhr.abort();
            } catch (e) {
            }
            // process url with routeData
            if (!$.isEmptyObject(obj.routeData)) {
                var info = w2utils.parseRoute(url);
                if (info.keys.length > 0) {
                    for (var k = 0; k &lt; info.keys.length; k++) {
                        if (obj.routeData[info.keys[k].name] == null) continue;
                        url = url.replace((new RegExp(':' + info.keys[k].name, 'g')), obj.routeData[info.keys[k].name]);
                    }
                }
            }
            var ajaxOptions = {
                type: 'POST',
                url: url,
                data: edata.postData,
                headers: edata.httpHeaders,
                dataType: 'text'   // expected from server
            }
            switch (w2utils.settings.dataType) {
                case 'HTTP':
                    ajaxOptions.data = String($.param(ajaxOptions.data, false)).replace(/%5B/g, '[').replace(/%5D/g, ']');
                    break
                case 'HTTPJSON':
                    ajaxOptions.data = {request: JSON.stringify(ajaxOptions.data)};
                    break;
                case 'RESTFULL':
                    ajaxOptions.type = 'GET';
                    ajaxOptions.data = String($.param(ajaxOptions.data, false)).replace(/%5B/g, '[').replace(/%5D/g, ']');
                    break;
                case 'RESTFULLJSON':
                    ajaxOptions.type = 'GET';
                    ajaxOptions.data = JSON.stringify(ajaxOptions.data);
                    ajaxOptions.contentType = 'application/json';
                    break;
                case 'JSON':
                    ajaxOptions.type = 'POST';
                    ajaxOptions.data = JSON.stringify(ajaxOptions.data);
                    ajaxOptions.contentType = 'application/json';
                    break;
            }
            if (this.method) ajaxOptions.type = this.method;
            this.last.xhr = $.ajax(ajaxOptions)
                .done(function (data, status, xhr) {
                    obj.unlock();
                    // event before
                    var edata = obj.trigger({phase: 'before', target: obj.name, type: 'load', xhr: xhr});
                    if (edata.isCancelled === true) {
                        if (typeof callBack == 'function') callBack({status: 'error', message: 'Request aborted.'});
                        return;
                    }
                    // parse server response
                    var data;
                    var responseText = obj.last.xhr.responseText;
                    if (status != 'error') {
                        // default action
                        if (responseText != null &amp;&amp; responseText !== '') {
                            // check if the onLoad handler has not already parsed the data
                            if (typeof responseText == "object") {
                                data = responseText;
                            } else {
                                // $.parseJSON or $.getJSON did not work because those expect perfect JSON data - where everything is in double quotes
                                //
                                // TODO: avoid (potentially malicious) code injection from the response.
                                try {
                                    eval('data = ' + responseText);
                                } catch (e) {
                                }
                            }
                            if (data == null) {
                                data = {
                                    status: 'error',
                                    message: w2utils.lang(obj.msgNotJSON),
                                    responseText: responseText
                                };
                            }
                            if (data['status'] == 'error') {
                                obj.error(w2utils.lang(data['message']));
                            } else {
                                obj.record = $.extend({}, data.record);
                                obj.original = $.extend({}, data.record);
                            }
                        }
                    } else {
                        obj.error('AJAX Error ' + xhr.status + ': ' + xhr.statusText);
                        data = {
                            status: 'error',
                            message: w2utils.lang(obj.msgAJAXerror),
                            responseText: responseText
                        };
                    }
                    // event after
                    obj.trigger($.extend(edata, {phase: 'after'}));
                    obj.refresh();
                    // call back
                    if (typeof callBack == 'function') callBack(data);
                })
                .fail(function (xhr, status, error) {
                    // trigger event
                    var errorObj = {status: status, error: error, rawResponseText: xhr.responseText};
                    var edata2 = obj.trigger({phase: 'before', type: 'error', error: errorObj, xhr: xhr});
                    if (edata2.isCancelled === true) return;
                    // default behavior
                    if (status != 'abort') {
                        var data;
                        try {
                            data = $.parseJSON(xhr.responseText);
                        } catch (e) {
                        }
                        console.log('ERROR: Server communication failed.',
                            '\n   EXPECTED:', {status: 'success', items: [{id: 1, text: 'item'}]},
                            '\n         OR:', {status: 'error', message: 'error message'},
                            '\n   RECEIVED:', typeof data == 'object' ? data : xhr.responseText);
                    }
                    // event after
                    obj.trigger($.extend(edata2, {phase: 'after'}));
                });
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        submit: function (postData, callBack) {
            return this.save(postData, callBack);
        },

        save: function (postData, callBack) {
            var obj = this;
            $(this.box).find(':focus').change(); // trigger onchange
            // check for multiple params
            if (typeof postData == 'function') {
                callBack = postData;
                postData = null;
            }
            // validation
            var errors = obj.validate(true);
            if (errors.length !== 0) return;
            // submit save
            if (postData == null) postData = {};
            if (!obj.url || (typeof obj.url == 'object' &amp;&amp; !obj.url.save)) {
                console.log("ERROR: Form cannot be saved because no url is defined.");
                return;
            }
            obj.lock(w2utils.lang(obj.msgSaving) + ' &lt;span id="' + obj.name + '_progress">&lt;/span>');
            // need timer to allow to lock
            setTimeout(function () {
                // build parameters list
                var params = {};
                // add list params
                params['cmd'] = 'save';
                params['recid'] = obj.recid;
                params['name'] = obj.name;
                // append other params
                $.extend(params, obj.postData);
                $.extend(params, postData);
                // clear up files
                obj.fields.forEach(function (item) {
                    if (item.type == 'file' &amp;&amp; Array.isArray(obj.record[item.field])) {
                        obj.record[item.field].forEach(function (fitem) {
                            delete fitem.file;
                        });
                    }
                });
                params.record = $.extend(true, {}, obj.record);
                // event before
                var edata = obj.trigger({
                    phase: 'before',
                    type: 'submit',
                    target: obj.name,
                    url: obj.url,
                    postData: params,
                    httpHeaders: obj.httpHeaders
                });
                if (edata.isCancelled === true) return;
                // default action
                var url = edata.url;
                if (typeof edata.url == 'object' &amp;&amp; edata.url.save) url = edata.url.save;
                if (obj.last.xhr) try {
                    obj.last.xhr.abort();
                } catch (e) {
                }
                // process url with routeData
                if (!$.isEmptyObject(obj.routeData)) {
                    var info = w2utils.parseRoute(url);
                    if (info.keys.length > 0) {
                        for (var k = 0; k &lt; info.keys.length; k++) {
                            if (obj.routeData[info.keys[k].name] == null) continue;
                            url = url.replace((new RegExp(':' + info.keys[k].name, 'g')), obj.routeData[info.keys[k].name]);
                        }
                    }
                }
                var ajaxOptions = {
                    type: 'POST',
                    url: url,
                    data: edata.postData,
                    headers: edata.httpHeaders,
                    dataType: 'text',   // expected from server
                    xhr: function () {
                        var xhr = new window.XMLHttpRequest();
                        // upload
                        xhr.upload.addEventListener("progress", function (evt) {
                            if (evt.lengthComputable) {
                                var edata3 = obj.trigger({
                                    phase: 'before',
                                    type: 'progress',
                                    total: evt.total,
                                    loaded: evt.loaded,
                                    originalEvent: evt
                                });
                                if (edata3.isCancelled === true) return;
                                // default behavior
                                var percent = Math.round(evt.loaded / evt.total * 100);
                                $('#' + obj.name + '_progress').text('' + percent + '%');
                                // event after
                                obj.trigger($.extend(edata3, {phase: 'after'}));
                            }
                        }, false);
                        return xhr;
                    }
                };
                switch (w2utils.settings.dataType) {
                    case 'HTTP':
                        ajaxOptions.data = String($.param(ajaxOptions.data, false)).replace(/%5B/g, '[').replace(/%5D/g, ']');
                        break;
                    case 'HTTPJSON':
                        ajaxOptions.data = {request: JSON.stringify(ajaxOptions.data)};
                        break;
                    case 'RESTFULL':
                        if (obj.recid !== 0 &amp;&amp; obj.recid != null) ajaxOptions.type = 'PUT';
                        ajaxOptions.data = String($.param(ajaxOptions.data, false)).replace(/%5B/g, '[').replace(/%5D/g, ']');
                        break;
                    case 'RESTFULLJSON':
                        if (obj.recid !== 0 &amp;&amp; obj.recid != null) ajaxOptions.type = 'PUT';
                        ajaxOptions.data = JSON.stringify(ajaxOptions.data);
                        ajaxOptions.contentType = 'application/json';
                        break;
                    case 'JSON':
                        ajaxOptions.type = 'POST';
                        ajaxOptions.data = JSON.stringify(ajaxOptions.data);
                        ajaxOptions.contentType = 'application/json';
                        break;
                }
                if (this.method) ajaxOptions.type = this.method;
                obj.last.xhr = $.ajax(ajaxOptions)
                    .done(function (data, status, xhr) {
                        obj.unlock();
                        // event before
                        var edata = obj.trigger({
                            phase: 'before',
                            target: obj.name,
                            type: 'save',
                            xhr: xhr,
                            status: status
                        });
                        if (edata.isCancelled === true) return;
                        // parse server response
                        var data;
                        var responseText = xhr.responseText;
                        if (status != 'error') {
                            // default action
                            if (responseText != null &amp;&amp; responseText !== '') {
                                // check if the onLoad handler has not already parsed the data
                                if (typeof responseText == "object") {
                                    data = responseText;
                                } else {
                                    // $.parseJSON or $.getJSON did not work because those expect perfect JSON data - where everything is in double quotes
                                    //
                                    // TODO: avoid (potentially malicious) code injection from the response.
                                    try {
                                        eval('data = ' + responseText);
                                    } catch (e) {
                                    }
                                }
                                if (data == null) {
                                    data = {
                                        status: 'error',
                                        message: w2utils.lang(obj.msgNotJSON),
                                        responseText: responseText
                                    };
                                }
                                if (data['status'] == 'error') {
                                    obj.error(w2utils.lang(data['message']));
                                } else {
                                    obj.original = $.extend({}, obj.record);
                                }
                            }
                        } else {
                            obj.error('AJAX Error ' + xhr.status + ': ' + xhr.statusText);
                            data = {
                                status: 'error',
                                message: w2utils.lang(obj.msgAJAXerror),
                                responseText: responseText
                            };
                        }
                        // event after
                        obj.trigger($.extend(edata, {phase: 'after'}));
                        obj.refresh();
                        // call back
                        if (data.status == 'success' &amp;&amp; typeof callBack == 'function') callBack(data);
                    })
                    .fail(function (xhr, status, error) {
                        // trigger event
                        var errorObj = {status: status, error: error, rawResponseText: xhr.responseText};
                        var edata2 = obj.trigger({phase: 'before', type: 'error', error: errorObj, xhr: xhr});
                        if (edata2.isCancelled === true) return;
                        // default behavior
                        console.log('ERROR: server communication failed. The server should return',
                            {status: 'success'}, 'OR', {status: 'error', message: 'error message'},
                            ', instead the AJAX request produced this: ', errorObj);
                        // event after
                        obj.trigger($.extend(edata2, {phase: 'after'}));
                    });
                // event after
                obj.trigger($.extend(edata, {phase: 'after'}));
            }, 50);
        },

        lock: function (msg, showSpinner) {
            var args = Array.prototype.slice.call(arguments, 0);
            args.unshift(this.box);
            setTimeout(function () {
                w2utils.lock.apply(window, args);
            }, 10);
        },

        unlock: function (speed) {
            var box = this.box;
            setTimeout(function () {
                w2utils.unlock(box, speed);
            }, 25); // needed timer so if server fast, it will not flash
        },

        goto: function (page) {
            if (this.page === page) return; // already on this page
            if (page != null) this.page = page;
            // if it was auto size, resize it
            if ($(this.box).data('auto-size') === true) $(this.box).height(0);
            this.refresh();
        },

        generateHTML: function () {
            var pages = []; // array for each page
            var group = '';
            var page;
            var column;
            var html;
            for (var f = 0; f &lt; this.fields.length; f++) {
                html = '';
                var field = this.fields[f];
                if (field.html == null) field.html = {};
                if (field.options == null) field.options = {};
                field.html = $.extend(true, {
                    caption: '',
                    span: 6,
                    attr: '',
                    text: '',
                    style: '',
                    page: 0,
                    column: 0
                }, field.html);
                if (page == null) page = field.html.page;
                if (column == null) column = field.html.column;
                if (field.html.caption === '') field.html.caption = field.name;
                // input control
                var input = '&lt;input name="' + field.name + '" class="w2ui-input" type="text" ' + field.html.attr + ' tabindex="' + (f + 1) + '"/>';
                switch (field.type) {
                    case 'pass':
                    case 'password':
                        input = '&lt;input name="' + field.name + '" class="w2ui-input" type = "password" ' + field.html.attr + ' tabindex="' + (f + 1) + '"/>';
                        break;
                    case 'checkbox':
                        input = '&lt;input name="' + field.name + '" class="w2ui-input" type="checkbox" ' + field.html.attr + ' tabindex="' + (f + 1) + '"/>';
                        break;
                    case 'radio':
                        input = '';
                        // normalized options
                        var items = field.options.items ? field.options.items : field.html.items;
                        if (!$.isArray(items)) items = [];
                        if (items.length > 0) {
                            items = w2obj.field.prototype.normMenu(items);
                        }
                        // generate
                        for (var i = 0; i &lt; items.length; i++) {
                            input += '&lt;label>&lt;input name="' + field.name + '" class="w2ui-input" type = "radio" ' + field.html.attr + ' value="' + items[i].id + '"/>' +
                                '&amp;#160;' + items[i].text + '&lt;/label>&lt;br/>';
                        }
                        break;
                    case 'select':
                        input = '&lt;select name="' + field.name + '" class="w2ui-input" ' + field.html.attr + ' tabindex="' + (f + 1) + '">';
                        // normalized options
                        var items = field.options.items ? field.options.items : field.html.items;
                        if (!$.isArray(items)) items = [];
                        if (items.length > 0) {
                            items = w2obj.field.prototype.normMenu(items);
                        }
                        // generate
                        for (var i = 0; i &lt; items.length; i++) {
                            input += '&lt;option value="' + items[i].id + '">' + items[i].text + '&lt;/option>';
                        }
                        input += '&lt;/select>';
                        break;
                    case 'textarea':
                        input = '&lt;textarea name="' + field.name + '" class="w2ui-input" ' + field.html.attr + ' tabindex="' + (f + 1) + '">&lt;/textarea>';
                        break;
                    case 'toggle':
                        input = '&lt;input name="' + field.name + '" type="checkbox" ' + field.html.attr + ' class="w2ui-input w2ui-toggle" tabindex="' + (f + 1) + '"/>&lt;div>&lt;div>&lt;/div>&lt;/div>';
                        break;
                    case 'html':
                    case 'custom':
                    case 'empty':
                        input = '';
                        break;

                }
                if (group !== '') {
                    if (page != field.html.page || column != field.html.column || (field.html.group &amp;&amp; (group != field.html.group))) {
                        pages[page][column] += '\n   &lt;/div>';
                        group = '';
                    }
                }
                if (field.html.group &amp;&amp; (group != field.html.group)) {
                    html += '\n   &lt;div class="w2ui-group-title">' + field.html.group + '&lt;/div>\n   &lt;div class="w2ui-group">';
                    group = field.html.group;
                }
                html += '\n      &lt;div class="w2ui-field ' + (field.html.span != null ? 'w2ui-span' + field.html.span : '') + '" style="' + field.html.style + '">' +
                    '\n         &lt;label>' + w2utils.lang(field.html.caption) + '&lt;/label>' +
                    '\n         &lt;div>' + input + w2utils.lang(field.html.text) + '&lt;/div>' +
                    '\n      &lt;/div>';
                if (pages[field.html.page] == null) pages[field.html.page] = [];
                if (pages[field.html.page][field.html.column] == null) pages[field.html.page][field.html.column] = '';
                pages[field.html.page][field.html.column] += html;
                page = field.html.page;
                column = field.html.column;
            }
            if (group !== '') pages[page][column] += '\n   &lt;/div>';
            if (this.tabs.tabs) {
                for (var i = 0; i &lt; this.tabs.tabs.length; i++) if (pages[i] == null) pages[i] = [];
            }
            // buttons if any
            var buttons = '';
            if (!$.isEmptyObject(this.actions)) {
                var addClass = '';
                buttons += '\n&lt;div class="w2ui-buttons">';
                for (var a in this.actions) { // it is an object
                    var act = this.actions[a];
                    var info = {caption: '', style: '', "class": ''};
                    if ($.isPlainObject(act)) {
                        if (act.caption) info.caption = act.caption;
                        if (act.style) info.style = act.style;
                        if (act["class"]) info['class'] = act['class'];
                    } else {
                        info.caption = a;
                        if (['save', 'update', 'create'].indexOf(a.toLowerCase()) != -1) info['class'] = 'w2ui-btn-blue'; else info['class'] = '';
                    }
                    buttons += '\n    &lt;button name="' + a + '" class="w2ui-btn ' + info['class'] + '" style="' + info.style + '">' +
                        w2utils.lang(info.caption) + '&lt;/button>';
                }
                buttons += '\n&lt;/div>';
            }
            html = '';
            for (var p = 0; p &lt; pages.length; p++) {
                html += '&lt;div class="w2ui-page page-' + p + '" ' + ((p === 0) ? '' : 'style="display: none;"') + '>&lt;div class="w2ui-column-container" style="display: flex;">';
                for (var c = 0; c &lt; pages[p].length; c++) {
                    html += '&lt;div class="w2ui-column col-' + c + '">' + (pages[p][c] || '') + '\n&lt;/div>';
                }
                html += '\n&lt;/div>&lt;/div>';
            }
            html += buttons;
            return html;
        },

        action: function (action, event) {
            var act = this.actions[action];
            var click = act;
            if ($.isPlainObject(act) &amp;&amp; act.onClick) click = act.onClick;
            // event before
            var edata = this.trigger({
                phase: 'before',
                target: action,
                type: 'action',
                click: click,
                originalEvent: event
            });
            if (edata.isCancelled === true) return;
            // default actions
            if (typeof click == 'function') click.call(this, event);
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
        },

        resize: function () {
            var obj = this;
            // event before
            var edata = this.trigger({phase: 'before', target: this.name, type: 'resize'});
            if (edata.isCancelled === true) return;
            // default behaviour
            var main = $(this.box).find('> div.w2ui-form-box');
            var header = $(this.box).find('> div .w2ui-form-header');
            var toolbar = $(this.box).find('> div .w2ui-form-toolbar');
            var tabs = $(this.box).find('> div .w2ui-form-tabs');
            var page = $(this.box).find('> div .w2ui-page');
            var cpage = $(this.box).find('> div .w2ui-page.page-' + this.page);
            var dpage = $(this.box).find('> div .w2ui-page.page-' + this.page + ' > div');
            var buttons = $(this.box).find('> div .w2ui-buttons');
            // if no height, calculate it
            resizeElements();
            if (parseInt($(this.box).height()) === 0 || $(this.box).data('auto-size') === true) {
                $(this.box).height(
                    (header.length > 0 ? w2utils.getSize(header, 'height') : 0) +
                    ((typeof this.tabs === 'object' &amp;&amp; $.isArray(this.tabs.tabs) &amp;&amp; this.tabs.tabs.length > 0) ? w2utils.getSize(tabs, 'height') : 0) +
                    ((typeof this.toolbar == 'object' &amp;&amp; $.isArray(this.toolbar.items) &amp;&amp; this.toolbar.items.length > 0) ? w2utils.getSize(toolbar, 'height') : 0) +
                    (page.length > 0 ? w2utils.getSize(dpage, 'height') + w2utils.getSize(cpage, '+height') + 12 : 0) +  // why 12 ???
                    (buttons.length > 0 ? w2utils.getSize(buttons, 'height') : 0)
                );
                $(this.box).data('auto-size', true);
            }
            resizeElements();
            if (this.toolbar &amp;&amp; this.toolbar.resize) this.toolbar.resize();
            if (this.tabs &amp;&amp; this.tabs.resize) this.tabs.resize();
            // event after
            obj.trigger($.extend(edata, {phase: 'after'}));

            function resizeElements() {
                // resize elements
                main.width($(obj.box).width()).height($(obj.box).height());
                toolbar.css('top', (obj.header !== '' ? w2utils.getSize(header, 'height') : 0));
                tabs.css('top', (obj.header !== '' ? w2utils.getSize(header, 'height') : 0)
                    + ((typeof obj.toolbar == 'object' &amp;&amp; $.isArray(obj.toolbar.items) &amp;&amp; obj.toolbar.items.length > 0) ? w2utils.getSize(toolbar, 'height') : 0));
                page.css('top', (obj.header !== '' ? w2utils.getSize(header, 'height') : 0)
                    + ((typeof obj.toolbar == 'object' &amp;&amp; $.isArray(obj.toolbar.items) &amp;&amp; obj.toolbar.items.length > 0) ? w2utils.getSize(toolbar, 'height') + 5 : 0)
                    + ((typeof obj.tabs === 'object' &amp;&amp; $.isArray(obj.tabs.tabs) &amp;&amp; obj.tabs.tabs.length > 0) ? w2utils.getSize(tabs, 'height') + 5 : 0));
                page.css('bottom', (buttons.length > 0 ? w2utils.getSize(buttons, 'height') : 0));
            }
        },

        refresh: function (field) {
            var time = (new Date()).getTime();
            var obj = this;
            if (!this.box) return;
            if (!this.isGenerated || $(this.box).html() == null) return;
            // event before
            var edata = this.trigger({
                phase: 'before',
                target: this.name,
                type: 'refresh',
                page: this.page,
                field: field
            });
            if (edata.isCancelled === true) return;
            if (field != null) {
                var from_field = obj.get(field, true);
                var to_field = from_field + 1;
            } else {
                // update what page field belongs
                $(this.box).find('input, textarea, select').each(function (index, el) {
                    var name = ($(el).attr('name') != null ? $(el).attr('name') : $(el).attr('id'));
                    var field = obj.get(name);
                    if (field) {
                        // find page
                        var div = $(el).parents('.w2ui-page');
                        if (div.length > 0) {
                            for (var i = 0; i &lt; 100; i++) {
                                if (div.hasClass('page-' + i)) {
                                    field.page = i;
                                    break;
                                }
                            }
                        }
                    }
                });
                // default action
                $(this.box).find('.w2ui-page').hide();
                $(this.box).find('.w2ui-page.page-' + this.page).show();
                $(this.box).find('.w2ui-form-header').html(this.header);
                // refresh tabs if needed
                if (typeof this.tabs === 'object' &amp;&amp; $.isArray(this.tabs.tabs) &amp;&amp; this.tabs.tabs.length > 0) {
                    $('#form_' + this.name + '_tabs').show();
                    this.tabs.active = this.tabs.tabs[this.page].id;
                    this.tabs.refresh();
                } else {
                    $('#form_' + this.name + '_tabs').hide();
                }
                // refresh tabs if needed
                if (typeof this.toolbar == 'object' &amp;&amp; $.isArray(this.toolbar.items) &amp;&amp; this.toolbar.items.length > 0) {
                    $('#form_' + this.name + '_toolbar').show();
                    this.toolbar.refresh();
                } else {
                    $('#form_' + this.name + '_toolbar').hide();
                }
                var from_field = 0;
                var to_field = this.fields.length;
            }
            // refresh values of fields
            for (var f = from_field; f &lt; to_field; f++) {
                var field = this.fields[f];
                if (field.name == null &amp;&amp; field.field != null) field.name = field.field;
                if (field.field == null &amp;&amp; field.name != null) field.field = field.name;
                field.$el = $(this.box).find('[name="' + String(field.name).replace(/\\/g, '\\\\') + '"]');
                field.el = field.$el[0];
                if (field.el == null) {
                    console.log('ERROR: Cannot associate field "' + field.name + '" with html control. Make sure html control exists with the same name.');
                    //return;
                }
                if (field.el) field.el.id = field.name;
                var tmp = $(field).data('w2field');
                if (tmp) tmp.clear();
                $(field.$el).off('change').on('change', function () {
                    var value_new = this.value;
                    var value_previous = obj.record[this.name] != null ? obj.record[this.name] : '';
                    var field = obj.get(this.name);
                    if (['list', 'enum', 'file'].indexOf(field.type) != -1 &amp;&amp; $(this).data('selected')) {
                        var nv = $(this).data('selected');
                        var cv = obj.record[this.name];
                        if ($.isArray(nv)) {
                            value_new = [];
                            for (var i = 0; i &lt; nv.length; i++) value_new[i] = $.extend(true, {}, nv[i]); // clone array
                        }
                        if ($.isPlainObject(nv)) {
                            value_new = $.extend(true, {}, nv); // clone object
                        }
                        if ($.isArray(cv)) {
                            value_previous = [];
                            for (var i = 0; i &lt; cv.length; i++) value_previous[i] = $.extend(true, {}, cv[i]); // clone array
                        }
                        if ($.isPlainObject(cv)) {
                            value_previous = $.extend(true, {}, cv); // clone object
                        }
                    }
                    if (['toggle', 'checkbox'].indexOf(field.type) != -1) {
                        value_new = ($(this).prop('checked') ? ($(this).prop('value') == 'on' ? true : $(this).prop('value')) : false);
                    }
                    // clean extra chars
                    if (['int', 'float', 'percent', 'money', 'currency'].indexOf(field.type) != -1) {
                        value_new = $(this).data('w2field').clean(value_new);
                    }
                    if (value_new === value_previous) return;
                    // event before
                    var edata2 = obj.trigger({
                        phase: 'before',
                        target: this.name,
                        type: 'change',
                        value_new: value_new,
                        value_previous: value_previous
                    });
                    if (edata2.isCancelled === true) {
                        $(this).val(obj.record[this.name]); // return previous value
                        return;
                    }
                    // default action
                    var val = this.value;
                    if (this.type == 'select') val = this.value;
                    if (this.type == 'checkbox') val = this.checked ? true : false;
                    if (this.type == 'radio') {
                        field.$el.each(function (index, el) {
                            if (el.checked) val = el.value;
                        });
                    }
                    if (['int', 'float', 'percent', 'money', 'currency', 'list', 'combo', 'enum', 'file', 'toggle'].indexOf(field.type) != -1) {
                        val = value_new;
                    }
                    if (['enum', 'file'].indexOf(field.type) != -1) {
                        if (val.length > 0) {
                            var fld = $(field.el).data('w2field').helpers.multi;
                            $(fld).removeClass('w2ui-error');
                        }
                    }
                    if (val === '' || val == null || ($.isArray(val) &amp;&amp; val.length === 0) || ($.isPlainObject(val) &amp;&amp; $.isEmptyObject(val))) {
                        val = null;
                    }
                    obj.record[this.name] = val;
                    // event after
                    obj.trigger($.extend(edata2, {phase: 'after'}));
                });
                // required
                if (field.required) {
                    $(field.el).parent().parent().addClass('w2ui-required');
                } else {
                    $(field.el).parent().parent().removeClass('w2ui-required');
                }
                // disabled
                if (field.disabled != null) {
                    if (field.disabled) {
                        $(field.el).prop('readonly', true);
                    } else {
                        $(field.el).prop('readonly', false);
                    }
                }
                // hidden
                if (field.hidden) {
                    $(field.el).parent().parent().hide();
                } else {
                    $(field.el).parent().parent().show();
                }
            }
            // attach actions on buttons
            $(this.box).find('button, input[type=button]').each(function (index, el) {
                $(el).off('click').on('click', function (event) {
                    var action = this.value;
                    if (this.id) action = this.id;
                    if (this.name) action = this.name;
                    obj.action(action, event);
                });
            });
            // init controls with record
            for (var f = from_field; f &lt; to_field; f++) {
                var field = this.fields[f];
                var value = (this.record[field.name] != null ? this.record[field.name] : '');
                if (!field.el) continue;
                if (!$(field.el).hasClass('w2ui-input')) $(field.el).addClass('w2ui-input');
                field.type = String(field.type).toLowerCase();
                if (!field.options) field.options = {};
                switch (field.type) {
                    case 'text':
                    case 'textarea':
                    case 'email':
                    case 'pass':
                    case 'password':
                        field.el.value = value;
                        break;
                    case 'int':
                    case 'float':
                    case 'money':
                    case 'currency':
                    case 'percent':
                        // issue #761
                        field.el.value = value;
                        $(field.el).w2field($.extend({}, field.options, {type: field.type}));
                        break;
                    case 'hex':
                    case 'alphanumeric':
                    case 'color':
                    case 'date':
                    case 'time':
                        field.el.value = value;
                        $(field.el).w2field($.extend({}, field.options, {type: field.type}));
                        break;
                    case 'toggle':
                        if (w2utils.isFloat(value)) value = parseFloat(value);
                        $(field.el).prop('checked', (value ? true : false));
                        this.record[field.name] = (value ? value : false);
                        break;
                    // enums
                    case 'list':
                    case 'combo':
                        if (field.type == 'list') {
                            var tmp_value = ($.isPlainObject(value) ? value.id : ($.isPlainObject(field.options.selected) ? field.options.selected.id : value));
                            // normalized options
                            if (!field.options.items) field.options.items = [];
                            var items = field.options.items;
                            if ($.isArray(items) &amp;&amp; items.length > 0 &amp;&amp; !$.isPlainObject(items[0])) {
                                field.options.items = w2obj.field.prototype.normMenu(items);
                            }
                            // find value from items
                            for (var i = 0; i &lt; field.options.items.length; i++) {
                                var item = field.options.items[i];
                                if (item.id == tmp_value) {
                                    value = $.extend(true, {}, item);
                                    obj.record[field.name] = value;
                                    break;
                                }
                            }
                        } else if (field.type == 'combo' &amp;&amp; !$.isPlainObject(value)) {
                            field.el.value = value;
                        } else if ($.isPlainObject(value) &amp;&amp; value.text != null) {
                            field.el.value = value.text;
                        } else {
                            field.el.value = '';
                        }
                        if (!$.isPlainObject(value)) value = {};
                        $(field.el).w2field($.extend({}, field.options, {type: field.type, selected: value}));
                        break;
                    case 'enum':
                    case 'file':
                        if (!$.isArray(value)) value = [];
                        $(field.el).w2field($.extend({}, field.options, {type: field.type, selected: value}));
                        break;

                    // standard HTML
                    case 'select':
                        // generate options
                        var items = field.options.items;
                        if (items != null &amp;&amp; items.length > 0) {
                            items = w2obj.field.prototype.normMenu(items);
                            $(field.el).html('');
                            for (var it = 0; it &lt; items.length; it++) {
                                $(field.el).append('&lt;option value="' + items[it].id + '">' + items[it].text + '&lt;/option');
                            }
                        }
                        $(field.el).val(value);
                        break;
                    case 'radio':
                        $(field.$el).prop('checked', false).each(function (index, el) {
                            if ($(el).val() == value) $(el).prop('checked', true);
                        });
                        break;
                    case 'checkbox':
                        $(field.el).prop('checked', value ? true : false);
                        break;
                    case 'html':
                    case 'custom':
                    case 'empty':
                        break;
                    default:
                        $(field.el).val(value);
                        $(field.el).w2field($.extend({}, field.options, {type: field.type}));
                        break;
                }
            }
            // wrap pages in div
            var tmp = $(this.box).find('.w2ui-page');
            for (var i = 0; i &lt; tmp.length; i++) {
                if ($(tmp[i]).find('> *').length > 1) $(tmp[i]).wrapInner('&lt;div>&lt;/div>');
            }
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            this.resize();
            return (new Date()).getTime() - time;
        },

        render: function (box) {
            var time = (new Date()).getTime();
            var obj = this;
            if (typeof box == 'object') {
                // remove from previous box
                if ($(this.box).find('#form_' + this.name + '_tabs').length > 0) {
                    $(this.box).removeAttr('name')
                        .removeClass('w2ui-reset w2ui-form')
                        .html('');
                }
                this.box = box;
            }
            if (!this.isGenerated) return;
            if (!this.box) return;
            // event before
            var edata = this.trigger({
                phase: 'before',
                target: this.name,
                type: 'render',
                box: (box != null ? box : this.box)
            });
            if (edata.isCancelled === true) return;
            // default actions
            if ($.isEmptyObject(this.original) &amp;&amp; !$.isEmptyObject(this.record)) {
                this.original = $.extend(true, {}, this.record);
            }
            var html = '&lt;div class="w2ui-form-box">' +
                (this.header !== '' ? '&lt;div class="w2ui-form-header">' + this.header + '&lt;/div>' : '') +
                '    &lt;div id="form_' + this.name + '_toolbar" class="w2ui-form-toolbar" style="display: none">&lt;/div>' +
                '    &lt;div id="form_' + this.name + '_tabs" class="w2ui-form-tabs" style="display: none">&lt;/div>' +
                this.formHTML +
                '&lt;/div>';
            $(this.box).attr('name', this.name)
                .addClass('w2ui-reset w2ui-form')
                .html(html);
            if ($(this.box).length > 0) $(this.box)[0].style.cssText += this.style;

            // init toolbar regardless it is defined or not
            if (typeof this.toolbar.render !== 'function') {
                this.toolbar = $().w2toolbar($.extend({}, this.toolbar, {name: this.name + '_toolbar', owner: this}));
                this.toolbar.on('click', function (event) {
                    var edata = obj.trigger({
                        phase: 'before',
                        type: 'toolbar',
                        target: event.target,
                        originalEvent: event
                    });
                    if (edata.isCancelled === true) return;
                    // no default action
                    obj.trigger($.extend(edata, {phase: 'after'}));
                });
            }
            if (typeof this.toolbar == 'object' &amp;&amp; typeof this.toolbar.render == 'function') {
                this.toolbar.render($('#form_' + this.name + '_toolbar')[0]);
            }
            // init tabs regardless it is defined or not
            if (typeof this.tabs.render !== 'function') {
                this.tabs = $().w2tabs($.extend({}, this.tabs, {
                    name: this.name + '_tabs',
                    owner: this,
                    active: this.tabs.active
                }));
                this.tabs.on('click', function (event) {
                    obj.goto(this.get(event.target, true));
                });
            }
            if (typeof this.tabs == 'object' &amp;&amp; typeof this.tabs.render == 'function') {
                this.tabs.render($('#form_' + this.name + '_tabs')[0]);
                if (this.tabs.active) this.tabs.click(this.tabs.active);
            }
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            // after render actions
            this.resize();
            var url = (typeof this.url != 'object' ? this.url : this.url.get);
            if (url &amp;&amp; this.recid !== 0 &amp;&amp; this.recid != null) {
                this.request();
            } else {
                this.refresh();
            }
            // attach to resize event
            if ($('.w2ui-layout').length === 0) { // if there is layout, it will send a resize event
                this.tmp_resize = function (event) {
                    w2ui[obj.name].resize();
                };
                $(window).off('resize', 'body').on('resize', 'body', this.tmp_resize);
            }
            // focus on load
            function focusEl() {
                var inputs = $(obj.box).find('div:not(.w2ui-field-helper) > input, select, textarea, div > label:nth-child(1) > :radio').not('.file-input');
                if (inputs.length > obj.focus) inputs[obj.focus].focus();
            }

            if (this.focus >= 0) {
                setTimeout(function () {
                    // if not rendered in 10ms, then wait 500ms
                    if ($(obj.box).find('input, select, textarea').length === 0) {
                        setTimeout(focusEl, 500); // need timeout to allow form to render
                    } else {
                        focusEl();
                    }
                }, 10);
            }
            return (new Date()).getTime() - time;
        },

        destroy: function () {
            // event before
            var edata = this.trigger({phase: 'before', target: this.name, type: 'destroy'});
            if (edata.isCancelled === true) return;
            // clean up
            if (typeof this.toolbar == 'object' &amp;&amp; this.toolbar.destroy) this.toolbar.destroy();
            if (typeof this.tabs == 'object' &amp;&amp; this.tabs.destroy) this.tabs.destroy();
            if ($(this.box).find('#form_' + this.name + '_tabs').length > 0) {
                $(this.box)
                    .removeAttr('name')
                    .removeClass('w2ui-reset w2ui-form')
                    .html('');
            }
            delete w2ui[this.name];
            // event after
            this.trigger($.extend(edata, {phase: 'after'}));
            $(window).off('resize', 'body')
        }
    };

    $.extend(w2form.prototype, w2utils.event);
    w2obj.form = w2form;
})(jQuery);


/*** EXPORTS FROM exports-loader ***/
exports["w2ui"] = (w2ui);
exports["w2alert"] = (w2alert);
exports["w2popup"] = (w2popup);
exports["w2utils"] = (w2utils);
exports["w2confirm"] = (w2confirm);


/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = {"locale":"ru-RU","dateFormat":"dd/mm/yyyy","timeFormat":"h24","currency":"^[-+]?[0-9]*[\\.]?[0-9]+RUB$","currencyPrefix":"","currencySuffix":"руб","groupSymbol":"","decimalSymbol":",","float":"^[-]?[0-9]*[\\.]?[0-9]+$","shortmonths":["Янв","Фев","Мар","Апр","Май","Июн","Июл","Авг","Сен","Окт","Ноя","Дек"],"fullmonths":["Январь","Февраль","Март","Апрель","Май","Июнь","Июль","Август","Сентябрь","Октябрь","Ноябрь","Декабрь"],"shortdays":["П","В","С","Ч","П","С","В"],"fulldays":["Понедельник","Вторник","Среда","Четверг","Пятница","Суббота","Воскресенье"],"phrases":{"Add new record":"Добавить новую запись","Add New":"Добавить","All Fields":"Все поля","Are you sure you want to delete selected records?":"Вы действительно хотите удалить выделенные записи?","Attach files by dragging and dropping or Click to Select":"Перетащите файлы сюда или нажмите чтобы выбрать","begins with":"начинается с","begins":"начинается","between":"между","buffered":"буфер","Clear Search":"Очистить поиск","Column":"Колонка","Confirmation":"Подтверждение","contains":"содержит","Delete Confirmation":"Подтверждение удаления","Delete selected records":"Удалить выбранные записи","Delete":"Удалить","Edit selected record":"Изменить выделенную запись","Edit":"Просмотр/Изменение","ends with":"заканчивается на","ends":"заканчивается","Hide":"Скрыть","in":"в","is":"равняется","Loading...":"Загрузка...","Line #":"Нумерация строк","Multi Fields":"Несколько полей","No items found":"Ничего не найдено","No":"Нет","none":"пусто","Not a float":"Не натуральное число","Not a hex number":"Не шестнадцатеричное число","Not a valid date":"Неверный формат","Not a valid email":"Неверный e-mail","Not alpha-numeric":"Не буквенно-цифровой текст","Not an integer":"Не целое число","Not in money format":"Не денежный формат","not in":"не в","Notification":"Уведомление","of":"из","Ok":"OK","Open Search Fields":"Открыть поля поиска","Record ID":"Запись","Records":"Записей","Refreshing...":"Обновление...","Reload data in the list":"Обновить список","Remove":"Удалить","Required field":"Обязательное поле","Restore Default State":"Размеры по умолчанию","Reset Column Size":"Восстановить размер колонок","Reset":"Очистить","reset":"Очистить","Return data is not in JSON format. See console for more information.":"Возвращенные данные не в формате JSON. Смотрите в консоли ошибки.","Save changed records":"Сохранить измененные записи","Save Grid State":"Сохранить состояние таблицы","Save":"Сохранить","save":"Сохранить","Saving...":"Сохранение","Search took":"Поиск занял","Search":"Поиск","Search...":"Поиск...","sec":"сек","Select Search Field":"Выбрать поля поиска","selected":"выделено","Server Response":"Ответ сервера","Show":"Показать","Show/hide columns":"Показать/скрыть колонки","Skip":"Пропустить","Sorting took":"Сортировка заняла","Toggle Line Numbers":"Вкл/Выкл. номера строк","undo":"Отмена","Yes":"Да","Yesterday":"Вчера"}}

/***/ })
/******/ ]);
//# sourceMappingURL=main.bandle.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#default">default</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.3</a> on Wed Aug 02 2017 10:00:27 GMT+0800 (RTZ 7 (зима))
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
